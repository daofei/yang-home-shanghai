__text_start:
__start:
    003A E5CF      LDI	R28,0x5F
    003B E0D4      LDI	R29,4
    003C BFCD      OUT	0x3D,R28
    003D BFDE      OUT	0x3E,R29
    003E 51C0      SUBI	R28,0x10
    003F 40D0      SBCI	R29,0
    0040 EA0A      LDI	R16,0xAA
    0041 8308      STD	Y+0,R16
    0042 2400      CLR	R0
    0043 E7E3      LDI	R30,0x73
    0044 E0F0      LDI	R31,0
    0045 E010      LDI	R17,0
    0046 38E3      CPI	R30,0x83
    0047 07F1      CPC	R31,R17
    0048 F011      BEQ	0x004B
    0049 9201      ST	R0,Z+
    004A CFFB      RJMP	0x0046
    004B 8300      STD	Z+0,R16
    004C E6E0      LDI	R30,0x60
    004D E0F0      LDI	R31,0
    004E E6A0      LDI	R26,0x60
    004F E0B0      LDI	R27,0
    0050 E010      LDI	R17,0
    0051 37E3      CPI	R30,0x73
    0052 07F1      CPC	R31,R17
    0053 F021      BEQ	0x0058
    0054 95C8      LPM
    0055 9631      ADIW	R30,1
    0056 920D      ST	R0,X+
    0057 CFF9      RJMP	0x0051
    0058 D001      RCALL	_main
_exit:
    0059 CFFF      RJMP	_exit
_main:
  ot                   --> Y+13
  t                    --> Y+0
  door_minitor_count   --> R10
    005A 97EF      SBIW	R28,0x3F
    005B 972F      SBIW	R28,0xF
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\main.c
(0001) #include <stdio.h>
(0002) #include <stdlib.h>
(0003) #include <string.h>
(0004) 
(0005) #include<iom16v.h>
(0006) #include <macros.h>
(0007) 
(0008) #include "uart.h"
(0009) #include "wg26.h"
(0010) #include "util.h"
(0011) #include "tips.h"
(0012) #include "timer.h"
(0013) #include "ringandscreen.h"
(0014) #include "eeprom.h"
(0015) #include "password.h"
(0016) #include "locker.h"
(0017) 
(0018) int main(void)
(0019) {
(0020)     unsigned int door_minitor_count = 0;
    005C 24AA      CLR	R10
    005D 24BB      CLR	R11
(0021)     passwordItem_t t, ot;
(0022) 	
(0023)     uart0_init();
    005E 940E0625  CALL	_uart0_init
(0024)     wg26_init_interrupt();
    0060 D082      RCALL	_wg26_init_interrupt
(0025)     tips_port_init();
    0061 D146      RCALL	_tips_port_init
(0026)     timer_init();
    0062 D366      RCALL	_timer_init
(0027)     at24c256_init();
    0063 D444      RCALL	_at24c256_init
(0028) 	locker_init();
    0064 D405      RCALL	_locker_init
(0029) 	doorandscreen_init();
    0065 D430      RCALL	_doorandscreen_init
(0030) 
(0031)     t.flags = PASSWORDFLAGS_ID;
    0066 E081      LDI	R24,1
    0067 8388      STD	Y+0,R24
(0032)     t.idCard = 1163690;
    0068 EA4A      LDI	R20,0xAA
    0069 EC51      LDI	R21,0xC1
    006A E161      LDI	R22,0x11
    006B 940E07C3  CALL	0x7C3
(0033)     t.passwordH = 1;
    006D E041      LDI	R20,1
    006E 940E0753  CALL	0x753
    0070 940E0822  CALL	0x822
(0034)     t.passwordL = 1;
    0072 E041      LDI	R20,1
    0073 940E0753  CALL	0x753
    0075 940E07BC  CALL	0x7BC
(0035)     insertPasswordItem(0, t);
    0077 967A      ADIW	R30,0x1A
    0078 940E0792  CALL	0x792
    007A 5E26      SUBI	R18,0xE6
    007B 4F3F      SBCI	R19,0xFF
    007C 2700      CLR	R16
    007D D1C1      RCALL	_insertPasswordItem
(0036) 
(0037)     t.flags = PASSWORDFLAGS_PASSWORD;
    007E E082      LDI	R24,2
    007F 8388      STD	Y+0,R24
(0038)     t.idCard = 0;
    0080 E040      LDI	R20,0
    0081 940E0753  CALL	0x753
    0083 940E081D  CALL	0x81D
(0039)     t.passwordH = 1135642406;
    0085 E246      LDI	R20,0x26
    0086 E857      LDI	R21,0x87
    0087 EB60      LDI	R22,0xB0
    0088 E473      LDI	R23,0x43
    0089 940E07FD  CALL	0x7FD
(0040)     t.passwordL = 100;
    008B E644      LDI	R20,0x64
    008C 940E0753  CALL	0x753
    008E 940E07BC  CALL	0x7BC
(0041)     insertPasswordItem(1, t);
    0090 96B7      ADIW	R30,0x27
    0091 940E0792  CALL	0x792
    0093 5D29      SUBI	R18,0xD9
    0094 4F3F      SBCI	R19,0xFF
    0095 E001      LDI	R16,1
    0096 D1A8      RCALL	_insertPasswordItem
(0042) 
(0043)     t.flags = PASSWORDFLAGS_PASSWORD;
    0097 E082      LDI	R24,2
    0098 8388      STD	Y+0,R24
(0044)     t.idCard = 0;
    0099 E040      LDI	R20,0
    009A 940E0753  CALL	0x753
    009C 940E081D  CALL	0x81D
(0045)     t.passwordH = 1314159265;
    009E EA41      LDI	R20,0xA1
    009F E75A      LDI	R21,0x7A
    00A0 E564      LDI	R22,0x54
    00A1 E47E      LDI	R23,0x4E
    00A2 940E07FD  CALL	0x7FD
(0046)     t.passwordL = 1;
    00A4 E041      LDI	R20,1
    00A5 940E0753  CALL	0x753
    00A7 940E07BC  CALL	0x7BC
(0047)     insertPasswordItem(2, t);
    00A9 96F4      ADIW	R30,0x34
    00AA 940E0792  CALL	0x792
    00AC 5C2C      SUBI	R18,0xCC
    00AD 4F3F      SBCI	R19,0xFF
    00AE E002      LDI	R16,2
    00AF D18F      RCALL	_insertPasswordItem
(0048) 
(0049)     t.flags = PASSWORDFLAGS_ID;
    00B0 E081      LDI	R24,1
    00B1 8388      STD	Y+0,R24
(0050)     t.idCard = 1392618;
    00B2 EE4A      LDI	R20,0xEA
    00B3 E35F      LDI	R21,0x3F
    00B4 E165      LDI	R22,0x15
    00B5 940E07C3  CALL	0x7C3
(0051)     t.passwordH = 1;
    00B7 E041      LDI	R20,1
    00B8 940E0753  CALL	0x753
    00BA 940E0822  CALL	0x822
(0052)     t.passwordL = 1;
    00BC E041      LDI	R20,1
    00BD 940E0753  CALL	0x753
    00BF 940E07BC  CALL	0x7BC
(0053)     insertPasswordItem(3, t);
    00C1 5BEF      SUBI	R30,0xBF
    00C2 4FFF      SBCI	R31,0xFF
    00C3 940E0792  CALL	0x792
    00C5 5B2F      SUBI	R18,0xBF
    00C6 4F3F      SBCI	R19,0xFF
    00C7 E003      LDI	R16,3
    00C8 D176      RCALL	_insertPasswordItem
(0054) 
(0055) 	writePasswordItemNum(4);
    00C9 E004      LDI	R16,4
    00CA D199      RCALL	_writePasswordItemNum
    00CB C011      RJMP	0x00DD
(0056) 
(0057)     while(1)
(0058)     {
(0059) 		door_minitor_count++;
    00CC 01C5      MOVW	R24,R10
    00CD 9601      ADIW	R24,1
    00CE 015C      MOVW	R10,R24
(0060) 		if(door_minitor_count>20)
    00CF E184      LDI	R24,0x14
    00D0 E090      LDI	R25,0
    00D1 158A      CP	R24,R10
    00D2 059B      CPC	R25,R11
    00D3 F430      BCC	0x00DA
(0061) 		{
(0062) 			//door open.
(0063) 			if(check_door())
    00D4 D3D0      RCALL	_check_door
    00D5 2300      TST	R16
    00D6 F009      BEQ	0x00D8
(0064) 			{
(0065) 				tips_err();
    00D7 D0EC      RCALL	_tips_err
(0066) 			}
(0067) 			door_minitor_count = 0;
    00D8 24AA      CLR	R10
    00D9 24BB      CLR	R11
(0068) 		}
(0069) 		delay_ms(500);
    00DA EF04      LDI	R16,0xF4
    00DB E011      LDI	R17,1
    00DC D0BE      RCALL	_delay_ms
    00DD CFEE      RJMP	0x00CC
(0070)     }
(0071)     return 0;
    00DE 2700      CLR	R16
    00DF 2711      CLR	R17
    00E0 96EF      ADIW	R28,0x3F
    00E1 962F      ADIW	R28,0xF
    00E2 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\wg26.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "password.h"
(0004) #include "timer.h"
(0005) 
(0006) //pc0 input wg26 d0, pc1 input wg26 d1.
(0007) //wg26 d0 is 0, d1 is 1.
(0008) void wg26_init_interrupt(void)
(0009) {
(0010)     //pc0,pc1 input mode.
(0011)     DDRC &= 0xfc;
_wg26_init_interrupt:
    00E3 B384      IN	R24,0x14
    00E4 7F8C      ANDI	R24,0xFC
    00E5 BB84      OUT	0x14,R24
(0012)     //上拉。
(0013)     PORTC |= 0x03;
    00E6 B385      IN	R24,0x15
    00E7 6083      ORI	R24,3
    00E8 BB85      OUT	0x15,R24
(0014)     //enable interrupt.
(0015)     //pd2 input mode.
(0016)     DDRD &= 0xfb;
    00E9 B381      IN	R24,0x11
    00EA 7F8B      ANDI	R24,0xFB
    00EB BB81      OUT	0x11,R24
(0017) 	//
(0018) 	PORTD |= 0x04;
    00EC 9A92      SBI	0x12,2
(0019) 	
(0020)     SREG |= 0x80;
    00ED 9478      BSET	7
(0021)     //int0 enable.
(0022)     GICR |= 0x40;
    00EE B78B      IN	R24,0x3B
    00EF 6480      ORI	R24,0x40
    00F0 BF8B      OUT	0x3B,R24
(0023)     //int0 fall edge.
(0024)     MCUCR |= 0x02;
    00F1 B785      IN	R24,0x35
    00F2 6082      ORI	R24,2
    00F3 BF85      OUT	0x35,R24
(0025)     return;
    00F4 9508      RET
(0026) }
(0027) //diable reader.
(0028) static void disable_reader(void)
(0029) {
(0030)     GICR &= 0xbf;
_disable_reader:
    00F5 B78B      IN	R24,0x3B
    00F6 7B8F      ANDI	R24,0xBF
    00F7 BF8B      OUT	0x3B,R24
(0031)     return;
    00F8 9508      RET
(0032) }
(0033) //enable reader.
(0034) static void enable_reader(void)
(0035) {
(0036)     GICR |= 0x40;
_enable_reader:
    00F9 B78B      IN	R24,0x3B
    00FA 6480      ORI	R24,0x40
    00FB BF8B      OUT	0x3B,R24
(0037)     return;
    00FC 9508      RET
_id_reader_check:
  id_code              --> Y+0
    00FD D533      RCALL	push_arg4
(0038) }
(0039) 
(0040) //id card id.
(0041) static unsigned long id_code = 0;
(0042) //read flags.
(0043) static unsigned int id_reader_flags = 0;
(0044) //read count.
(0045) static char read_count = 0;
(0046) //define reader flags.
(0047) #define IDREADERFLAG_WAITING 0x0000
(0048) #define IDREADERFLAG_READING 0x0001
(0049) #define IDREADERFLAG_READED 0x0002
(0050) //id code check.
(0051) static char id_reader_check(unsigned long id_code)
(0052) {
(0053)     return 0;
    00FE 2700      CLR	R16
    00FF 9624      ADIW	R28,4
    0100 9508      RET
_read_time_out:
  timer                --> R10
    0101 940E066A  CALL	push_gset3
    0103 2EA0      MOV	R10,R16
    0104 9722      SBIW	R28,2
(0054) }
(0055) 
(0056) //read timeout.
(0057) static void read_time_out(char timer)
(0058) {
(0059)     if(timer == IDREADERTIMEOUTTIMER)
    0105 20AA      TST	R10
    0106 F009      BEQ	0x0108
    0107 C03E      RJMP	0x0146
(0060)     {
(0061)         //disable reader.
(0062)         disable_reader();
    0108 DFEC      RCALL	_disable_reader
(0063)         id_reader_flags = IDREADERFLAG_READED;
    0109 E082      LDI	R24,2
    010A 940E087A  CALL	0x87A
(0064)         //read ok.
(0065)         if(read_count==26) //id card.
    010C 91800066  LDS	R24,read_count
    010E 318A      CPI	R24,0x1A
    010F F511      BNE	0x0132
(0066)         {
(0067)             if(!id_reader_check(id_code))
    0110 91200062  LDS	R18,id_code+2
    0112 91300063  LDS	R19,id_code+3
    0114 91000060  LDS	R16,id_code
    0116 91100061  LDS	R17,id_code+1
    0118 DFE4      RCALL	_id_reader_check
    0119 2300      TST	R16
    011A F009      BEQ	0x011C
    011B C021      RJMP	0x013D
(0068)             {
(0069)                 id_code &= 0x01fffffe;
    011C EF4E      LDI	R20,0xFE
    011D EF5F      LDI	R21,0xFF
    011E EF6F      LDI	R22,0xFF
    011F E071      LDI	R23,1
    0120 940E07A7  CALL	0x7A7
    0122 940E07CA  CALL	0x7CA
    0124 940E0780  CALL	0x780
(0070)                 id_code >>= 1;
    0126 9456      LSR	R5
    0127 9447      ROR	R4
    0128 9437      ROR	R3
    0129 9427      ROR	R2
    012A 940E0780  CALL	0x780
(0071)                 password_handle(IDREADEDIDCARD, id_code);
    012C 8248      STD	Y+0,R4
    012D 8259      STD	Y+1,R5
    012E 0191      MOVW	R18,R2
    012F 2700      CLR	R16
    0130 D163      RCALL	_password_handle
(0072)             }
(0073)         }
    0131 C00B      RJMP	0x013D
(0074)         else if(read_count==4)//keypad input.
    0132 91800066  LDS	R24,read_count
    0134 3084      CPI	R24,4
    0135 F439      BNE	0x013D
    0136 940E07A7  CALL	0x7A7
(0075)         {
(0076)             password_handle(IDREADEDKEYPAD, id_code);
    0138 8248      STD	Y+0,R4
    0139 8259      STD	Y+1,R5
    013A 0191      MOVW	R18,R2
    013B E001      LDI	R16,1
    013C D157      RCALL	_password_handle
(0077)         }
(0078)         //enable reader.
(0079)         enable_reader();
    013D DFBB      RCALL	_enable_reader
(0080)         id_reader_flags = IDREADERFLAG_WAITING;
    013E 2422      CLR	R2
    013F 2433      CLR	R3
    0140 92300065  STS	id_reader_flags+1,R3
    0142 92200064  STS	id_reader_flags,R2
(0081)         read_count = 0;
    0144 92200066  STS	read_count,R2
(0082)     }
(0083)     return;
    0146 9622      ADIW	R28,2
    0147 D51A      RCALL	pop_gset3
    0148 9508      RET
_set_id_reading_status:
    0149 D522      RCALL	push_gset2
    014A 9722      SBIW	R28,2
(0084) }
(0085) //set status.
(0086) static void set_id_reading_status(void)
(0087) {
(0088)     if(id_reader_flags!=IDREADERFLAG_READING)
    014B 91800064  LDS	R24,id_reader_flags
    014D 91900065  LDS	R25,id_reader_flags+1
    014F 3081      CPI	R24,1
    0150 E0E0      LDI	R30,0
    0151 079E      CPC	R25,R30
    0152 F0A9      BEQ	0x0168
(0089)     {
(0090)         id_reader_flags = IDREADERFLAG_READING;
    0153 E081      LDI	R24,1
    0154 940E087A  CALL	0x87A
    0156 940E077B  CALL	0x77B
(0091)         id_code = 0;
    0158 93500061  STS	id_code+1,R21
    015A 93400060  STS	id_code,R20
    015C 93700063  STS	id_code+3,R23
    015E 93600062  STS	id_code+2,R22
(0092)         //1*100ms.
(0093)         set_timer(IDREADERTIMEOUTTIMER, 1, read_time_out);
    0160 E584      LDI	R24,0x54
    0161 E090      LDI	R25,0
    0162 8399      STD	Y+1,R25
    0163 8388      STD	Y+0,R24
    0164 E021      LDI	R18,1
    0165 E030      LDI	R19,0
    0166 2700      CLR	R16
    0167 D270      RCALL	_set_timer
(0094)     }
(0095)     return;
    0168 9622      ADIW	R28,2
    0169 D4F6      RCALL	pop_gset2
    016A 9508      RET
_int0_isr:
    016B D547      RCALL	push_lset
    016C D4FF      RCALL	push_gset2
(0096) }
(0097) //pull id card id and keypad input.
(0098) #pragma interrupt_handler int0_isr:2
(0099) void int0_isr(void)
(0100) {
(0101)     set_id_reading_status();
    016D DFDB      RCALL	_set_id_reading_status
(0102)     if(!(PINC&0x02))
    016E 9999      SBIC	0x13,1
    016F C013      RJMP	0x0183
    0170 940E07A7  CALL	0x7A7
(0103)     {
(0104)         id_code <<= 1;
    0172 0C22      LSL	R2
    0173 1C33      ROL	R3
    0174 1C44      ROL	R4
    0175 1C55      ROL	R5
    0176 940E0780  CALL	0x780
    0178 940E079C  CALL	0x79C
(0105)         id_code |= 1;
    017A 2A24      OR	R2,R20
    017B 2A35      OR	R3,R21
    017C 2A46      OR	R4,R22
    017D 2A57      OR	R5,R23
    017E 940E0780  CALL	0x780
    0180 940E086E  CALL	0x86E
(0106)         ++read_count;
(0107)     }
    0182 C00C      RJMP	0x018F
(0108)     else if(!(PINC&0x01))
    0183 9998      SBIC	0x13,0
    0184 C00A      RJMP	0x018F
    0185 940E07A7  CALL	0x7A7
(0109)     {
(0110)         id_code <<= 1;
    0187 0C22      LSL	R2
    0188 1C33      ROL	R3
    0189 1C44      ROL	R4
    018A 1C55      ROL	R5
    018B 940E0780  CALL	0x780
    018D 940E086E  CALL	0x86E
(0111)         ++read_count;
(0112)     }
(0113)     return;
    018F D4D0      RCALL	pop_gset2
    0190 D535      RCALL	pop_lset
    0191 9518      RETI
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\util.c
(0001) #include "util.h"
(0002) 
(0003) #define XTAL    8
(0004) void delay_1ms(void)
(0005) {
(0006)     int i;
(0007)     //XTAL*143-2 = 1142
(0008)     for(i=1;i<1142;i++);
_delay_1ms:
  i                    --> R16
    0192 E001      LDI	R16,1
    0193 E010      LDI	R17,0
    0194 5F0F      SUBI	R16,0xFF
    0195 4F1F      SBCI	R17,0xFF
    0196 3706      CPI	R16,0x76
    0197 E0E4      LDI	R30,4
    0198 071E      CPC	R17,R30
    0199 F3D4      BLT	0x0194
    019A 9508      RET
_delay_ms:
  i                    --> R20
  ms                   --> R22
    019B D4D0      RCALL	push_gset2
    019C 01B8      MOVW	R22,R16
(0009) }
(0010) //=========================================
(0011) void delay_ms(int ms)
(0012) {
(0013)     int i=0;
    019D 2744      CLR	R20
    019E 2755      CLR	R21
    019F C003      RJMP	0x01A3
(0014)     while(i<ms)
(0015)     {
(0016)         delay_1ms();
    01A0 DFF1      RCALL	_delay_1ms
(0017)         i++;
    01A1 5F4F      SUBI	R20,0xFF
    01A2 4F5F      SBCI	R21,0xFF
    01A3 1746      CP	R20,R22
    01A4 0757      CPC	R21,R23
    01A5 F3D4      BLT	0x01A0
    01A6 D4B9      RCALL	pop_gset2
    01A7 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\tips.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "tips.h"
(0005) #include "util.h"
(0006) 
(0007) #define BEEP_ON (PORTB&=0xdf)
(0008) #define BEEP_OFF (PORTB|=0x20)
(0009) #define LED_ON (PORTB&=0xbf)
(0010) #define LED_OFF (PORTB|=0x40)
(0011) 
(0012) //pb5 beep,pb6 led.
(0013) void tips_port_init(void)
(0014) {
(0015)     //PINB5 & PINB6 OUTPUT AND pull-up resistors.
(0016)     PORTB |= 0x60;
_tips_port_init:
    01A8 B388      IN	R24,0x18
    01A9 6680      ORI	R24,0x60
    01AA BB88      OUT	0x18,R24
(0017)     DDRB |= 0x60;
    01AB B387      IN	R24,0x17
    01AC 6680      ORI	R24,0x60
    01AD BB87      OUT	0x17,R24
(0018)     return;
    01AE 9508      RET
(0019) }
(0020) //led on.
(0021) void tips_led_on(void)
(0022) {
(0023)     LED_ON;
_tips_led_on:
    01AF B388      IN	R24,0x18
    01B0 7B8F      ANDI	R24,0xBF
    01B1 BB88      OUT	0x18,R24
(0024)     return;
    01B2 9508      RET
(0025) }
(0026) //led off.
(0027) void tips_led_off(void)
(0028) {
(0029)     LED_OFF;
_tips_led_off:
    01B3 9AC6      SBI	0x18,6
(0030)     return;
    01B4 9508      RET
(0031) }
(0032) //beep on.
(0033) void tips_beep_on(void)
(0034) {
(0035)     BEEP_ON;
_tips_beep_on:
    01B5 B388      IN	R24,0x18
    01B6 7D8F      ANDI	R24,0xDF
    01B7 BB88      OUT	0x18,R24
(0036)     return;
    01B8 9508      RET
(0037) }
(0038) //beep off.
(0039) void tips_beep_off(void)
(0040) {
(0041)     BEEP_OFF;
_tips_beep_off:
    01B9 9AC5      SBI	0x18,5
(0042)     return;
    01BA 9508      RET
(0043) }
(0044) //__------__ 6 pices.pice per 0.4 seconds.
(0045) void tips_ok(void)
(0046) {
(0047)     LED_ON;
_tips_ok:
    01BB B388      IN	R24,0x18
    01BC 7B8F      ANDI	R24,0xBF
    01BD BB88      OUT	0x18,R24
    01BE 940E083C  CALL	0x83C
(0048)     BEEP_ON;
(0049)     //2.4 seconds.
(0050)     delay_ms(400);
    01C0 DFDA      RCALL	_delay_ms
(0051)     LED_OFF;
    01C1 9AC6      SBI	0x18,6
(0052)     BEEP_OFF;
    01C2 9AC5      SBI	0x18,5
(0053)     return;
    01C3 9508      RET
(0054) }
(0055) //_-_-___-_-_
(0056) void tips_err(void)
(0057) {
(0058)     BEEP_ON;
_tips_err:
    01C4 940E07B0  CALL	0x7B0
(0059)     delay_ms(100);
    01C6 DFD4      RCALL	_delay_ms
(0060)     BEEP_OFF;
    01C7 9AC5      SBI	0x18,5
(0061)     delay_ms(100);
    01C8 E604      LDI	R16,0x64
    01C9 E010      LDI	R17,0
    01CA DFD0      RCALL	_delay_ms
    01CB 940E07B0  CALL	0x7B0
(0062)     BEEP_ON;
(0063)     delay_ms(100);
    01CD DFCD      RCALL	_delay_ms
(0064)     BEEP_OFF;
    01CE 9AC5      SBI	0x18,5
(0065)  
(0066)     delay_ms(200);
    01CF EC08      LDI	R16,0xC8
    01D0 E010      LDI	R17,0
    01D1 DFC9      RCALL	_delay_ms
    01D2 940E07B0  CALL	0x7B0
(0067)  
(0068)     BEEP_ON;
(0069)     delay_ms(100);
    01D4 DFC6      RCALL	_delay_ms
(0070)     BEEP_OFF;
    01D5 9AC5      SBI	0x18,5
(0071)     delay_ms(100);
    01D6 E604      LDI	R16,0x64
    01D7 E010      LDI	R17,0
    01D8 DFC2      RCALL	_delay_ms
    01D9 940E07B0  CALL	0x7B0
(0072)     BEEP_ON;
(0073)     delay_ms(100);
    01DB DFBF      RCALL	_delay_ms
(0074)     BEEP_OFF;
    01DC 9AC5      SBI	0x18,5
(0075)     return;
    01DD 9508      RET
(0076) }
(0077) //_----_-_-_
(0078) void tips_id_ok(void)
(0079) {
(0080)     BEEP_ON;
_tips_id_ok:
    01DE B388      IN	R24,0x18
    01DF 7D8F      ANDI	R24,0xDF
    01E0 BB88      OUT	0x18,R24
(0081)     delay_ms(200);
    01E1 EC08      LDI	R16,0xC8
    01E2 E010      LDI	R17,0
    01E3 DFB7      RCALL	_delay_ms
(0082)     BEEP_OFF;
    01E4 9AC5      SBI	0x18,5
(0083)     delay_ms(200);
    01E5 EC08      LDI	R16,0xC8
    01E6 E010      LDI	R17,0
    01E7 DFB3      RCALL	_delay_ms
    01E8 940E07B0  CALL	0x7B0
(0084) 
(0085)     BEEP_ON;
(0086)     delay_ms(100);
    01EA DFB0      RCALL	_delay_ms
(0087)     BEEP_OFF;
    01EB 9AC5      SBI	0x18,5
(0088)     delay_ms(100);
    01EC E604      LDI	R16,0x64
    01ED E010      LDI	R17,0
    01EE DFAC      RCALL	_delay_ms
    01EF 940E07B0  CALL	0x7B0
(0089)     BEEP_ON;
(0090)     delay_ms(100);
    01F1 DFA9      RCALL	_delay_ms
(0091)     BEEP_OFF;
    01F2 9AC5      SBI	0x18,5
(0092)     return;
    01F3 9508      RET
    01F4 940E083C  CALL	0x83C
(0093) }
(0094) //__------__-----__
(0095) void tips_ring_on(void)
(0096) {
(0097)     BEEP_ON;
(0098)     //2.4 seconds.
(0099)     delay_ms(400);
_tips_ring_on:
    01F6 DFA4      RCALL	_delay_ms
(0100)     BEEP_OFF;
    01F7 9AC5      SBI	0x18,5
(0101)     delay_ms(400);
    01F8 E900      LDI	R16,0x90
    01F9 E011      LDI	R17,1
    01FA DFA0      RCALL	_delay_ms
    01FB 940E083C  CALL	0x83C
(0102)     BEEP_ON;
(0103)     //2.4 seconds.
(0104)     delay_ms(400);
    01FD DF9D      RCALL	_delay_ms
(0105)     BEEP_OFF;
    01FE 9AC5      SBI	0x18,5
(0106)     return;
    01FF 9508      RET
_readPasswordItemNum:
  num                  --> Y+3
    0200 9724      SBIW	R28,4
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\password.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "log.h"
(0005) #include "locker.h"
(0006) #include "tips.h"
(0007) #include "timer.h"
(0008) #include "eeprom.h"
(0009) #include "password.h"
(0010) #include "ringandscreen.h"
(0011) 
(0012) //eeprom 
(0013) //addr: 0 number.
(0014) 
(0015) // 1: flags
(0016) // 2,3,4,5: id Card.
(0017) // 6,7,8,9: password H
(0018) // 10,11,12,13 :password L
(0019) 
(0020) // 14: flags
(0021) // 15,16,17,18: id Card.
(0022) // 19,20,21,22: password H
(0023) // 23,24,25,26 :password L
(0024) 
(0025) unsigned char readPasswordItemNum(void)
(0026) {
(0027)     unsigned char num = 0;
    0201 2422      CLR	R2
    0202 822B      STD	Y+3,R2
(0028) 
(0029)     rw24c256(&num, 1, 0, RW24C256READ);
    0203 E081      LDI	R24,1
    0204 838A      STD	Y+2,R24
    0205 940E0842  CALL	0x842
    0207 D2A7      RCALL	_rw24c256
(0030)     return num;
    0208 810B      LDD	R16,Y+3
    0209 9624      ADIW	R28,4
    020A 9508      RET
_readPasswordItem:
  t                    --> Y+16
  item                 --> Y+3
  index                --> R22
    020B D460      RCALL	push_gset2
    020C 2F62      MOV	R22,R18
    020D 01A8      MOVW	R20,R16
    020E 9761      SBIW	R28,0x11
(0031) }
(0032) 
(0033) passwordItem_t readPasswordItem(unsigned char index)
(0034) {
(0035)     passwordItem_t item;
(0036)     unsigned char t = 0;
    020F 2422      CLR	R2
    0210 8A28      STD	Y+16,R2
    0211 940E0803  CALL	0x803
    0213 940E0880  CALL	0x880
(0037) 
(0038)     rw24c256(&t, 1, index*13+1, RW24C256READ);
    0215 018E      MOVW	R16,R28
    0216 5F00      SUBI	R16,0xF0
    0217 4F1F      SBCI	R17,0xFF
    0218 D296      RCALL	_rw24c256
(0039)     item.flags = t;
    0219 8828      LDD	R2,Y+16
    021A 822B      STD	Y+3,R2
    021B 940E0803  CALL	0x803
(0040) 
(0041)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RW24C256READ);
    021D 9602      ADIW	R24,2
    021E 940E085E  CALL	0x85E
    0220 5F0C      SUBI	R16,0xFC
    0221 4F1F      SBCI	R17,0xFF
    0222 D28C      RCALL	_rw24c256
    0223 940E0803  CALL	0x803
(0042)     
(0043)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RW24C256READ);
    0225 9606      ADIW	R24,6
    0226 940E085E  CALL	0x85E
    0228 5F08      SUBI	R16,0xF8
    0229 4F1F      SBCI	R17,0xFF
    022A D284      RCALL	_rw24c256
    022B 940E0803  CALL	0x803
(0044) 	
(0045)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RW24C256READ);
    022D 960A      ADIW	R24,0xA
    022E 940E085E  CALL	0x85E
    0230 5F04      SUBI	R16,0xF4
    0231 4F1F      SBCI	R17,0xFF
    0232 D27C      RCALL	_rw24c256
(0046)     
(0047)     return item;
    0233 01CE      MOVW	R24,R28
    0234 9603      ADIW	R24,3
    0235 E00D      LDI	R16,0xD
    0236 E010      LDI	R17,0
    0237 935A      ST	R21,-Y
    0238 934A      ST	R20,-Y
    0239 939A      ST	R25,-Y
    023A 938A      ST	R24,-Y
    023B D4D2      RCALL	asgnblk
    023C 9661      ADIW	R28,0x11
    023D D422      RCALL	pop_gset2
    023E 9508      RET
_insertPasswordItem:
  item                 --> R20
  index                --> R22
    023F D42C      RCALL	push_gset2
    0240 01A9      MOVW	R20,R18
    0241 2F60      MOV	R22,R16
    0242 9723      SBIW	R28,3
    0243 940E07ED  CALL	0x7ED
    0245 940E0880  CALL	0x880
(0048) }
(0049) 
(0050) void insertPasswordItem(unsigned char index, passwordItem_t item)
(0051) {
(0052)     rw24c256(&(item.flags), 1, index*13+1, RW24C256WRITE);
    0247 018A      MOVW	R16,R20
    0248 D266      RCALL	_rw24c256
    0249 940E07ED  CALL	0x7ED
(0053) 	
(0054)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RW24C256WRITE);
    024B 9602      ADIW	R24,2
    024C 940E0863  CALL	0x863
    024E 5F0F      SUBI	R16,0xFF
    024F 4F1F      SBCI	R17,0xFF
    0250 D25E      RCALL	_rw24c256
    0251 940E07ED  CALL	0x7ED
(0055) 	
(0056)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RW24C256WRITE);
    0253 9606      ADIW	R24,6
    0254 940E0863  CALL	0x863
    0256 5F0B      SUBI	R16,0xFB
    0257 4F1F      SBCI	R17,0xFF
    0258 D256      RCALL	_rw24c256
    0259 940E07ED  CALL	0x7ED
(0057) 	
(0058)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RW24C256WRITE);
    025B 960A      ADIW	R24,0xA
    025C 940E0863  CALL	0x863
    025E 5F07      SUBI	R16,0xF7
    025F 4F1F      SBCI	R17,0xFF
    0260 D24E      RCALL	_rw24c256
(0059) 	
(0060)     return;
    0261 9623      ADIW	R28,3
    0262 D3FD      RCALL	pop_gset2
    0263 9508      RET
_writePasswordItemNum:
  num                  --> Y+3
    0264 931A      ST	R17,-Y
    0265 930A      ST	R16,-Y
    0266 9723      SBIW	R28,3
(0061) }
(0062) 
(0063) void writePasswordItemNum(unsigned char num)
(0064) {
(0065)     rw24c256(&num, 1, 0, RW24C256WRITE);
    0267 2422      CLR	R2
    0268 822A      STD	Y+2,R2
    0269 940E0842  CALL	0x842
    026B D243      RCALL	_rw24c256
(0066)     return;
    026C 9625      ADIW	R28,5
    026D 9508      RET
_clear_pswd_status:
    026E D3FD      RCALL	push_gset2
    026F 940E079C  CALL	0x79C
(0067) }
(0068) 
(0069) #define PASSWORDREADIDCARDUNKOWN    0
(0070) #define PASSWORDREADIDCARDOK                1
(0071) #define PASSWORDREADIDANDPSWDOK         2
(0072) 
(0073) static unsigned char password_read_flags = 0;
(0074) static unsigned char current_index = 0;
(0075) static unsigned char input_err_count = 0;
(0076) 
(0077) //You input xxx then password is 1xxx.
(0078) static unsigned long passwordH = 1;
(0079) static unsigned long passwordL = 1;
(0080) 
(0081) static void clear_pswd_status(void)
(0082) {
(0083)     //clear last password input.
(0084)     passwordH = 1;
    0271 9350006B  STS	passwordH+1,R21
    0273 9340006A  STS	passwordH,R20
    0275 9370006D  STS	passwordH+3,R23
    0277 9360006C  STS	passwordH+2,R22
    0279 940E079C  CALL	0x79C
    027B 940E0814  CALL	0x814
(0085)     passwordL = 1;
(0086)     tips_led_off();
    027D DF35      RCALL	_tips_led_off
(0087)     password_read_flags = PASSWORDREADIDCARDUNKOWN;
    027E 2422      CLR	R2
    027F 92200067  STS	password_read_flags,R2
(0088)     current_index = 0;
    0281 92200068  STS	current_index,R2
(0089)     stop_timer(PASSWORDTIMEOUTTIMER);
    0283 E001      LDI	R16,1
    0284 D173      RCALL	_stop_timer
(0090)     return;
    0285 D3DA      RCALL	pop_gset2
    0286 9508      RET
(0091) }
(0092) 
(0093) //cannot input timeout.
(0094) static void cannot_input_time_out(char timer)
(0095) {
(0096)     if(timer==PASSWORDTIMEOUTTIMER)
_cannot_input_time_out:
  timer                --> R16
    0287 3001      CPI	R16,1
    0288 F419      BNE	0x028C
(0097)         input_err_count = 0;
    0289 2422      CLR	R2
    028A 92200069  STS	input_err_count,R2
(0098)     return;
    028C 9508      RET
_input_time_out:
  timer                --> R20
    028D D3E0      RCALL	push_gset1
    028E 2F40      MOV	R20,R16
(0099) }
(0100) 
(0101) //input timeout.
(0102) static void input_time_out(char timer)
(0103) {
(0104)     if(timer==PASSWORDTIMEOUTTIMER)
    028F 3041      CPI	R20,1
    0290 F409      BNE	0x0292
(0105)         clear_pswd_status();
    0291 DFDC      RCALL	_clear_pswd_status
(0106)     return;
    0292 D3DE      RCALL	pop_gset1
    0293 9508      RET
_password_handle:
  current_item         --> Y+25
  pswd_item_num        --> R10
  i                    --> R12
  item                 --> Y+12
  code                 --> Y+48
  type                 --> R14
    0294 933A      ST	R19,-Y
    0295 932A      ST	R18,-Y
    0296 D3CF      RCALL	push_gset5
    0297 2EE0      MOV	R14,R16
    0298 97A6      SBIW	R28,0x26
(0107) }
(0108) 
(0109) void password_handle(char type, unsigned long code)
(0110) {
(0111)     unsigned char pswd_item_num = 0;
    0299 24AA      CLR	R10
(0112)     unsigned char i;
(0113)     passwordItem_t item;
(0114) 
(0115) 	//on screen
(0116) 	screen_on();
    029A D202      RCALL	_screen_on
(0117)     //if input error count is too large.
(0118)     if(input_err_count>5)
    029B E085      LDI	R24,5
    029C 90200069  LDS	R2,input_err_count
    029E 1582      CP	R24,R2
    029F F458      BCC	0x02AB
(0119)     {
(0120)         clear_pswd_status();
    02A0 DFCD      RCALL	_clear_pswd_status
(0121)         tips_err();
    02A1 DF22      RCALL	_tips_err
(0122)         //set time out. 100ms*10*60
(0123)         set_timer(PASSWORDTIMEOUTTIMER, 600, cannot_input_time_out);
    02A2 E588      LDI	R24,0x58
    02A3 E090      LDI	R25,0
    02A4 8399      STD	Y+1,R25
    02A5 8388      STD	Y+0,R24
    02A6 E528      LDI	R18,0x58
    02A7 E032      LDI	R19,2
    02A8 E001      LDI	R16,1
    02A9 D12E      RCALL	_set_timer
(0124)         return;
    02AA C11A      RJMP	0x03C5
(0125)     }
(0126)  
(0127)     //read a card.
(0128)     if(type==IDREADEDIDCARD)
    02AB 20EE      TST	R14
    02AC F009      BEQ	0x02AE
    02AD C040      RJMP	0x02EE
(0129)     {
(0130)         clear_pswd_status();
    02AE DFBF      RCALL	_clear_pswd_status
(0131)         //read paswd item num.
(0132)         pswd_item_num = readPasswordItemNum();
    02AF DF50      RCALL	_readPasswordItemNum
    02B0 2EA0      MOV	R10,R16
(0133)         //loop find it.
(0134)         for(i=0;i<pswd_item_num;++i)
    02B1 24CC      CLR	R12
    02B2 C02E      RJMP	0x02E1
(0135)         {
(0136)             //read a item.
(0137)             item = readPasswordItem(i);
    02B3 940E0899  CALL	0x899
    02B5 DF55      RCALL	_readPasswordItem
(0138)             //if item need id card, and is this id card.
(0139)             if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
    02B6 842C      LDD	R2,Y+12
    02B7 FE20      SBRS	R2,0
    02B8 C027      RJMP	0x02E0
    02B9 01FE      MOVW	R30,R28
    02BA A820      LDD	R2,Z+48
    02BB A831      LDD	R3,Z+49
    02BC A842      LDD	R4,Z+50
    02BD A853      LDD	R5,Z+51
    02BE 01FE      MOVW	R30,R28
    02BF 8465      LDD	R6,Z+13
    02C0 8476      LDD	R7,Z+14
    02C1 8487      LDD	R8,Z+15
    02C2 8890      LDD	R9,Z+16
    02C3 940E07F3  CALL	0x7F3
    02C5 F009      BEQ	0x02C7
    02C6 C019      RJMP	0x02E0
(0140)             {
(0141)                 //need paswd.
(0142)                 if(item.flags&PASSWORDFLAGS_PASSWORD)
    02C7 842C      LDD	R2,Y+12
    02C8 FE21      SBRS	R2,1
    02C9 C00A      RJMP	0x02D4
(0143)                 {
(0144)                     //id card ok, but need password.
(0145)                     //tips_id_ok();
(0146)                     //id card ok, but not input password, led on.
(0147)                     tips_led_on();
    02CA DEE4      RCALL	_tips_led_on
(0148)                     current_index = i;
    02CB 92C00068  STS	current_index,R12
(0149)                     password_read_flags = PASSWORDREADIDCARDOK;
    02CD E081      LDI	R24,1
    02CE 93800067  STS	password_read_flags,R24
    02D0 940E084A  CALL	0x84A
(0150)                     //set time out. 100ms*10*30
(0151)                     set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    02D2 D105      RCALL	_set_timer
(0152)                 }
    02D3 C0F1      RJMP	0x03C5
(0153)                 else //only id card.
(0154)                 {
(0155)                     //record log
(0156)                     log(LOGTYPEIDOK, i, code, 0, 0);
    02D4 940E0758  CALL	0x758
    02D6 2D2C      MOV	R18,R12
    02D7 E001      LDI	R16,1
    02D8 D190      RCALL	_log
(0157)                     //clear pswd statuc.
(0158)                     clear_pswd_status();
    02D9 DF94      RCALL	_clear_pswd_status
(0159)                     tips_ok();
    02DA DEE0      RCALL	_tips_ok
(0160)                     locker_unlock();
    02DB D1A5      RCALL	_locker_unlock
(0161)                     //error count clear.
(0162)                     input_err_count = 0;
    02DC 2422      CLR	R2
    02DD 92200069  STS	input_err_count,R2
(0163)                 } //else
(0164)                 return;
    02DF C0E5      RJMP	0x03C5
    02E0 94C3      INC	R12
    02E1 14CA      CP	R12,R10
    02E2 F408      BCC	0x02E4
    02E3 CFCF      RJMP	0x02B3
(0165)             }  //if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
(0166)         }	  //for(i=0;i<pswd_item_num;++i)
(0167)         //unkown id card.
(0168)         log(LOGTYPEIDERR, 0, code, 0, 0);
    02E4 940E0758  CALL	0x758
    02E6 2722      CLR	R18
    02E7 E002      LDI	R16,2
    02E8 D180      RCALL	_log
(0169)         //clear password.
(0170)         clear_pswd_status();
    02E9 DF84      RCALL	_clear_pswd_status
(0171)         //error password and log.
(0172)         tips_err();
    02EA DED9      RCALL	_tips_err
    02EB 940E0830  CALL	0x830
(0173)         //error count ++
(0174)         ++input_err_count;
(0175)         return;
    02ED C0D7      RJMP	0x03C5
(0176)     }	  //if(type==IDREADEDIDCARD)
(0177)     else if(type==IDREADEDKEYPAD) // read a keypad input.
    02EE 2D8E      MOV	R24,R14
    02EF 3081      CPI	R24,1
    02F0 F009      BEQ	0x02F2
    02F1 C0D3      RJMP	0x03C5
(0178)     {
(0179)         code &= 0x0000000f;
    02F2 E04F      LDI	R20,0xF
    02F3 940E0753  CALL	0x753
    02F5 940E07CF  CALL	0x7CF
    02F7 940E07CA  CALL	0x7CA
    02F9 01FE      MOVW	R30,R28
    02FA AA20      STD	Z+48,R2
    02FB AA31      STD	Z+49,R3
    02FC AA42      STD	Z+50,R4
    02FD AA53      STD	Z+51,R5
(0180)         if(code == 0x0000000a)  //*
    02FE E04A      LDI	R20,0xA
    02FF 940E0753  CALL	0x753
    0301 940E07CF  CALL	0x7CF
    0303 940E0894  CALL	0x894
    0305 F411      BNE	0x0308
(0181)         {
(0182)             //clear password.
(0183)             clear_pswd_status();
    0306 DF67      RCALL	_clear_pswd_status
(0184)         }
    0307 C0BD      RJMP	0x03C5
(0185)         else if(code == 0x0000000b) //#
    0308 E04B      LDI	R20,0xB
    0309 940E0753  CALL	0x753
    030B 940E07CF  CALL	0x7CF
    030D 940E0894  CALL	0x894
    030F F009      BEQ	0x0311
    0310 C07D      RJMP	0x038E
(0186)         {
(0187)             //need id card password.
(0188)             if(password_read_flags==PASSWORDREADIDCARDOK)
    0311 91800067  LDS	R24,password_read_flags
    0313 3081      CPI	R24,1
    0314 F009      BEQ	0x0316
    0315 C035      RJMP	0x034B
(0189)             {
(0190)                 passwordItem_t current_item = readPasswordItem(current_index);
    0316 91200068  LDS	R18,current_index
    0318 018E      MOVW	R16,R28
    0319 5E07      SUBI	R16,0xE7
    031A 4F1F      SBCI	R17,0xFF
    031B DEEF      RCALL	_readPasswordItem
    031C 940E0772  CALL	0x772
(0191)                 //password is ok.
(0192)                 if((current_item.passwordH==passwordH)&&(current_item.passwordL==passwordL))
    031E 01FE      MOVW	R30,R28
    031F 8C66      LDD	R6,Z+30
    0320 8C77      LDD	R7,Z+31
    0321 A080      LDD	R8,Z+32
    0322 A091      LDD	R9,Z+33
    0323 940E07F3  CALL	0x7F3
    0325 F009      BEQ	0x0327
    0326 C017      RJMP	0x033E
    0327 940E0789  CALL	0x789
    0329 01FE      MOVW	R30,R28
    032A A062      LDD	R6,Z+34
    032B A073      LDD	R7,Z+35
    032C A084      LDD	R8,Z+36
    032D A095      LDD	R9,Z+37
    032E 940E07F3  CALL	0x7F3
    0330 F469      BNE	0x033E
    0331 940E0742  CALL	0x742
    0333 940E07D4  CALL	0x7D4
(0193)                 {
(0194)                     log(LOGTYPEIDANDPSWDOK, current_index, current_item.idCard, passwordH, passwordL);
    0335 E003      LDI	R16,3
    0336 D132      RCALL	_log
(0195)                     //clear password status.
(0196)                     clear_pswd_status();
    0337 DF36      RCALL	_clear_pswd_status
(0197)                     //unlock and write log.
(0198)                     tips_ok();
    0338 DE82      RCALL	_tips_ok
(0199)                     locker_unlock();
    0339 D147      RCALL	_locker_unlock
(0200)                     //error count clear.
(0201)                     input_err_count = 0;
    033A 2422      CLR	R2
    033B 92200069  STS	input_err_count,R2
(0202)                 }
    033D C087      RJMP	0x03C5
(0203)                 else //password is error.
(0204)                 {
(0205)                     log(LOGTYPEIDANDPSWDERR, current_index, current_item.idCard, passwordH, passwordL);
    033E 940E0789  CALL	0x789
    0340 940E0742  CALL	0x742
    0342 940E07D4  CALL	0x7D4
    0344 E004      LDI	R16,4
    0345 D123      RCALL	_log
(0206)                     //clear password.
(0207)                     clear_pswd_status();
    0346 DF27      RCALL	_clear_pswd_status
(0208)                     //error password and log.
(0209)                     tips_err();
    0347 DE7C      RCALL	_tips_err
    0348 940E0830  CALL	0x830
(0210)                     //error count ++.
(0211)                     ++input_err_count;
(0212)                 }
(0213)             }
    034A C07A      RJMP	0x03C5
(0214)             else //only password.
(0215)             {
(0216)                 //read paswd item num.
(0217)                 pswd_item_num = readPasswordItemNum();
    034B DEB4      RCALL	_readPasswordItemNum
    034C 2EA0      MOV	R10,R16
(0218)                 //loop find it.
(0219)                 for(i=0;i<pswd_item_num;++i)
    034D 24CC      CLR	R12
    034E C02C      RJMP	0x037B
(0220)                 {
(0221)                     //read a item.
(0222)                     item = readPasswordItem(i);
    034F 940E0899  CALL	0x899
    0351 DEB9      RCALL	_readPasswordItem
(0223)                     //if item need id card, and is this id card.
(0224)                     if((item.flags==PASSWORDFLAGS_PASSWORD)&&(item.passwordH==passwordH)
    0352 858C      LDD	R24,Y+12
    0353 3082      CPI	R24,2
    0354 F009      BEQ	0x0356
    0355 C024      RJMP	0x037A
    0356 940E0772  CALL	0x772
    0358 01FE      MOVW	R30,R28
    0359 8861      LDD	R6,Z+17
    035A 8872      LDD	R7,Z+18
    035B 8883      LDD	R8,Z+19
    035C 8894      LDD	R9,Z+20
    035D 940E07F3  CALL	0x7F3
    035F F4D1      BNE	0x037A
    0360 940E0789  CALL	0x789
    0362 01FE      MOVW	R30,R28
    0363 8865      LDD	R6,Z+21
    0364 8876      LDD	R7,Z+22
    0365 8887      LDD	R8,Z+23
    0366 8C90      LDD	R9,Z+24
    0367 940E07F3  CALL	0x7F3
    0369 F481      BNE	0x037A
    036A 940E0742  CALL	0x742
    036C 940E077B  CALL	0x77B
    036E 940E088A  CALL	0x88A
(0225)                         &&(item.passwordL==passwordL))
(0226)                     {
(0227)                         log(LOGTYPEPSWDOK, i, 0, passwordH, passwordL);
    0370 2D2C      MOV	R18,R12
    0371 E005      LDI	R16,5
    0372 D0F6      RCALL	_log
(0228)                         //clear password.
(0229)                         clear_pswd_status();
    0373 DEFA      RCALL	_clear_pswd_status
(0230)                         //password is right. unlock and log.
(0231)                         tips_ok();
    0374 DE46      RCALL	_tips_ok
(0232)                         locker_unlock();
    0375 D10B      RCALL	_locker_unlock
(0233)                         //error count clear.
(0234)                         input_err_count = 0;
    0376 2422      CLR	R2
    0377 92200069  STS	input_err_count,R2
(0235)                         return;
    0379 C04B      RJMP	0x03C5
    037A 94C3      INC	R12
    037B 14CA      CP	R12,R10
    037C F408      BCC	0x037E
    037D CFD1      RJMP	0x034F
(0236)                     }
(0237)                 }
(0238)                 //password is error.
(0239)                 log(LOGTYPEPSWDERR, 0, 0, passwordH, passwordL);
    037E 940E0789  CALL	0x789
    0380 940E0742  CALL	0x742
    0382 940E077B  CALL	0x77B
    0384 940E088A  CALL	0x88A
    0386 2722      CLR	R18
    0387 E006      LDI	R16,6
    0388 D0E0      RCALL	_log
(0240)                 //clear password.
(0241)                 clear_pswd_status();
    0389 DEE4      RCALL	_clear_pswd_status
(0242)                 //password is error, and log.
(0243)                 tips_err();
    038A DE39      RCALL	_tips_err
    038B 940E0830  CALL	0x830
(0244)                 //error count++.
(0245)                 ++input_err_count;
(0246)                 return;
    038D C037      RJMP	0x03C5
(0247)             }
(0248)         }
(0249)         else
(0250)         {
(0251)             tips_led_on();
    038E DE20      RCALL	_tips_led_on
    038F 940E084A  CALL	0x84A
(0252)             //set time out. 100ms*10*30
(0253)             set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    0391 D046      RCALL	_set_timer
    0392 940E0789  CALL	0x789
(0254)             passwordL = passwordL*10 + code;
    0394 E04A      LDI	R20,0xA
    0395 E050      LDI	R21,0
    0396 E060      LDI	R22,0
    0397 E070      LDI	R23,0
    0398 940E0885  CALL	0x885
    039A 018A      MOVW	R16,R20
    039B 019B      MOVW	R18,R22
    039C D297      RCALL	empy32u
    039D 0118      MOVW	R2,R16
    039E 0129      MOVW	R4,R18
    039F 01FE      MOVW	R30,R28
    03A0 A860      LDD	R6,Z+48
    03A1 A871      LDD	R7,Z+49
    03A2 A882      LDD	R8,Z+50
    03A3 A893      LDD	R9,Z+51
    03A4 0C26      ADD	R2,R6
    03A5 1C37      ADC	R3,R7
    03A6 1C48      ADC	R4,R8
    03A7 1C59      ADC	R5,R9
    03A8 9230006F  STS	passwordL+1,R3
    03AA 9220006E  STS	passwordL,R2
    03AC 92500071  STS	passwordL+3,R5
    03AE 92400070  STS	passwordL+2,R4
(0255)             //passwordH save password hight 9 num.
(0256)             if(passwordL>999999999)
    03B0 EF4F      LDI	R20,0xFF
    03B1 EC59      LDI	R21,0xC9
    03B2 E96A      LDI	R22,0x9A
    03B3 E37B      LDI	R23,0x3B
    03B4 1542      CP	R20,R2
    03B5 0553      CPC	R21,R3
    03B6 0564      CPC	R22,R4
    03B7 0575      CPC	R23,R5
    03B8 F460      BCC	0x03C5
(0257)             {
(0258)                 passwordH = passwordL;
    03B9 9230006B  STS	passwordH+1,R3
    03BB 9220006A  STS	passwordH,R2
    03BD 9250006D  STS	passwordH+3,R5
    03BF 9240006C  STS	passwordH+2,R4
    03C1 940E079C  CALL	0x79C
    03C3 940E0814  CALL	0x814
(0259)                 passwordL = 1;
(0260)             }
(0261)         }
(0262)     }
(0263)     return;
    03C5 96A6      ADIW	R28,0x26
    03C6 D29D      RCALL	pop_gset5
    03C7 9622      ADIW	R28,2
    03C8 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\timer.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "timer.h"
(0005) 
(0006) void timer_init(void)
(0007) {
(0008)     //enable interrupt.
(0009)     SREG |= 0x80;
_timer_init:
    03C9 9478      BSET	7
(0010)     //timer0 normal mode.ck/1024.
(0011)     TCCR0 |= 0x05;
    03CA B783      IN	R24,0x33
    03CB 6085      ORI	R24,5
    03CC BF83      OUT	0x33,R24
(0012)     //init TCNT0.
(0013)     TCNT0 = 0;
    03CD 2422      CLR	R2
    03CE BE22      OUT	0x32,R2
(0014)     //TIMSK
(0015)     //TIMSK |= 0x01;
(0016)     return; 
    03CF 9508      RET
(0017) }
(0018) //cpu timer0 start
(0019) static void t0_start(void)
(0020) {
(0021)     TIMSK |= 0x01;
_t0_start:
    03D0 B789      IN	R24,0x39
    03D1 6081      ORI	R24,1
    03D2 BF89      OUT	0x39,R24
(0022)     return;
    03D3 9508      RET
(0023) }
(0024) //cpu timer0 stop
(0025) static void t0_stop(void)
(0026) {
(0027)     TIMSK &= 0xfe;
_t0_stop:
    03D4 B789      IN	R24,0x39
    03D5 7F8E      ANDI	R24,0xFE
    03D6 BF89      OUT	0x39,R24
(0028)     return;
    03D7 9508      RET
_set_timer:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    03D8 D293      RCALL	push_gset2
    03D9 01B9      MOVW	R22,R18
    03DA 2F40      MOV	R20,R16
(0029) }
(0030) //
(0031) static timer_t g_timer[MAXTIMER];
(0032) //set timer and start timer. set value 0, need wait a cpu timer pice.
(0033) void set_timer(char timer, int value, timerCB cb)
(0034) {
(0035)     //value=0, stoped timer.
(0036)     g_timer[timer].value = value+1;
    03DB E084      LDI	R24,4
    03DC 9F84      MUL	R24,R20
    03DD 940E07A1  CALL	0x7A1
    03DF 01CB      MOVW	R24,R22
    03E0 9601      ADIW	R24,1
    03E1 8391      STD	Z+1,R25
    03E2 8380      STD	Z+0,R24
(0037)     g_timer[timer].cb = cb;
    03E3 E084      LDI	R24,4
    03E4 9F84      MUL	R24,R20
    03E5 940E0809  CALL	0x809
    03E7 800C      LDD	R0,Y+4
    03E8 801D      LDD	R1,Y+5
    03E9 8211      STD	Z+1,R1
    03EA 8200      STD	Z+0,R0
(0038)     if(g_timer[timer].value)
    03EB E084      LDI	R24,4
    03EC 9F84      MUL	R24,R20
    03ED 940E07A1  CALL	0x7A1
    03EF 8020      LDD	R2,Z+0
    03F0 8031      LDD	R3,Z+1
    03F1 2022      TST	R2
    03F2 F411      BNE	0x03F5
    03F3 2033      TST	R3
    03F4 F009      BEQ	0x03F6
(0039)         t0_start();
    03F5 DFDA      RCALL	_t0_start
(0040)     return;
    03F6 D269      RCALL	pop_gset2
    03F7 9508      RET
(0041) }
(0042) //stop timer and clean timer.
(0043) void stop_timer(char timer)
(0044) {
(0045)     if(g_timer[timer].value)
_stop_timer:
  timer                --> R16
    03F8 E084      LDI	R24,4
    03F9 9F80      MUL	R24,R16
    03FA 940E07A1  CALL	0x7A1
    03FC 8020      LDD	R2,Z+0
    03FD 8031      LDD	R3,Z+1
    03FE 2022      TST	R2
    03FF F411      BNE	0x0402
    0400 2033      TST	R3
    0401 F059      BEQ	0x040D
(0046)     {
(0047)         //stop this timer.
(0048)         g_timer[timer].value = 0;
    0402 E084      LDI	R24,4
    0403 9F80      MUL	R24,R16
    0404 940E07A1  CALL	0x7A1
    0406 940E0868  CALL	0x868
(0049)         g_timer[timer].cb = 0;
    0408 9F80      MUL	R24,R16
    0409 940E0809  CALL	0x809
    040B 8231      STD	Z+1,R3
    040C 8220      STD	Z+0,R2
(0050)     }
(0051)     return;
    040D 9508      RET
_timer0_isr:
  running_timer_count  --> R20
  i                    --> R22
    040E D2A4      RCALL	push_lset
    040F D25C      RCALL	push_gset2
(0052) }
(0053) //timer spank.
(0054) #pragma interrupt_handler timer0_isr:10
(0055) void timer0_isr(void)
(0056) {
(0057)     static char time_pices = 0;
(0058)     ++time_pices;
    0410 91800072  LDS	R24,time_pices
    0412 5F8F      SUBI	R24,0xFF
    0413 93800072  STS	time_pices,R24
(0059)     //200ms.
(0060)     if(time_pices == 2)
    0415 3082      CPI	R24,2
    0416 F009      BEQ	0x0418
    0417 C04E      RJMP	0x0466
(0061)     {
(0062)         char running_timer_count = 0;
    0418 2744      CLR	R20
(0063)         char i;
(0064)         for(i=0;i<MAXTIMER;i++)
    0419 2766      CLR	R22
    041A C042      RJMP	0x045D
(0065)         {
(0066)             if(g_timer[i].value>1)
    041B E084      LDI	R24,4
    041C 9F86      MUL	R24,R22
    041D 940E07A1  CALL	0x7A1
    041F 8020      LDD	R2,Z+0
    0420 8031      LDD	R3,Z+1
    0421 E081      LDI	R24,1
    0422 E090      LDI	R25,0
    0423 1582      CP	R24,R2
    0424 0593      CPC	R25,R3
    0425 F478      BCC	0x0435
(0067)             {
(0068)                 --g_timer[i].value;
    0426 E084      LDI	R24,4
    0427 9F86      MUL	R24,R22
    0428 0110      MOVW	R2,R0
    0429 E783      LDI	R24,0x73
    042A E090      LDI	R25,0
    042B 0E28      ADD	R2,R24
    042C 1E39      ADC	R3,R25
    042D 01F1      MOVW	R30,R2
    042E 8180      LDD	R24,Z+0
    042F 8191      LDD	R25,Z+1
    0430 9701      SBIW	R24,1
    0431 8391      STD	Z+1,R25
    0432 8380      STD	Z+0,R24
(0069)                 ++running_timer_count;
    0433 9543      INC	R20
(0070)             }
    0434 C027      RJMP	0x045C
(0071)             //timer call back.
(0072)             else if(g_timer[i].value==1)
    0435 E084      LDI	R24,4
    0436 9F86      MUL	R24,R22
    0437 940E07A1  CALL	0x7A1
    0439 8180      LDD	R24,Z+0
    043A 8191      LDD	R25,Z+1
    043B 3081      CPI	R24,1
    043C E0E0      LDI	R30,0
    043D 079E      CPC	R25,R30
    043E F4E9      BNE	0x045C
(0073)             {
(0074)                 g_timer[i].value = 0;
    043F E084      LDI	R24,4
    0440 9F86      MUL	R24,R22
    0441 940E07A1  CALL	0x7A1
    0443 940E0868  CALL	0x868
(0075)                 if(g_timer[i].cb)
    0445 9F86      MUL	R24,R22
    0446 01F0      MOVW	R30,R0
    0447 E785      LDI	R24,0x75
    0448 E090      LDI	R25,0
    0449 0FE8      ADD	R30,R24
    044A 1FF9      ADC	R31,R25
    044B 8020      LDD	R2,Z+0
    044C 8031      LDD	R3,Z+1
    044D 2022      TST	R2
    044E F411      BNE	0x0451
    044F 2033      TST	R3
    0450 F059      BEQ	0x045C
(0076)                 {
(0077)                     //disable cpu timer.
(0078)                     t0_stop();
    0451 DF82      RCALL	_t0_stop
(0079)                     (g_timer[i].cb)(i);
    0452 2F06      MOV	R16,R22
    0453 E084      LDI	R24,4
    0454 9F86      MUL	R24,R22
    0455 940E0809  CALL	0x809
    0457 81A0      LDD	R26,Z+0
    0458 81B1      LDD	R27,Z+1
    0459 01FD      MOVW	R30,R26
    045A D22A      RCALL	xicall
(0080)                     //enable cpu timer.
(0081)                     t0_start();
    045B DF74      RCALL	_t0_start
    045C 9563      INC	R22
    045D 3064      CPI	R22,4
    045E F408      BCC	0x0460
    045F CFBB      RJMP	0x041B
(0082)                 }
(0083)             }
(0084)         }
(0085)         time_pices = 0;
    0460 2422      CLR	R2
    0461 92200072  STS	time_pices,R2
(0086)         //if no timer running, stop cpu timer.
(0087)         if(!running_timer_count) t0_stop();
    0463 2344      TST	R20
    0464 F409      BNE	0x0466
    0465 DF6E      RCALL	_t0_stop
(0088)     }
(0089)     return;
    0466 D1F9      RCALL	pop_gset2
    0467 D25E      RCALL	pop_lset
    0468 9518      RETI
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\log.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "log.h"
(0004) 
(0005) void log(char type, unsigned char index, unsigned long id_code, unsigned long pswdH, unsigned long pswdL)
(0006) {
_log:
  pswdL                --> Y+12
  pswdH                --> Y+8
  id_code              --> Y+4
  index                --> Y+2
  type                 --> Y+0
    0469 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\locker.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "timer.h"
(0004) #include "util.h"
(0005) #include "locker.h"
(0006) 
(0007) #define LOCKERINIT (PORTB&=0xe7)
(0008) #define LOCKERUNLOCK (PORTB&=0xf7,PORTB|=0x10)
(0009) #define LOCKERLOCK (PORTB&=0xef,PORTB|=0x08)
(0010) 
(0011) void locker_init(void)
(0012) {
(0013)     //pb3 pb4 OUTPUT.
(0014)     DDRB |= 0x18;
_locker_init:
    046A B387      IN	R24,0x17
    046B 6188      ORI	R24,0x18
    046C BB87      OUT	0x17,R24
(0015)     //output low
(0016)     PORTB &= 0xe7;
    046D B388      IN	R24,0x18
    046E 7E87      ANDI	R24,0xE7
    046F BB88      OUT	0x18,R24
(0017)     return;
    0470 9508      RET
_unlock_time_out:
  timer                --> R20
    0471 D1FC      RCALL	push_gset1
    0472 2F40      MOV	R20,R16
(0018) }
(0019) 
(0020) //unlock timeout.
(0021) static void unlock_time_out(char timer)
(0022) {
(0023)     if(timer==UNLOCKTIMEOUTTIMER)
    0473 3042      CPI	R20,2
    0474 F451      BNE	0x047F
(0024)     {
(0025) 		LOCKERLOCK;
    0475 B388      IN	R24,0x18
    0476 7E8F      ANDI	R24,0xEF
    0477 BB88      OUT	0x18,R24
    0478 9AC3      SBI	0x18,3
(0026) 		delay_ms(600);
    0479 E508      LDI	R16,0x58
    047A E012      LDI	R17,2
    047B DD1F      RCALL	_delay_ms
(0027) 		LOCKERINIT;
    047C B388      IN	R24,0x18
    047D 7E87      ANDI	R24,0xE7
    047E BB88      OUT	0x18,R24
(0028) 	}
(0029)     return;
    047F D1F1      RCALL	pop_gset1
    0480 9508      RET
_locker_unlock:
    0481 9722      SBIW	R28,2
(0030) }
(0031) 
(0032) void locker_unlock(void)
(0033) {
(0034) 	LOCKERUNLOCK;
    0482 B388      IN	R24,0x18
    0483 7F87      ANDI	R24,0xF7
    0484 BB88      OUT	0x18,R24
    0485 9AC4      SBI	0x18,4
(0035)     delay_ms(600);
    0486 E508      LDI	R16,0x58
    0487 E012      LDI	R17,2
    0488 DD12      RCALL	_delay_ms
(0036) 	LOCKERINIT;
    0489 B388      IN	R24,0x18
    048A 7E87      ANDI	R24,0xE7
    048B BB88      OUT	0x18,R24
(0037) 	//set time out. 100ms*10*30
(0038) 	set_timer(UNLOCKTIMEOUTTIMER, 150, unlock_time_out);
    048C E58A      LDI	R24,0x5A
    048D E090      LDI	R25,0
    048E 8399      STD	Y+1,R25
    048F 8388      STD	Y+0,R24
    0490 E926      LDI	R18,0x96
    0491 E030      LDI	R19,0
    0492 E002      LDI	R16,2
    0493 DF44      RCALL	_set_timer
(0039) 	return;
    0494 9622      ADIW	R28,2
    0495 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\ringandscreen.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "timer.h"
(0007) #include "ringandscreen.h"
(0008) 
(0009) //door monitor input is pa0.
(0010) //screen power output pb7.
(0011) 
(0012) #define SCREEN_ON (PORTB &= 0x7f)
(0013) #define SCREEN_OFF (PORTB |= 0x80)
(0014) 
(0015) void doorandscreen_init(void)
(0016) {
(0017)     //PA0 INPUT.
(0018)     DDRA &= 0xfe;
_doorandscreen_init:
    0496 B38A      IN	R24,0x1A
    0497 7F8E      ANDI	R24,0xFE
    0498 BB8A      OUT	0x1A,R24
(0019) 	PORTA |= 0x01;
    0499 9AD8      SBI	0x1B,0
(0020)     //pb7 OUTPUT.
(0021)     DDRB |= 0x80;
    049A 9ABF      SBI	0x17,7
(0022)     //init screen off
(0023)     PORTB |= 0x80;
    049B 9AC7      SBI	0x18,7
(0024)     //init interrput.
(0025)     return;
    049C 9508      RET
(0026) }
(0027) 
(0028) /**
(0029) #define SCREEN_RESET_START (PORTC&=0xef)
(0030) #define SCREEN_RESET_STOP (PORTC|=0x10)
(0031) #define RING_ON (PORTC&=0xdf)
(0032) #define RING_OFF (PORTC&=0x20)
(0033) 
(0034) void ringandscreen_init(void)
(0035) {
(0036)     //PC0,PC1,PC2 INPUT.
(0037)     DDRC &= 0xf8;
(0038)     //PC3,PC4,PC5 OUTPUT.
(0039)     DDRC |= 0x38;
(0040)     //
(0041)     PORTC = 0xff;
(0042)     //init interrput.
(0043)     return;
(0044) }
(0045) 
(0046) static void disable_input(void)
(0047) {
(0048) 
(0049) }
(0050) 
(0051) static void enable_input(void)
(0052) {
(0053) 
(0054) }
(0055) 
(0056) void screen_on(void)
(0057) {
(0058)     if((PORTC&=0x04))
(0059)     {
(0060)         SCREEN_ON;
(0061)         delay_ms(500);
(0062)         SCREEN_RESET_START;
(0063)         delay_ms(100);
(0064)         SCREEN_RESET_STOP;
(0065)     }
(0066)     return;
(0067) }
(0068) 
(0069) void screen_off(void)
(0070) {
(0071)     SCREEN_OFF;
(0072)     return;
(0073) }
(0074) 
(0075) void ring_on(void)
(0076) {
(0077)     RING_ON;
(0078)     delay_ms(20);
(0079)     RING_OFF;
(0080)     return;
(0081) }
(0082) 
(0083) void ring_screen_timeout(char timer)
(0084) {
(0085)     if(timer==RINGANDSCREENINPUTTIMER)
(0086)     {
(0087)         screen_off();
(0088)     }
(0089) }
(0090) 
(0091) void door_minitor_timeout(char timer)
(0092) {
(0093)     if(timer==RINGANDSCREENINPUTTIMER)
(0094)     {
(0095)         tips_err();
(0096)         //start timer. 10s.
(0097)         set_timer(RINGANDSCREENINPUTTIMER, 140, door_minitor_timeout); 
(0098)     }
(0099) }
(0100) 
(0101) void input_isr(void)
(0102) {
(0103)     disable_input();
(0104)     //
(0105)     delay_ms(100);
(0106)     if(!(PINC&0x01)) //ring input.
(0107)     {
(0108)         screen_on();
(0109)         ring_on();
(0110)         tips_ring_on();
(0111)         //start timer. 50s.
(0112)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0113)     }
(0114)     else if(!(PIND&0x02)) //screen key input.
(0115)     {
(0116)         screen_on();
(0117)         delay_ms(800);
(0118)         //start timer. 50s.
(0119)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0120)     }
(0121)     enable_input();
(0122)     return;
(0123) }
(0124) **/
(0125) 
(0126) void screen_on(void)
(0127) {
(0128)     SCREEN_ON;
_screen_on:
    049D B388      IN	R24,0x18
    049E 778F      ANDI	R24,0x7F
    049F BB88      OUT	0x18,R24
(0129) 	delay_ms(25);
    04A0 E109      LDI	R16,0x19
    04A1 E010      LDI	R17,0
    04A2 DCF8      RCALL	_delay_ms
(0130) 	SCREEN_OFF;
    04A3 9AC7      SBI	0x18,7
(0131)     return;
    04A4 9508      RET
(0132) }
(0133) 
(0134) //when door open, return 1.
(0135) char check_door(void)
(0136) {
(0137)     return (PINA&0x01);
_check_door:
    04A5 B309      IN	R16,0x19
    04A6 7001      ANDI	R16,1
    04A7 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\eeprom.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "eeprom.h"
(0006) 
(0007) /* 一个通用的24C01－24C256共9种EEPROM的字节读写操作程序，   
(0008) 此程序有五个入口条件，分别为读写数据缓冲区指针,   
(0009) 进行读写的字节数，EEPROM首址，EEPROM控制字节，   
(0010) 以及EEPROM类型。此程序结构性良好，具有极好的容错性，程序机器码也不多:   
(0011) DataBuff为读写数据输入／输出缓冲区的首址   
(0012) Length 为要读写数据的字节数量   
(0013) Addr 为EEPROM的片内地址 AT24256为0～32767   
(0014) Control 为EEPROM的控制字节，具体形式为(1)(0)(1)(0)(A2)(A1)(A0)(R/W),其中R/W=1,   
(0015) 表示读操作,R/W=0为写操作,A2,A1,A0为EEPROM的页选或片选地址;   
(0016) enumer为枚举变量,需为AT2401至AT24256中的一种,分别对应AT24C01至AT24C256;   
(0017) 函数返回值为一个位变量，若返回1表示此次操作失效，0表示操作成功;   
(0018) ERROR为允许最大次数，若出现ERRORCOUNT次操作失效后，则函数中止操作，并返回1   
(0019) SDA和SCL由用户自定义，这里暂定义为P3^0和P3^1; */   
(0020) /*对于1K位，2K位，4K位，8K位，16K位芯片采用一个8位长的字节地址码，对于32K位以上   
(0021) 的采用2个8位长的字节地址码直接寻址，而4K位，8K位，16K位配合页面地址来寻址*/   
(0022)    
(0023) /* －－－－－  AT24C01～AT24C256 的读写程序 －－－－－－ */
(0024) 
(0025) #define AT24C256DEVADDR 0xa0
(0026) 
(0027) #define MAXRETRY    10
(0028) 
(0029) #define SET_SCL (PORTC|=0x80)
(0030) #define CLR_SCL (PORTC&=0x7f)
(0031) #define SET_SDA (PORTC|=0x40)
(0032) #define CLR_SDA (PORTC&=0xbf)
(0033) #define TEST_SDA ((PINC&0x40)?1:0)
(0034) #define SDA_OUT (DDRC|=0x40)
(0035) #define SDA_IN (DDRC&=0xbf,PORTC|=0x40)
(0036) 
(0037) static void start(void);
(0038) static void stop(void);
(0039) static unsigned char recAck(void);
(0040) static void ack(void);
(0041) static void noAck(void);
(0042) static void sendByte(unsigned char byte);
(0043) static unsigned char receiveByte(void);
(0044) 
(0045) //pc7 scl
(0046) //pc6 sda
(0047) void at24c256_init(void)
(0048) {
(0049)     //pc6 and pc7 output mode.
(0050)     DDRC |= 0xc0;
_at24c256_init:
    04A8 B384      IN	R24,0x14
    04A9 6C80      ORI	R24,0xC0
    04AA BB84      OUT	0x14,R24
(0051)     PORTC |= 0xc0;
    04AB B385      IN	R24,0x15
    04AC 6C80      ORI	R24,0xC0
    04AD BB85      OUT	0x15,R24
(0052)     return;
    04AE 9508      RET
_rw24c256:
  i                    --> R10
  err                  --> R20
  rwFlag               --> R22
  addr                 --> R12
  len                  --> R14
  data                 --> Y+10
    04AF D181      RCALL	push_arg4
    04B0 D1B5      RCALL	push_gset5
    04B1 2EE2      MOV	R14,R18
    04B2 84CE      LDD	R12,Y+14
    04B3 84DF      LDD	R13,Y+15
    04B4 8968      LDD	R22,Y+16
(0053) }
(0054) 
(0055) char rw24c256(unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)    
(0056) {
(0057)     unsigned char i = MAXRETRY;
    04B5 E08A      LDI	R24,0xA
    04B6 2EA8      MOV	R10,R24
(0058)     char err = 1;  /*   出错标志   */   
    04B7 E041      LDI	R20,1
    04B8 C047      RJMP	0x0500
(0059)     while(i--)    
(0060)     {    
(0061)         start();  /*   启动总线   */
    04B9 D0E4      RCALL	_start
(0062)         sendByte(AT24C256DEVADDR |0x00); /*   向IIC总线写数据，器件地址 */   
    04BA EA00      LDI	R16,0xA0
    04BB D126      RCALL	_sendByte
(0063)         if(recAck()) continue; /*   如写不正确结束本次循环   */   
    04BC D0F6      RCALL	_recAck
    04BD 2300      TST	R16
    04BE F009      BEQ	0x04C0
    04BF C040      RJMP	0x0500
(0064)         sendByte((unsigned char)(addr >> 8));//把整型数据转换为字符型数据：弃高取低，只取低8位.如果容量大于32K位，使用16位地址寻址，写入高八位地址    
    04C0 0186      MOVW	R16,R12
    04C1 2F01      MOV	R16,R17
    04C2 2711      CLR	R17
    04C3 D11E      RCALL	_sendByte
(0065)         if(recAck())  continue;    
    04C4 D0EE      RCALL	_recAck
    04C5 2300      TST	R16
    04C6 F009      BEQ	0x04C8
    04C7 C038      RJMP	0x0500
(0066)         sendByte((unsigned char)addr); /*   向IIC总线写数据   */   
    04C8 2D0C      MOV	R16,R12
    04C9 D118      RCALL	_sendByte
(0067)         if(recAck())  continue; /*   如写正确结束本次循环   */
    04CA D0E8      RCALL	_recAck
    04CB 2300      TST	R16
    04CC F009      BEQ	0x04CE
    04CD C032      RJMP	0x0500
(0068)         if(rwFlag == RW24C256WRITE)   //判断是读器件还是写器件    
    04CE 2366      TST	R22
    04CF F4A1      BNE	0x04E4
(0069)         {
(0070)             err=0;         /* 清错误特征位 */   
    04D0 2744      CLR	R20
    04D1 C00C      RJMP	0x04DE
(0071)             while(len--)    
(0072)             {
(0073)                 sendByte(*(data++)); /*   向IIC总线写数据   */   
    04D2 85EA      LDD	R30,Y+10
    04D3 85FB      LDD	R31,Y+11
    04D4 9101      LD	R16,Z+
    04D5 87FB      STD	Y+11,R31
    04D6 87EA      STD	Y+10,R30
    04D7 D10A      RCALL	_sendByte
(0074)                 if(!recAck()) continue; /*   如写正确结束本次循环   */   
    04D8 D0DA      RCALL	_recAck
    04D9 2300      TST	R16
    04DA F409      BNE	0x04DC
    04DB C002      RJMP	0x04DE
(0075)                 err=1;    
    04DC E041      LDI	R20,1
(0076)                 break;    
    04DD C003      RJMP	0x04E1
    04DE 940E0857  CALL	0x857
    04E0 F789      BNE	0x04D2
(0077)             }    
(0078)             if(err==1) continue;    
    04E1 3041      CPI	R20,1
    04E2 F529      BNE	0x0508
    04E3 C01C      RJMP	0x0500
(0079)             break;    
(0080)         }    
(0081)         else   
(0082)         { 
(0083)             start();  /*   启动总线   */   
    04E4 D0B9      RCALL	_start
(0084)             sendByte(AT24C256DEVADDR |0x01); /*   向IIC总线写数据   */   
    04E5 EA01      LDI	R16,0xA1
    04E6 D0FB      RCALL	_sendByte
(0085)             if(recAck()) continue;//器件没应答结束本次本层循环    
    04E7 D0CB      RCALL	_recAck
    04E8 2300      TST	R16
    04E9 F009      BEQ	0x04EB
    04EA C015      RJMP	0x0500
(0086)             //循环数量要减一。
(0087)             len--;
    04EB 94EA      DEC	R14
    04EC C008      RJMP	0x04F5
(0088)             while(len--)  /*   字节长为0结束   */   
(0089)             {
(0090)                 *(data++)= receiveByte();    
    04ED D110      RCALL	_receiveByte
    04EE 2E20      MOV	R2,R16
    04EF 85EA      LDD	R30,Y+10
    04F0 85FB      LDD	R31,Y+11
    04F1 9221      ST	R2,Z+
    04F2 87FB      STD	Y+11,R31
    04F3 87EA      STD	Y+10,R30
(0091)                 ack();   /*   对IIC总线产生应答   */   
    04F4 D0DF      RCALL	_ack
    04F5 940E0857  CALL	0x857
    04F7 F7A9      BNE	0x04ED
(0092)             }    
(0093)             *data=receiveByte(); /* 读最后一个字节 */   
    04F8 D105      RCALL	_receiveByte
    04F9 2E20      MOV	R2,R16
    04FA 85EA      LDD	R30,Y+10
    04FB 85FB      LDD	R31,Y+11
    04FC 8220      STD	Z+0,R2
(0094)             noAck();  /*   不对IIC总线产生应答   */   
    04FD D0DF      RCALL	_noAck
(0095)             err=0;    
    04FE 2744      CLR	R20
(0096)             break;    
    04FF C008      RJMP	0x0508
    0500 2C2A      MOV	R2,R10
    0501 2433      CLR	R3
    0502 2D82      MOV	R24,R2
    0503 5081      SUBI	R24,1
    0504 2EA8      MOV	R10,R24
    0505 2022      TST	R2
    0506 F009      BEQ	0x0508
    0507 CFB1      RJMP	0x04B9
(0097)         }    
(0098)     }    
(0099)     stop();  /*   停止IIC总线   */   
    0508 D09F      RCALL	_stop
(0100)     if(rwFlag == RW24C256WRITE)    
    0509 2366      TST	R22
    050A F419      BNE	0x050E
(0101)     {     
(0102)         delay_ms(50);    
    050B E302      LDI	R16,0x32
    050C E010      LDI	R17,0
    050D DC8D      RCALL	_delay_ms
(0103)     }    
(0104)     return err;    
    050E 2F04      MOV	R16,R20
    050F D154      RCALL	pop_gset5
    0510 9624      ADIW	R28,4
    0511 9508      RET
_rw24c256Int:
  tmp                  --> Y+7
  out                  --> Y+3
  rwFlag               --> Y+21
  addr                 --> Y+19
  data                 --> Y+15
    0512 D11E      RCALL	push_arg4
    0513 D158      RCALL	push_gset2
    0514 972B      SBIW	R28,0xB
(0105) }    
(0106) 
(0107) unsigned long rw24c256Int(unsigned long data, unsigned int addr, unsigned char rwFlag)
(0108) {
(0109)     unsigned char tmp[4] = {0, 0, 0, 0};
    0515 E58C      LDI	R24,0x5C
    0516 E090      LDI	R25,0
    0517 01FE      MOVW	R30,R28
    0518 9637      ADIW	R30,7
    0519 E004      LDI	R16,4
    051A E010      LDI	R17,0
    051B 93FA      ST	R31,-Y
    051C 93EA      ST	R30,-Y
    051D 939A      ST	R25,-Y
    051E 938A      ST	R24,-Y
    051F D1D5      RCALL	asgncblk
(0110) 	unsigned long out = 0;
    0520 E040      LDI	R20,0
    0521 940E0753  CALL	0x753
    0523 940E088F  CALL	0x88F
(0111) 
(0112)     if(rwFlag==RW24C256WRITE)
    0525 880D      LDD	R0,Y+21
    0526 2000      TST	R0
    0527 F009      BEQ	0x0529
    0528 C03E      RJMP	0x0567
(0113)     {
(0114)         tmp[0] = (unsigned char)(data&0x000000ff);
    0529 EF4F      LDI	R20,0xFF
    052A 940E0753  CALL	0x753
    052C 940E07E8  CALL	0x7E8
    052E 940E07CA  CALL	0x7CA
    0530 822F      STD	Y+7,R2
(0115)         tmp[1] = (unsigned char)((data>>8)&0x000000ff);
    0531 E088      LDI	R24,0x8
    0532 E090      LDI	R25,0
    0533 940E07B6  CALL	0x7B6
    0535 938A      ST	R24,-Y
    0536 0181      MOVW	R16,R2
    0537 0192      MOVW	R18,R4
    0538 D1B0      RCALL	lsr32
    0539 0118      MOVW	R2,R16
    053A 0129      MOVW	R4,R18
    053B 940E080F  CALL	0x80F
    053D 940E07CA  CALL	0x7CA
    053F 8628      STD	Y+8,R2
(0116)         tmp[2] = (unsigned char)((data>>16)&0x000000ff);
    0540 EF4F      LDI	R20,0xFF
    0541 940E0753  CALL	0x753
    0543 940E07E8  CALL	0x7E8
    0545 0112      MOVW	R2,R4
    0546 2444      CLR	R4
    0547 2455      CLR	R5
    0548 940E07CA  CALL	0x7CA
    054A 8629      STD	Y+9,R2
(0117)         tmp[3] = (unsigned char)((data>>24)&0x000000ff);
    054B E188      LDI	R24,0x18
    054C E090      LDI	R25,0
    054D 940E07B6  CALL	0x7B6
    054F 938A      ST	R24,-Y
    0550 0181      MOVW	R16,R2
    0551 0192      MOVW	R18,R4
    0552 D196      RCALL	lsr32
    0553 0118      MOVW	R2,R16
    0554 0129      MOVW	R4,R18
    0555 940E080F  CALL	0x80F
    0557 940E07CA  CALL	0x7CA
    0559 862A      STD	Y+10,R2
(0118)         rw24c256((unsigned char*)&tmp, 4, addr, RW24C256WRITE);
    055A 2422      CLR	R2
    055B 822A      STD	Y+2,R2
    055C 940E0827  CALL	0x827
    055E DF50      RCALL	_rw24c256
    055F 940E07B6  CALL	0x7B6
(0119) 		out = data;
    0561 01FE      MOVW	R30,R28
    0562 8223      STD	Z+3,R2
    0563 8234      STD	Z+4,R3
    0564 8245      STD	Z+5,R4
    0565 8256      STD	Z+6,R5
(0120)     }
    0566 C02E      RJMP	0x0595
(0121)     else
(0122)     {
(0123)         rw24c256((unsigned char*)&tmp, 4, addr, RW24C256READ);
    0567 E081      LDI	R24,1
    0568 838A      STD	Y+2,R24
    0569 940E0827  CALL	0x827
    056B DF43      RCALL	_rw24c256
(0124) 
(0125)         out= 0;
    056C E040      LDI	R20,0
    056D 940E0753  CALL	0x753
    056F 940E088F  CALL	0x88F
(0126)         out |= tmp[0];
    0571 802F      LDD	R2,Y+7
    0572 940E0726  CALL	<created procedures>
(0127)         out <<= 8;
    0574 D168      RCALL	lsl32
    0575 940E0836  CALL	0x836
(0128)         out |= tmp[1];
    0577 8428      LDD	R2,Y+8
    0578 940E0726  CALL	<created procedures>
(0129)         out <<= 8;
    057A D162      RCALL	lsl32
    057B 940E0836  CALL	0x836
(0130)         out |= tmp[2];
    057D 8429      LDD	R2,Y+9
    057E 940E0726  CALL	<created procedures>
(0131)         out <<= 8;
    0580 D15C      RCALL	lsl32
    0581 940E0836  CALL	0x836
(0132)         out |= tmp[3];
    0583 842A      LDD	R2,Y+10
    0584 2433      CLR	R3
    0585 2444      CLR	R4
    0586 2455      CLR	R5
    0587 01FE      MOVW	R30,R28
    0588 8063      LDD	R6,Z+3
    0589 8074      LDD	R7,Z+4
    058A 8085      LDD	R8,Z+5
    058B 8096      LDD	R9,Z+6
    058C 2862      OR	R6,R2
    058D 2873      OR	R7,R3
    058E 2884      OR	R8,R4
    058F 2895      OR	R9,R5
    0590 01FE      MOVW	R30,R28
    0591 8263      STD	Z+3,R6
    0592 8274      STD	Z+4,R7
    0593 8285      STD	Z+5,R8
    0594 8296      STD	Z+6,R9
(0133)     }
(0134)     return out;
    0595 01FE      MOVW	R30,R28
    0596 8103      LDD	R16,Z+3
    0597 8114      LDD	R17,Z+4
    0598 8125      LDD	R18,Z+5
    0599 8136      LDD	R19,Z+6
    059A 962B      ADIW	R28,0xB
    059B D0C4      RCALL	pop_gset2
    059C 9624      ADIW	R28,4
    059D 9508      RET
(0135) }
(0136) 
(0137) /* * * * * 以下是对IIC总线的操作子程序 * * * * */   
(0138) /* * * * * * 启动总线 * * * * */   
(0139) static void start(void)    
(0140) {    
(0141)     //SCL=0; /* SCL处于高电平时,SDA从高电平转向低电平表示 */   
(0142)     //CLR_SCL;
(0143)     //SDA=1; /* 一个"开始"状态,该状态必须在其他命令之前执行 */   
(0144)     SET_SDA;
_start:
    059E 9AAE      SBI	0x15,6
(0145)     NOP();
    059F 0000      NOP
    05A0 940E07F8  CALL	0x7F8
(0146)     //SCL=1;
(0147)     SET_SCL;
(0148)     NOP(); NOP(); NOP();    
(0149)     //SDA=0;
(0150)     CLR_SDA;
    05A2 B385      IN	R24,0x15
    05A3 7B8F      ANDI	R24,0xBF
    05A4 BB85      OUT	0x15,R24
    05A5 940E07E0  CALL	0x7E0
(0151)     NOP(); NOP(); NOP(); NOP();    
(0152)     //SCL=0;
(0153)     CLR_SCL;
(0154)     //SDA=1;
(0155)     //SET_SDA;
(0156) 
(0157)     return;
    05A7 9508      RET
(0158) }    
(0159)    
(0160) /* * * * * 停止IIC总线 * * * * */   
(0161) static void stop(void)    
(0162) {     
(0163)     //SCL=0; /*SCL处于高电平时,SDA从低电平转向高电平 */
(0164)     //CLR_SCL;   
(0165)     //SDA=0; /*表示一个"停止"状态,该状态终止所有通讯 */
(0166)     CLR_SDA;
_stop:
    05A8 B385      IN	R24,0x15
    05A9 7B8F      ANDI	R24,0xBF
    05AA BB85      OUT	0x15,R24
(0167)     NOP();
    05AB 0000      NOP
    05AC 940E07F8  CALL	0x7F8
(0168)     //SCL=1;
(0169)     SET_SCL;
(0170)     NOP(); NOP(); NOP(); /* 空操作 */
(0171)     //SDA=1;
(0172)     SET_SDA;
    05AE 9AAE      SBI	0x15,6
(0173)     NOP(); NOP(); NOP();
    05AF 0000      NOP
    05B0 0000      NOP
    05B1 0000      NOP
(0174)     //SCL=0;
(0175)     //CLR_SCL;
(0176)     
(0177)     return;
    05B2 9508      RET
(0178) }    
(0179)    
(0180) /* * * * * 检查应答位 * * * * */   
(0181) static unsigned char recAck(void)    
(0182) {
(0183)     unsigned char result;
(0184)      unsigned char i=0;
_recAck:
  result               --> R16
  i                    --> R16
    05B3 2700      CLR	R16
    05B4 940E0874  CALL	0x874
    05B6 940E07F8  CALL	0x7F8
(0185)     
(0186)     //SCL=0;
(0187)     //CLR_SCL;   
(0188)     //SDA=1;
(0189)     SET_SDA;
(0190)     SDA_IN;
(0191)     //SCL=1;
(0192)     SET_SCL;
(0193)     //change sda input mode.
(0194)     NOP(); NOP(); NOP(); NOP();
    05B8 0000      NOP
    05B9 C001      RJMP	0x05BB
(0195)     //CY=SDA;     /* 因为返回值总是放在CY中的 */
(0196)     while(TEST_SDA&&(i>250)) i++;
    05BA 9503      INC	R16
    05BB 9B9E      SBIS	0x13,6
    05BC C003      RJMP	0x05C0
    05BD E021      LDI	R18,1
    05BE E030      LDI	R19,0
    05BF C002      RJMP	0x05C2
    05C0 2722      CLR	R18
    05C1 2733      CLR	R19
    05C2 3020      CPI	R18,0
    05C3 0723      CPC	R18,R19
    05C4 F019      BEQ	0x05C8
    05C5 EF8A      LDI	R24,0xFA
    05C6 1780      CP	R24,R16
    05C7 F390      BCS	0x05BA
(0197)     result = TEST_SDA;
    05C8 9B9E      SBIS	0x13,6
    05C9 C003      RJMP	0x05CD
    05CA E001      LDI	R16,1
    05CB E010      LDI	R17,0
    05CC C002      RJMP	0x05CF
    05CD 2700      CLR	R16
    05CE 2711      CLR	R17
(0198)     //SCL=0;
(0199)     CLR_SCL;
    05CF B385      IN	R24,0x15
    05D0 778F      ANDI	R24,0x7F
    05D1 BB85      OUT	0x15,R24
(0200)     //SDA_OUT;
(0201)     SDA_OUT;
    05D2 9AA6      SBI	0x14,6
(0202)     return result;
    05D3 9508      RET
(0203) }    
(0204)    
(0205) /* * * * *对IIC总线产生应答 * * * * */   
(0206) static void ack(void)    
(0207) {     
(0208)     //SDA=0; /* EEPROM通过在收到每个地址或数据之后, */
(0209)     CLR_SDA;
_ack:
    05D4 B385      IN	R24,0x15
    05D5 7B8F      ANDI	R24,0xBF
    05D6 BB85      OUT	0x15,R24
(0210)     //SCL=1; /* 置SDA低电平的方式确认表示收到读SDA口状态 */
(0211)     SET_SCL;
    05D7 9AAF      SBI	0x15,7
    05D8 940E07E0  CALL	0x7E0
(0212)     NOP(); NOP(); NOP(); NOP();
(0213)     //SCL=0;
(0214)     CLR_SCL;   
(0215)     NOP();
    05DA 0000      NOP
(0216)     //SDA=1;
(0217)     SET_SDA;
    05DB 9AAE      SBI	0x15,6
(0218) 
(0219)     return;
    05DC 9508      RET
(0220) }    
(0221)    
(0222) /* * * * * * * * * 不对IIC总线产生应答 * * * * */   
(0223) static void noAck(void)    
(0224) {    
(0225)     //SDA=1;
(0226)     SET_SDA;
_noAck:
    05DD 9AAE      SBI	0x15,6
(0227)     //SCL=1;
(0228)     SET_SCL;
    05DE 9AAF      SBI	0x15,7
    05DF 940E07E0  CALL	0x7E0
(0229)     NOP(); NOP(); NOP(); NOP();    
(0230)     //SCL=0;
(0231)     CLR_SCL;
(0232)     
(0233)     return;
    05E1 9508      RET
_sendByte:
  mask                 --> R20
  byte                 --> R16
    05E2 D08B      RCALL	push_gset1
(0234) }    
(0235)    
(0236) /* * * * * * * * * 向IIC总线写数据 * * * * */   
(0237) static void sendByte(unsigned char byte)    
(0238) {
(0239)     unsigned char mask = 0x80;
    05E3 E840      LDI	R20,0x80
(0240)     for(;mask>0;)    
    05E4 C011      RJMP	0x05F6
(0241)     {
(0242)         //SCL=0;
(0243)         CLR_SCL;
    05E5 940E0852  CALL	0x852
(0244)         NOP();NOP();
    05E7 0000      NOP
(0245)         if(mask&byte)
    05E8 2E24      MOV	R2,R20
    05E9 2220      AND	R2,R16
    05EA F011      BEQ	0x05ED
(0246)         {
(0247)             //SDA=1;
(0248)             SET_SDA;
    05EB 9AAE      SBI	0x15,6
(0249)         }
    05EC C003      RJMP	0x05F0
(0250)         else
(0251)         {
(0252)             //SDA=0;
(0253)             CLR_SDA;
    05ED B385      IN	R24,0x15
    05EE 7B8F      ANDI	R24,0xBF
    05EF BB85      OUT	0x15,R24
(0254)         }
(0255)         mask >>= 1;
    05F0 9546      LSR	R20
(0256)         NOP();NOP();
    05F1 0000      NOP
    05F2 0000      NOP
(0257)         //SCL=1;
(0258)         SET_SCL;
    05F3 9AAF      SBI	0x15,7
(0259)         NOP();NOP();
    05F4 0000      NOP
    05F5 0000      NOP
    05F6 2422      CLR	R2
    05F7 1624      CP	R2,R20
    05F8 F360      BCS	0x05E5
(0260)     }
(0261)     //SCL=0;
(0262)     CLR_SCL;
    05F9 B385      IN	R24,0x15
    05FA 778F      ANDI	R24,0x7F
    05FB BB85      OUT	0x15,R24
(0263) 
(0264)     return;
    05FC D074      RCALL	pop_gset1
    05FD 9508      RET
_receiveByte:
  i                    --> R16
  receivebyte          --> R18
    05FE D06F      RCALL	push_gset1
(0265) }
(0266)    
(0267) /* * * * * * * * * 从IIC总线上读数据子程序 * * * * */   
(0268) static unsigned char receiveByte(void)    
(0269) {     
(0270)     unsigned char receivebyte = 0, i=8;     
    05FF 2722      CLR	R18
    0600 E008      LDI	R16,0x8
(0271)     //SCL=0;
(0272)     CLR_SCL;
    0601 B385      IN	R24,0x15
    0602 778F      ANDI	R24,0x7F
    0603 BB85      OUT	0x15,R24
    0604 940E0874  CALL	0x874
(0273)     //SDA = 1;
(0274)     SET_SDA;
(0275)     SDA_IN;
(0276)     NOP();NOP();
    0606 0000      NOP
    0607 0000      NOP
    0608 C013      RJMP	0x061C
(0277)     while(i--)    
(0278)     {     
(0279)         //SCL=1;
(0280)         SET_SCL;
    0609 9AAF      SBI	0x15,7
(0281)         NOP();NOP();
    060A 0000      NOP
    060B 0000      NOP
(0282)         receivebyte = (receivebyte <<1 ) | TEST_SDA;
    060C 9B9E      SBIS	0x13,6
    060D C003      RJMP	0x0611
    060E E041      LDI	R20,1
    060F E050      LDI	R21,0
    0610 C002      RJMP	0x0613
    0611 2744      CLR	R20
    0612 2755      CLR	R21
    0613 2E22      MOV	R2,R18
    0614 2433      CLR	R3
    0615 0C22      LSL	R2
    0616 1C33      ROL	R3
    0617 2A24      OR	R2,R20
    0618 2A35      OR	R3,R21
    0619 2D22      MOV	R18,R2
    061A 940E0852  CALL	0x852
    061C 2E20      MOV	R2,R16
    061D 2433      CLR	R3
    061E 5001      SUBI	R16,1
    061F 2022      TST	R2
    0620 F741      BNE	0x0609
(0283)         //SCL=0;
(0284)         CLR_SCL;
(0285)         NOP();
(0286)     }
(0287)     SDA_OUT;
    0621 9AA6      SBI	0x14,6
(0288)     return receivebyte;    
    0622 2F02      MOV	R16,R18
    0623 D04D      RCALL	pop_gset1
    0624 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\uart.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "uart.h"
(0005) 
(0006) //uart0 init. for printf.
(0007) void uart0_init(void)
(0008) {
(0009)     UCSRB = 0x00;                //禁止UART发送和接收
_uart0_init:
    0625 2422      CLR	R2
    0626 B82A      OUT	0x0A,R2
(0010)     UCSRA = 0x02;               //倍速
    0627 E082      LDI	R24,2
    0628 B98B      OUT	0x0B,R24
(0011)     UCSRC = 0x06;                //8位数据
    0629 E086      LDI	R24,6
    062A BD80      OUT	0x20,R24
(0012)     UBRRL = 0x67;                 //9600bps
    062B E687      LDI	R24,0x67
    062C B989      OUT	0x09,R24
(0013)     UBRRH = 0x00;
    062D BC20      OUT	0x20,R2
(0014)     UCSRB = 0x18;
FILE: <library>
    062E E188      LDI	R24,0x18
    062F B98A      OUT	0x0A,R24
    0630 9508      RET
push_arg4:
    0631 940E089E  CALL	0x89E
push_arg2:
    0633 9508      RET
empy32u:
empy32s:
    0634 D059      RCALL	long_prolog
    0635 927F      PUSH	R7
    0636 D070      RCALL	tstzero1
    0637 F131      BEQ	0x065E
    0638 2477      CLR	R7
    0639 D073      RCALL	tstzero2
    063A F419      BNE	0x063E
    063B 018C      MOVW	R16,R24
    063C 019D      MOVW	R18,R26
    063D C020      RJMP	0x065E
    063E 9F08      MUL	R16,R24
    063F 2CB0      MOV	R11,R0
    0640 2CA1      MOV	R10,R1
    0641 9F28      MUL	R18,R24
    0642 2C90      MOV	R9,R0
    0643 2C81      MOV	R8,R1
    0644 9F18      MUL	R17,R24
    0645 0CA0      ADD	R10,R0
    0646 1C91      ADC	R9,R1
    0647 1C87      ADC	R8,R7
    0648 9F09      MUL	R16,R25
    0649 0CA0      ADD	R10,R0
    064A 1C91      ADC	R9,R1
    064B 1C87      ADC	R8,R7
    064C 9F19      MUL	R17,R25
    064D 0C90      ADD	R9,R0
    064E 1C81      ADC	R8,R1
    064F 9F0A      MUL	R16,R26
    0650 0C90      ADD	R9,R0
    0651 1C81      ADC	R8,R1
    0652 9F38      MUL	R19,R24
    0653 0C80      ADD	R8,R0
    0654 9F29      MUL	R18,R25
    0655 0C80      ADD	R8,R0
    0656 9F1A      MUL	R17,R26
    0657 0C80      ADD	R8,R0
    0658 9F0B      MUL	R16,R27
    0659 0C80      ADD	R8,R0
    065A 2D0B      MOV	R16,R11
    065B 2D1A      MOV	R17,R10
    065C 2D29      MOV	R18,R9
    065D 2D38      MOV	R19,R8
    065E 907F      POP	R7
    065F C03C      RJMP	long_epilog
pop_gset2:
    0660 E0E2      LDI	R30,2
    0661 C010      RJMP	pop
pop_gset3:
    0662 E0E4      LDI	R30,4
    0663 C00E      RJMP	pop
pop_gset5:
    0664 27EE      CLR	R30
    0665 C00C      RJMP	pop
push_gset5:
    0666 92FA      ST	R15,-Y
    0667 92EA      ST	R14,-Y
push_gset4:
    0668 92DA      ST	R13,-Y
    0669 92CA      ST	R12,-Y
push_gset3:
    066A 92BA      ST	R11,-Y
    066B 92AA      ST	R10,-Y
push_gset2:
    066C 937A      ST	R23,-Y
    066D 936A      ST	R22,-Y
push_gset1:
    066E 935A      ST	R21,-Y
    066F 934A      ST	R20,-Y
    0670 9508      RET
pop_gset1:
    0671 E0E1      LDI	R30,1
pop:
    0672 9149      LD	R20,Y+
    0673 9159      LD	R21,Y+
    0674 FDE0      SBRC	R30,0
    0675 9508      RET
    0676 9169      LD	R22,Y+
    0677 9179      LD	R23,Y+
    0678 FDE1      SBRC	R30,1
    0679 9508      RET
    067A 90A9      LD	R10,Y+
    067B 90B9      LD	R11,Y+
    067C FDE2      SBRC	R30,2
    067D 9508      RET
    067E 90C9      LD	R12,Y+
    067F 90D9      LD	R13,Y+
    0680 FDE3      SBRC	R30,3
    0681 9508      RET
    0682 90E9      LD	R14,Y+
    0683 90F9      LD	R15,Y+
    0684 9508      RET
xicall:
    0685 920A      ST	R0,-Y
    0686 95C8      LPM
    0687 920A      ST	R0,-Y
    0688 9631      ADIW	R30,1
    0689 95C8      LPM
    068A 2DF0      MOV	R31,R0
    068B 91E9      LD	R30,Y+
    068C 9009      LD	R0,Y+
    068D 9409      IJMP
long_prolog:
    068E 928A      ST	R8,-Y
    068F 929A      ST	R9,-Y
    0690 92AA      ST	R10,-Y
    0691 92BA      ST	R11,-Y
    0692 93EA      ST	R30,-Y
    0693 938A      ST	R24,-Y
    0694 939A      ST	R25,-Y
    0695 93AA      ST	R26,-Y
    0696 93BA      ST	R27,-Y
    0697 8589      LDD	R24,Y+9
    0698 859A      LDD	R25,Y+10
    0699 85AB      LDD	R26,Y+11
    069A 85BC      LDD	R27,Y+12
    069B 9508      RET
long_epilog:
    069C 91B9      LD	R27,Y+
    069D 91A9      LD	R26,Y+
    069E 9199      LD	R25,Y+
    069F 9189      LD	R24,Y+
    06A0 91E9      LD	R30,Y+
    06A1 90B9      LD	R11,Y+
    06A2 90A9      LD	R10,Y+
    06A3 9099      LD	R9,Y+
    06A4 9089      LD	R8,Y+
    06A5 9624      ADIW	R28,4
    06A6 9508      RET
tstzero1:
    06A7 27EE      CLR	R30
    06A8 2BE0      OR	R30,R16
    06A9 2BE1      OR	R30,R17
    06AA 2BE2      OR	R30,R18
    06AB 2BE3      OR	R30,R19
    06AC 9508      RET
tstzero2:
    06AD 27EE      CLR	R30
    06AE 2BE8      OR	R30,R24
    06AF 2BE9      OR	R30,R25
    06B0 2BEA      OR	R30,R26
    06B1 2BEB      OR	R30,R27
    06B2 9508      RET
push_lset:
    06B3 93FA      ST	R31,-Y
    06B4 93EA      ST	R30,-Y
    06B5 93BA      ST	R27,-Y
    06B6 93AA      ST	R26,-Y
    06B7 939A      ST	R25,-Y
    06B8 938A      ST	R24,-Y
    06B9 940E089E  CALL	0x89E
    06BB 929A      ST	R9,-Y
    06BC 928A      ST	R8,-Y
    06BD 927A      ST	R7,-Y
    06BE 926A      ST	R6,-Y
    06BF 940E0885  CALL	0x885
    06C1 921A      ST	R1,-Y
    06C2 920A      ST	R0,-Y
    06C3 B60F      IN	R0,0x3F
    06C4 920A      ST	R0,-Y
    06C5 9508      RET
pop_lset:
    06C6 9009      LD	R0,Y+
    06C7 BE0F      OUT	0x3F,R0
    06C8 9009      LD	R0,Y+
    06C9 9019      LD	R1,Y+
    06CA 9029      LD	R2,Y+
    06CB 9039      LD	R3,Y+
    06CC 9049      LD	R4,Y+
    06CD 9059      LD	R5,Y+
    06CE 9069      LD	R6,Y+
    06CF 9079      LD	R7,Y+
    06D0 9089      LD	R8,Y+
    06D1 9099      LD	R9,Y+
    06D2 9109      LD	R16,Y+
    06D3 9119      LD	R17,Y+
    06D4 9129      LD	R18,Y+
    06D5 9139      LD	R19,Y+
    06D6 9189      LD	R24,Y+
    06D7 9199      LD	R25,Y+
    06D8 91A9      LD	R26,Y+
    06D9 91B9      LD	R27,Y+
    06DA 91E9      LD	R30,Y+
    06DB 91F9      LD	R31,Y+
    06DC 9508      RET
lsl32:
    06DD 920F      PUSH	R0
    06DE 9009      LD	R0,Y+
    06DF 2000      TST	R0
    06E0 F031      BEQ	0x06E7
    06E1 0F00      LSL	R16
    06E2 1F11      ROL	R17
    06E3 1F22      ROL	R18
    06E4 1F33      ROL	R19
    06E5 940A      DEC	R0
    06E6 CFF8      RJMP	0x06DF
    06E7 900F      POP	R0
    06E8 9508      RET
lsr32:
    06E9 920F      PUSH	R0
    06EA 9009      LD	R0,Y+
    06EB 2000      TST	R0
    06EC F031      BEQ	0x06F3
    06ED 9536      LSR	R19
    06EE 9527      ROR	R18
    06EF 9517      ROR	R17
    06F0 9507      ROR	R16
    06F1 940A      DEC	R0
    06F2 CFF8      RJMP	0x06EB
    06F3 900F      POP	R0
    06F4 9508      RET
asgncblk:
    06F5 93AA      ST	R26,-Y
    06F6 93BA      ST	R27,-Y
    06F7 93EA      ST	R30,-Y
    06F8 93FA      ST	R31,-Y
    06F9 920A      ST	R0,-Y
    06FA 81AF      LDD	R26,Y+7
    06FB 85B8      LDD	R27,Y+8
    06FC 81ED      LDD	R30,Y+5
    06FD 81FE      LDD	R31,Y+6
    06FE 3000      CPI	R16,0
    06FF 0701      CPC	R16,R17
    0700 F031      BEQ	0x0707
    0701 95C8      LPM
    0702 920D      ST	R0,X+
    0703 9631      ADIW	R30,1
    0704 5001      SUBI	R16,1
    0705 4010      SBCI	R17,0
    0706 CFF7      RJMP	0x06FE
    0707 9009      LD	R0,Y+
    0708 91F9      LD	R31,Y+
    0709 91E9      LD	R30,Y+
    070A 91B9      LD	R27,Y+
    070B 91A9      LD	R26,Y+
    070C 9624      ADIW	R28,4
    070D 9508      RET
asgnblk:
    070E 93AA      ST	R26,-Y
    070F 93BA      ST	R27,-Y
    0710 93EA      ST	R30,-Y
    0711 93FA      ST	R31,-Y
    0712 920A      ST	R0,-Y
    0713 81AF      LDD	R26,Y+7
    0714 85B8      LDD	R27,Y+8
    0715 81ED      LDD	R30,Y+5
    0716 81FE      LDD	R31,Y+6
    0717 3000      CPI	R16,0
    0718 0701      CPC	R16,R17
    0719 F029      BEQ	0x071F
    071A 9001      LD	R0,Z+
    071B 920D      ST	R0,X+
    071C 5001      SUBI	R16,1
    071D 4010      SBCI	R17,0
    071E CFF8      RJMP	0x0717
    071F 9009      LD	R0,Y+
    0720 91F9      LD	R31,Y+
    0721 91E9      LD	R30,Y+
    0722 91B9      LD	R27,Y+
    0723 91A9      LD	R26,Y+
    0724 9624      ADIW	R28,4
    0725 9508      RET
<created procedures>:
    0726 2433      CLR	R3
    0727 2444      CLR	R4
    0728 2455      CLR	R5
    0729 01FE      MOVW	R30,R28
    072A 8063      LDD	R6,Z+3
    072B 8074      LDD	R7,Z+4
    072C 8085      LDD	R8,Z+5
    072D 8096      LDD	R9,Z+6
    072E 2862      OR	R6,R2
    072F 2873      OR	R7,R3
    0730 2884      OR	R8,R4
    0731 2895      OR	R9,R5
    0732 01FE      MOVW	R30,R28
    0733 8263      STD	Z+3,R6
    0734 8274      STD	Z+4,R7
    0735 8285      STD	Z+5,R8
    0736 8296      STD	Z+6,R9
    0737 E088      LDI	R24,0x8
    0738 E090      LDI	R25,0
    0739 01FE      MOVW	R30,R28
    073A 8023      LDD	R2,Z+3
    073B 8034      LDD	R3,Z+4
    073C 8045      LDD	R4,Z+5
    073D 8056      LDD	R5,Z+6
    073E 938A      ST	R24,-Y
    073F 0181      MOVW	R16,R2
    0740 0192      MOVW	R18,R4
    0741 9508      RET
    0742 8628      STD	Y+8,R2
    0743 8639      STD	Y+9,R3
    0744 864A      STD	Y+10,R4
    0745 865B      STD	Y+11,R5
    0746 9040006C  LDS	R4,passwordH+2
    0748 9050006D  LDS	R5,passwordH+3
    074A 9020006A  LDS	R2,passwordH
    074C 9030006B  LDS	R3,passwordH+1
    074E 822C      STD	Y+4,R2
    074F 823D      STD	Y+5,R3
    0750 824E      STD	Y+6,R4
    0751 825F      STD	Y+7,R5
    0752 9508      RET
    0753 E050      LDI	R21,0
    0754 E060      LDI	R22,0
    0755 E070      LDI	R23,0
    0756 01FE      MOVW	R30,R28
    0757 9508      RET
    0758 E040      LDI	R20,0
    0759 E050      LDI	R21,0
    075A E060      LDI	R22,0
    075B E070      LDI	R23,0
    075C 8748      STD	Y+8,R20
    075D 8759      STD	Y+9,R21
    075E 876A      STD	Y+10,R22
    075F 877B      STD	Y+11,R23
    0760 E040      LDI	R20,0
    0761 E050      LDI	R21,0
    0762 E060      LDI	R22,0
    0763 E070      LDI	R23,0
    0764 834C      STD	Y+4,R20
    0765 835D      STD	Y+5,R21
    0766 836E      STD	Y+6,R22
    0767 837F      STD	Y+7,R23
    0768 01FE      MOVW	R30,R28
    0769 A820      LDD	R2,Z+48
    076A A831      LDD	R3,Z+49
    076B A842      LDD	R4,Z+50
    076C A853      LDD	R5,Z+51
    076D 8228      STD	Y+0,R2
    076E 8239      STD	Y+1,R3
    076F 824A      STD	Y+2,R4
    0770 825B      STD	Y+3,R5
    0771 9508      RET
    0772 9040006C  LDS	R4,passwordH+2
    0774 9050006D  LDS	R5,passwordH+3
    0776 9020006A  LDS	R2,passwordH
    0778 9030006B  LDS	R3,passwordH+1
    077A 9508      RET
    077B E040      LDI	R20,0
    077C E050      LDI	R21,0
    077D E060      LDI	R22,0
    077E E070      LDI	R23,0
    077F 9508      RET
    0780 92300061  STS	id_code+1,R3
    0782 92200060  STS	id_code,R2
    0784 92500063  STS	id_code+3,R5
    0786 92400062  STS	id_code+2,R4
    0788 9508      RET
    0789 90400070  LDS	R4,passwordL+2
    078B 90500071  LDS	R5,passwordL+3
    078D 9020006E  LDS	R2,passwordL
    078F 9030006F  LDS	R3,passwordL+1
    0791 9508      RET
    0792 E00D      LDI	R16,0xD
    0793 E010      LDI	R17,0
    0794 93FA      ST	R31,-Y
    0795 93EA      ST	R30,-Y
    0796 939A      ST	R25,-Y
    0797 938A      ST	R24,-Y
    0798 940E070E  CALL	asgnblk
    079A 019E      MOVW	R18,R28
    079B 9508      RET
    079C E041      LDI	R20,1
    079D E050      LDI	R21,0
    079E E060      LDI	R22,0
    079F E070      LDI	R23,0
    07A0 9508      RET
    07A1 01F0      MOVW	R30,R0
    07A2 E783      LDI	R24,0x73
    07A3 E090      LDI	R25,0
    07A4 0FE8      ADD	R30,R24
    07A5 1FF9      ADC	R31,R25
    07A6 9508      RET
    07A7 90400062  LDS	R4,id_code+2
    07A9 90500063  LDS	R5,id_code+3
    07AB 90200060  LDS	R2,id_code
    07AD 90300061  LDS	R3,id_code+1
    07AF 9508      RET
    07B0 B388      IN	R24,0x18
    07B1 7D8F      ANDI	R24,0xDF
    07B2 BB88      OUT	0x18,R24
    07B3 E604      LDI	R16,0x64
    07B4 E010      LDI	R17,0
    07B5 9508      RET
    07B6 01FE      MOVW	R30,R28
    07B7 8427      LDD	R2,Z+15
    07B8 8830      LDD	R3,Z+16
    07B9 8841      LDD	R4,Z+17
    07BA 8852      LDD	R5,Z+18
    07BB 9508      RET
    07BC 8741      STD	Z+9,R20
    07BD 8752      STD	Z+10,R21
    07BE 8763      STD	Z+11,R22
    07BF 8774      STD	Z+12,R23
    07C0 01CE      MOVW	R24,R28
    07C1 01FE      MOVW	R30,R28
    07C2 9508      RET
    07C3 E070      LDI	R23,0
    07C4 01FE      MOVW	R30,R28
    07C5 8341      STD	Z+1,R20
    07C6 8352      STD	Z+2,R21
    07C7 8363      STD	Z+3,R22
    07C8 8374      STD	Z+4,R23
    07C9 9508      RET
    07CA 2224      AND	R2,R20
    07CB 2235      AND	R3,R21
    07CC 2246      AND	R4,R22
    07CD 2257      AND	R5,R23
    07CE 9508      RET
    07CF A820      LDD	R2,Z+48
    07D0 A831      LDD	R3,Z+49
    07D1 A842      LDD	R4,Z+50
    07D2 A853      LDD	R5,Z+51
    07D3 9508      RET
    07D4 01FE      MOVW	R30,R28
    07D5 8C22      LDD	R2,Z+26
    07D6 8C33      LDD	R3,Z+27
    07D7 8C44      LDD	R4,Z+28
    07D8 8C55      LDD	R5,Z+29
    07D9 8228      STD	Y+0,R2
    07DA 8239      STD	Y+1,R3
    07DB 824A      STD	Y+2,R4
    07DC 825B      STD	Y+3,R5
    07DD 91200068  LDS	R18,current_index
    07DF 9508      RET
    07E0 0000      NOP
    07E1 0000      NOP
    07E2 0000      NOP
    07E3 0000      NOP
    07E4 B385      IN	R24,0x15
    07E5 778F      ANDI	R24,0x7F
    07E6 BB85      OUT	0x15,R24
    07E7 9508      RET
    07E8 8427      LDD	R2,Z+15
    07E9 8830      LDD	R3,Z+16
    07EA 8841      LDD	R4,Z+17
    07EB 8852      LDD	R5,Z+18
    07EC 9508      RET
    07ED 2422      CLR	R2
    07EE 822A      STD	Y+2,R2
    07EF E08D      LDI	R24,0xD
    07F0 9F86      MUL	R24,R22
    07F1 01C0      MOVW	R24,R0
    07F2 9508      RET
    07F3 1462      CP	R6,R2
    07F4 0473      CPC	R7,R3
    07F5 0484      CPC	R8,R4
    07F6 0495      CPC	R9,R5
    07F7 9508      RET
    07F8 9AAF      SBI	0x15,7
    07F9 0000      NOP
    07FA 0000      NOP
    07FB 0000      NOP
    07FC 9508      RET
    07FD 01FE      MOVW	R30,R28
    07FE 8345      STD	Z+5,R20
    07FF 8356      STD	Z+6,R21
    0800 8367      STD	Z+7,R22
    0801 8770      STD	Z+8,R23
    0802 9508      RET
    0803 E081      LDI	R24,1
    0804 838A      STD	Y+2,R24
    0805 E08D      LDI	R24,0xD
    0806 9F86      MUL	R24,R22
    0807 01C0      MOVW	R24,R0
    0808 9508      RET
    0809 01F0      MOVW	R30,R0
    080A E785      LDI	R24,0x75
    080B E090      LDI	R25,0
    080C 0FE8      ADD	R30,R24
    080D 1FF9      ADC	R31,R25
    080E 9508      RET
    080F EF4F      LDI	R20,0xFF
    0810 E050      LDI	R21,0
    0811 E060      LDI	R22,0
    0812 E070      LDI	R23,0
    0813 9508      RET
    0814 9350006F  STS	passwordL+1,R21
    0816 9340006E  STS	passwordL,R20
    0818 93700071  STS	passwordL+3,R23
    081A 93600070  STS	passwordL+2,R22
    081C 9508      RET
    081D 8341      STD	Z+1,R20
    081E 8352      STD	Z+2,R21
    081F 8363      STD	Z+3,R22
    0820 8374      STD	Z+4,R23
    0821 9508      RET
    0822 8345      STD	Z+5,R20
    0823 8356      STD	Z+6,R21
    0824 8367      STD	Z+7,R22
    0825 8770      STD	Z+8,R23
    0826 9508      RET
    0827 880B      LDD	R0,Y+19
    0828 881C      LDD	R1,Y+20
    0829 8219      STD	Y+1,R1
    082A 8208      STD	Y+0,R0
    082B E024      LDI	R18,4
    082C 018E      MOVW	R16,R28
    082D 5F09      SUBI	R16,0xF9
    082E 4F1F      SBCI	R17,0xFF
    082F 9508      RET
    0830 91800069  LDS	R24,input_err_count
    0832 5F8F      SUBI	R24,0xFF
    0833 93800069  STS	input_err_count,R24
    0835 9508      RET
    0836 01FE      MOVW	R30,R28
    0837 8303      STD	Z+3,R16
    0838 8314      STD	Z+4,R17
    0839 8325      STD	Z+5,R18
    083A 8336      STD	Z+6,R19
    083B 9508      RET
    083C B388      IN	R24,0x18
    083D 7D8F      ANDI	R24,0xDF
    083E BB88      OUT	0x18,R24
    083F E900      LDI	R16,0x90
    0840 E011      LDI	R17,1
    0841 9508      RET
    0842 2433      CLR	R3
    0843 8239      STD	Y+1,R3
    0844 8228      STD	Y+0,R2
    0845 E021      LDI	R18,1
    0846 018E      MOVW	R16,R28
    0847 5F0D      SUBI	R16,0xFD
    0848 4F1F      SBCI	R17,0xFF
    0849 9508      RET
    084A E586      LDI	R24,0x56
    084B E090      LDI	R25,0
    084C 8399      STD	Y+1,R25
    084D 8388      STD	Y+0,R24
    084E E22C      LDI	R18,0x2C
    084F E031      LDI	R19,1
    0850 E001      LDI	R16,1
    0851 9508      RET
    0852 B385      IN	R24,0x15
    0853 778F      ANDI	R24,0x7F
    0854 BB85      OUT	0x15,R24
    0855 0000      NOP
    0856 9508      RET
    0857 2C2E      MOV	R2,R14
    0858 2433      CLR	R3
    0859 2D82      MOV	R24,R2
    085A 5081      SUBI	R24,1
    085B 2EE8      MOV	R14,R24
    085C 2022      TST	R2
    085D 9508      RET
    085E 8399      STD	Y+1,R25
    085F 8388      STD	Y+0,R24
    0860 E024      LDI	R18,4
    0861 018E      MOVW	R16,R28
    0862 9508      RET
    0863 8399      STD	Y+1,R25
    0864 8388      STD	Y+0,R24
    0865 E024      LDI	R18,4
    0866 018A      MOVW	R16,R20
    0867 9508      RET
    0868 2422      CLR	R2
    0869 2433      CLR	R3
    086A 8231      STD	Z+1,R3
    086B 8220      STD	Z+0,R2
    086C E084      LDI	R24,4
    086D 9508      RET
    086E 91800066  LDS	R24,read_count
    0870 5F8F      SUBI	R24,0xFF
    0871 93800066  STS	read_count,R24
    0873 9508      RET
    0874 9AAE      SBI	0x15,6
    0875 B384      IN	R24,0x14
    0876 7B8F      ANDI	R24,0xBF
    0877 BB84      OUT	0x14,R24
    0878 9AAE      SBI	0x15,6
    0879 9508      RET
    087A E090      LDI	R25,0
    087B 93900065  STS	id_reader_flags+1,R25
    087D 93800064  STS	id_reader_flags,R24
    087F 9508      RET
    0880 9601      ADIW	R24,1
    0881 8399      STD	Y+1,R25
    0882 8388      STD	Y+0,R24
    0883 E021      LDI	R18,1
    0884 9508      RET
    0885 925A      ST	R5,-Y
    0886 924A      ST	R4,-Y
    0887 923A      ST	R3,-Y
    0888 922A      ST	R2,-Y
    0889 9508      RET
    088A 8348      STD	Y+0,R20
    088B 8359      STD	Y+1,R21
    088C 836A      STD	Y+2,R22
    088D 837B      STD	Y+3,R23
    088E 9508      RET
    088F 8343      STD	Z+3,R20
    0890 8354      STD	Z+4,R21
    0891 8365      STD	Z+5,R22
    0892 8376      STD	Z+6,R23
    0893 9508      RET
    0894 1624      CP	R2,R20
    0895 0635      CPC	R3,R21
    0896 0646      CPC	R4,R22
    0897 0657      CPC	R5,R23
    0898 9508      RET
    0899 2D2C      MOV	R18,R12
    089A 018E      MOVW	R16,R28
    089B 5F04      SUBI	R16,0xF4
    089C 4F1F      SBCI	R17,0xFF
    089D 9508      RET
    089E 933A      ST	R19,-Y
    089F 932A      ST	R18,-Y
    08A0 931A      ST	R17,-Y
    08A1 930A      ST	R16,-Y
    08A2 9508      RET
