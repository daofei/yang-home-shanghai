__start:
__text_start:
    003A E5CF      LDI	R28,0x5F
    003B E0D4      LDI	R29,4
    003C BFCD      OUT	0x3D,R28
    003D BFDE      OUT	0x3E,R29
    003E 51C0      SUBI	R28,0x10
    003F 40D0      SBCI	R29,0
    0040 EA0A      LDI	R16,0xAA
    0041 8308      STD	Y+0,R16
    0042 2400      CLR	R0
    0043 E7E3      LDI	R30,0x73
    0044 E0F0      LDI	R31,0
    0045 E010      LDI	R17,0
    0046 38E3      CPI	R30,0x83
    0047 07F1      CPC	R31,R17
    0048 F011      BEQ	0x004B
    0049 9201      ST	R0,Z+
    004A CFFB      RJMP	0x0046
    004B 8300      STD	Z+0,R16
    004C E6E0      LDI	R30,0x60
    004D E0F0      LDI	R31,0
    004E E6A0      LDI	R26,0x60
    004F E0B0      LDI	R27,0
    0050 E010      LDI	R17,0
    0051 37E3      CPI	R30,0x73
    0052 07F1      CPC	R31,R17
    0053 F021      BEQ	0x0058
    0054 95C8      LPM
    0055 9631      ADIW	R30,1
    0056 920D      ST	R0,X+
    0057 CFF9      RJMP	0x0051
    0058 D001      RCALL	_main
_exit:
    0059 CFFF      RJMP	_exit
_main:
  ot                   --> Y+13
  t                    --> Y+0
    005A 97EF      SBIW	R28,0x3F
    005B 972F      SBIW	R28,0xF
FILE: D:\smarthome\smarthome\门禁系统资料\code\main.c
(0001) #include <stdio.h>
(0002) #include <stdlib.h>
(0003) #include <string.h>
(0004) 
(0005) #include<iom16v.h>
(0006) #include <macros.h>
(0007) //#include <sleep.h>
(0008) 
(0009) #include "uart.h"
(0010) #include "wg26.h"
(0011) #include "util.h"
(0012) #include "tips.h"
(0013) #include "timer.h"
(0014) #include "ringandscreen.h"
(0015) #include "eeprom.h"
(0016) #include "password.h"
(0017) #include "locker.h"
(0018) 
(0019) int main(void)
(0020) {
(0021)     //unsigned int door_minitor_count = 0;
(0022)     passwordItem_t t, ot;
(0023) 	
(0024)     uart0_init();
    005C D433      RCALL	_uart0_init
(0025)     wg26_init_interrupt();
    005D D05E      RCALL	_wg26_init_interrupt
(0026)     tips_port_init();
    005E D119      RCALL	_tips_port_init
(0027)     timer_init();
    005F D336      RCALL	_timer_init
(0028)     iicport_init();
    0060 D43B      RCALL	_iicport_init
(0029) 	locker_init();
    0061 D3D5      RCALL	_locker_init
(0030) 	doorandscreen_init();
    0062 D400      RCALL	_doorandscreen_init
(0031) 
(0032)     t.flags = PASSWORDFLAGS_ID;
    0063 E081      LDI	R24,1
    0064 8388      STD	Y+0,R24
(0033)     t.idCard = 1163690;
    0065 EA4A      LDI	R20,0xAA
    0066 EC51      LDI	R21,0xC1
    0067 E161      LDI	R22,0x11
    0068 940E073A  CALL	0x73A
(0034)     t.passwordH = 1;
(0035)     t.passwordL = 1;
(0036)     insertPasswordItem(0, t);
    006A 967A      ADIW	R30,0x1A
    006B 940E07BF  CALL	0x7BF
    006D 5E26      SUBI	R18,0xE6
    006E 4F3F      SBCI	R19,0xFF
    006F 2700      CLR	R16
    0070 D19E      RCALL	_insertPasswordItem
(0037) 
(0038)     t.flags = PASSWORDFLAGS_PASSWORD;
    0071 E082      LDI	R24,2
    0072 8388      STD	Y+0,R24
(0039)     t.idCard = 0;
    0073 E040      LDI	R20,0
    0074 940E0766  CALL	0x766
    0076 8341      STD	Z+1,R20
    0077 8352      STD	Z+2,R21
    0078 8363      STD	Z+3,R22
    0079 8374      STD	Z+4,R23
(0040)     t.passwordH = 1135642406;
    007A E246      LDI	R20,0x26
    007B E857      LDI	R21,0x87
    007C EB60      LDI	R22,0xB0
    007D E473      LDI	R23,0x43
    007E 01FE      MOVW	R30,R28
    007F 8345      STD	Z+5,R20
    0080 8356      STD	Z+6,R21
    0081 8367      STD	Z+7,R22
    0082 8770      STD	Z+8,R23
(0041)     t.passwordL = 100;
    0083 E644      LDI	R20,0x64
    0084 940E0766  CALL	0x766
    0086 8741      STD	Z+9,R20
    0087 8752      STD	Z+10,R21
    0088 8763      STD	Z+11,R22
    0089 8774      STD	Z+12,R23
(0042)     insertPasswordItem(1, t);
    008A 01CE      MOVW	R24,R28
    008B 01FE      MOVW	R30,R28
    008C 96B7      ADIW	R30,0x27
    008D 940E07BF  CALL	0x7BF
    008F 5D29      SUBI	R18,0xD9
    0090 4F3F      SBCI	R19,0xFF
    0091 E001      LDI	R16,1
    0092 D17C      RCALL	_insertPasswordItem
(0043) 
(0044)     t.flags = PASSWORDFLAGS_ID;
    0093 E081      LDI	R24,1
    0094 8388      STD	Y+0,R24
(0045)     t.idCard = 9512827;
    0095 E74B      LDI	R20,0x7B
    0096 E257      LDI	R21,0x27
    0097 E961      LDI	R22,0x91
    0098 940E073A  CALL	0x73A
(0046)     t.passwordH = 1;
(0047)     t.passwordL = 1;
(0048)     insertPasswordItem(2, t);
    009A 96F4      ADIW	R30,0x34
    009B 940E07BF  CALL	0x7BF
    009D 5C2C      SUBI	R18,0xCC
    009E 4F3F      SBCI	R19,0xFF
    009F E002      LDI	R16,2
    00A0 D16E      RCALL	_insertPasswordItem
(0049) 
(0050)     t.flags = PASSWORDFLAGS_ID;
    00A1 E081      LDI	R24,1
    00A2 8388      STD	Y+0,R24
(0051)     t.idCard = 1392618;
    00A3 EE4A      LDI	R20,0xEA
    00A4 E35F      LDI	R21,0x3F
    00A5 E165      LDI	R22,0x15
    00A6 940E073A  CALL	0x73A
(0052)     t.passwordH = 1;
(0053)     t.passwordL = 1;
(0054)     insertPasswordItem(3, t);
    00A8 5BEF      SUBI	R30,0xBF
    00A9 4FFF      SBCI	R31,0xFF
    00AA 940E07BF  CALL	0x7BF
    00AC 5B2F      SUBI	R18,0xBF
    00AD 4F3F      SBCI	R19,0xFF
    00AE E003      LDI	R16,3
    00AF D15F      RCALL	_insertPasswordItem
(0055) 
(0056) 	writePasswordItemNum(4);
    00B0 E004      LDI	R16,4
    00B1 D182      RCALL	_writePasswordItemNum
    00B2 C003      RJMP	0x00B6
(0057) 
(0058)     while(1)
(0059)     {
(0060)         /*
(0061) 		//door_minitor_count++;
(0062) 		if(door_minitor_count>20)
(0063) 		{
(0064) 			//door open.
(0065) 			if(check_door())
(0066) 			{
(0067) 				tips_err();
(0068) 			}
(0069) 			door_minitor_count = 0;
(0070) 		}
(0071) 		delay_ms(500);
(0072) 		*/
(0073) 		//set_sleep_mode(SLEEP_MODE_IDLE);
(0074)         //sleep_mode();
(0075)         delay_ms(500);
    00B3 EF04      LDI	R16,0xF4
    00B4 E011      LDI	R17,1
    00B5 D0B4      RCALL	_delay_ms
    00B6 CFFC      RJMP	0x00B3
(0076)     }
(0077)     return 0;
    00B7 2700      CLR	R16
    00B8 2711      CLR	R17
    00B9 96EF      ADIW	R28,0x3F
    00BA 962F      ADIW	R28,0xF
    00BB 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\wg26.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "password.h"
(0004) #include "timer.h"
(0005) 
(0006) //pc0 input wg26 d0, pc1 input wg26 d1.
(0007) //wg26 d0 is 0, d1 is 1.
(0008) void wg26_init_interrupt(void)
(0009) {
(0010)     //pc0,pc1 input mode.
(0011)     DDRC &= 0xfc;
_wg26_init_interrupt:
    00BC B384      IN	R24,0x14
    00BD 7F8C      ANDI	R24,0xFC
    00BE BB84      OUT	0x14,R24
(0012)     //上拉。
(0013)     PORTC |= 0x03;
    00BF B385      IN	R24,0x15
    00C0 6083      ORI	R24,3
    00C1 BB85      OUT	0x15,R24
(0014)     //enable interrupt.
(0015)     //pd2 input mode.
(0016)     DDRD &= 0xfb;
    00C2 B381      IN	R24,0x11
    00C3 7F8B      ANDI	R24,0xFB
    00C4 BB81      OUT	0x11,R24
(0017) 	//
(0018) 	PORTD |= 0x04;
    00C5 9A92      SBI	0x12,2
(0019) 	
(0020)     SREG |= 0x80;
    00C6 9478      BSET	7
(0021)     //int0 enable.
(0022)     GICR |= 0x40;
    00C7 B78B      IN	R24,0x3B
    00C8 6480      ORI	R24,0x40
    00C9 BF8B      OUT	0x3B,R24
(0023)     //int0 fall edge.
(0024)     MCUCR |= 0x02;
    00CA B785      IN	R24,0x35
    00CB 6082      ORI	R24,2
    00CC BF85      OUT	0x35,R24
(0025)     return;
    00CD 9508      RET
(0026) }
(0027) //diable reader.
(0028) static void disable_reader(void)
(0029) {
(0030)     GICR &= 0xbf;
_disable_reader:
    00CE B78B      IN	R24,0x3B
    00CF 7B8F      ANDI	R24,0xBF
    00D0 BF8B      OUT	0x3B,R24
(0031)     return;
    00D1 9508      RET
(0032) }
(0033) //enable reader.
(0034) static void enable_reader(void)
(0035) {
(0036)     GICR |= 0x40;
_enable_reader:
    00D2 B78B      IN	R24,0x3B
    00D3 6480      ORI	R24,0x40
    00D4 BF8B      OUT	0x3B,R24
(0037)     return;
    00D5 9508      RET
_id_reader_check:
  id_code              --> Y+0
    00D6 940E0629  CALL	push_arg4
(0038) }
(0039) 
(0040) //id card id.
(0041) static unsigned long id_code = 0;
(0042) //read flags.
(0043) static unsigned int id_reader_flags = 0;
(0044) //read count.
(0045) static char read_count = 0;
(0046) //define reader flags.
(0047) #define IDREADERFLAG_WAITING 0x0000
(0048) #define IDREADERFLAG_READING 0x0001
(0049) #define IDREADERFLAG_READED 0x0002
(0050) //id code check.
(0051) static char id_reader_check(unsigned long id_code)
(0052) {
(0053)     return 0;
    00D8 2700      CLR	R16
    00D9 9624      ADIW	R28,4
    00DA 9508      RET
_read_time_out:
  timer                --> R10
    00DB 940E0662  CALL	push_gset3
    00DD 2EA0      MOV	R10,R16
    00DE 9722      SBIW	R28,2
(0054) }
(0055) 
(0056) //read timeout.
(0057) static void read_time_out(char timer)
(0058) {
(0059)     if(timer == IDREADERTIMEOUTTIMER)
    00DF 20AA      TST	R10
    00E0 F009      BEQ	0x00E2
    00E1 C03E      RJMP	0x0120
(0060)     {
(0061)         //disable reader.
(0062)         disable_reader();
    00E2 DFEB      RCALL	_disable_reader
(0063)         id_reader_flags = IDREADERFLAG_READED;
    00E3 E082      LDI	R24,2
    00E4 940E088B  CALL	0x88B
(0064)         //read ok.
(0065)         if(read_count==26) //id card.
    00E6 91800066  LDS	R24,read_count
    00E8 318A      CPI	R24,0x1A
    00E9 F511      BNE	0x010C
(0066)         {
(0067)             if(!id_reader_check(id_code))
    00EA 91200062  LDS	R18,id_code+2
    00EC 91300063  LDS	R19,id_code+3
    00EE 91000060  LDS	R16,id_code
    00F0 91100061  LDS	R17,id_code+1
    00F2 DFE3      RCALL	_id_reader_check
    00F3 2300      TST	R16
    00F4 F009      BEQ	0x00F6
    00F5 C021      RJMP	0x0117
(0068)             {
(0069)                 id_code &= 0x01fffffe;
    00F6 EF4E      LDI	R20,0xFE
    00F7 EF5F      LDI	R21,0xFF
    00F8 EF6F      LDI	R22,0xFF
    00F9 E071      LDI	R23,1
    00FA 940E07CF  CALL	0x7CF
    00FC 940E07E9  CALL	0x7E9
    00FE 940E07A8  CALL	0x7A8
(0070)                 id_code >>= 1;
    0100 9456      LSR	R5
    0101 9447      ROR	R4
    0102 9437      ROR	R3
    0103 9427      ROR	R2
    0104 940E07A8  CALL	0x7A8
(0071)                 password_handle(IDREADEDIDCARD, id_code);
    0106 8248      STD	Y+0,R4
    0107 8259      STD	Y+1,R5
    0108 0191      MOVW	R18,R2
    0109 2700      CLR	R16
    010A D159      RCALL	_password_handle
(0072)             }
(0073)         }
    010B C00B      RJMP	0x0117
(0074)         else if(read_count==4)//keypad input.
    010C 91800066  LDS	R24,read_count
    010E 3084      CPI	R24,4
    010F F439      BNE	0x0117
    0110 940E07CF  CALL	0x7CF
(0075)         {
(0076)             password_handle(IDREADEDKEYPAD, id_code);
    0112 8248      STD	Y+0,R4
    0113 8259      STD	Y+1,R5
    0114 0191      MOVW	R18,R2
    0115 E001      LDI	R16,1
    0116 D14D      RCALL	_password_handle
(0077)         }
(0078)         //enable reader.
(0079)         enable_reader();
    0117 DFBA      RCALL	_enable_reader
(0080)         id_reader_flags = IDREADERFLAG_WAITING;
    0118 2422      CLR	R2
    0119 2433      CLR	R3
    011A 92300065  STS	id_reader_flags+1,R3
    011C 92200064  STS	id_reader_flags,R2
(0081)         read_count = 0;
    011E 92200066  STS	read_count,R2
(0082)     }
(0083)     return;
    0120 9622      ADIW	R28,2
    0121 D538      RCALL	pop_gset3
    0122 9508      RET
_set_id_reading_status:
    0123 D540      RCALL	push_gset2
    0124 9722      SBIW	R28,2
(0084) }
(0085) //set status.
(0086) static void set_id_reading_status(void)
(0087) {
(0088)     if(id_reader_flags!=IDREADERFLAG_READING)
    0125 91800064  LDS	R24,id_reader_flags
    0127 91900065  LDS	R25,id_reader_flags+1
    0129 3081      CPI	R24,1
    012A E0E0      LDI	R30,0
    012B 079E      CPC	R25,R30
    012C F0A9      BEQ	0x0142
(0089)     {
(0090)         id_reader_flags = IDREADERFLAG_READING;
    012D E081      LDI	R24,1
    012E 940E088B  CALL	0x88B
    0130 940E07B1  CALL	0x7B1
(0091)         id_code = 0;
    0132 93500061  STS	id_code+1,R21
    0134 93400060  STS	id_code,R20
    0136 93700063  STS	id_code+3,R23
    0138 93600062  STS	id_code+2,R22
(0092)         //1*100ms.
(0093)         set_timer(IDREADERTIMEOUTTIMER, 1, read_time_out);
    013A E584      LDI	R24,0x54
    013B E090      LDI	R25,0
    013C 8399      STD	Y+1,R25
    013D 8388      STD	Y+0,R24
    013E E021      LDI	R18,1
    013F E030      LDI	R19,0
    0140 2700      CLR	R16
    0141 D263      RCALL	_set_timer
(0094)     }
(0095)     return;
    0142 9622      ADIW	R28,2
    0143 D514      RCALL	pop_gset2
    0144 9508      RET
_int0_isr:
    0145 940E06AB  CALL	push_lset
    0147 D51C      RCALL	push_gset2
(0096) }
(0097) //pull id card id and keypad input.
(0098) #pragma interrupt_handler int0_isr:2
(0099) void int0_isr(void)
(0100) {
(0101)     set_id_reading_status();
    0148 DFDA      RCALL	_set_id_reading_status
(0102)     if(!(PINC&0x02))
    0149 9999      SBIC	0x13,1
    014A C00D      RJMP	0x0158
    014B 940E0793  CALL	0x793
    014D 940E078E  CALL	0x78E
(0103)     {
(0104)         id_code <<= 1;
(0105)         id_code |= 1;
    014F 2A24      OR	R2,R20
    0150 2A35      OR	R3,R21
    0151 2A46      OR	R4,R22
    0152 2A57      OR	R5,R23
    0153 940E07A8  CALL	0x7A8
    0155 940E0885  CALL	0x885
(0106)         ++read_count;
(0107)     }
    0157 C006      RJMP	0x015E
(0108)     else if(!(PINC&0x01))
    0158 9998      SBIC	0x13,0
    0159 C004      RJMP	0x015E
    015A 940E0793  CALL	0x793
    015C 940E0885  CALL	0x885
(0109)     {
(0110)         id_code <<= 1;
(0111)         ++read_count;
(0112)     }
(0113)     return;
    015E D4F9      RCALL	pop_gset2
    015F D55E      RCALL	pop_lset
    0160 9518      RETI
FILE: D:\smarthome\smarthome\门禁系统资料\code\util.c
(0001) #include "util.h"
(0002) 
(0003) #define XTAL    8
(0004) void delay_1ms(void)
(0005) {
(0006)     int i;
(0007)     //XTAL*143-2 = 1142
(0008)     for(i=1;i<1142;i++);
_delay_1ms:
  i                    --> R16
    0161 E001      LDI	R16,1
    0162 E010      LDI	R17,0
    0163 5F0F      SUBI	R16,0xFF
    0164 4F1F      SBCI	R17,0xFF
    0165 3706      CPI	R16,0x76
    0166 E0E4      LDI	R30,4
    0167 071E      CPC	R17,R30
    0168 F3D4      BLT	0x0163
    0169 9508      RET
_delay_ms:
  i                    --> R20
  ms                   --> R22
    016A D4F9      RCALL	push_gset2
    016B 01B8      MOVW	R22,R16
(0009) }
(0010) //=========================================
(0011) void delay_ms(int ms)
(0012) {
(0013)     int i=0;
    016C 2744      CLR	R20
    016D 2755      CLR	R21
    016E C003      RJMP	0x0172
(0014)     while(i<ms)
(0015)     {
(0016)         delay_1ms();
    016F DFF1      RCALL	_delay_1ms
(0017)         i++;
    0170 5F4F      SUBI	R20,0xFF
    0171 4F5F      SBCI	R21,0xFF
    0172 1746      CP	R20,R22
    0173 0757      CPC	R21,R23
    0174 F3D4      BLT	0x016F
    0175 D4E2      RCALL	pop_gset2
    0176 9508      RET
(0018)     }
(0019) }
(0020) 
(0021) void gotoSleep(void)
(0022) {
_gotoSleep:
    0177 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\tips.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "tips.h"
(0005) #include "util.h"
(0006) 
(0007) #define BEEP_ON (PORTB&=0xdf)
(0008) #define BEEP_OFF (PORTB|=0x20)
(0009) #define LED_ON (PORTB&=0xbf)
(0010) #define LED_OFF (PORTB|=0x40)
(0011) 
(0012) //pb5 beep,pb6 led.
(0013) void tips_port_init(void)
(0014) {
(0015)     //PINB5 & PINB6 PINB0 tips led. OUTPUT AND pull-up resistors.
(0016)     PORTB |= 0x60;
_tips_port_init:
    0178 B388      IN	R24,0x18
    0179 6680      ORI	R24,0x60
    017A BB88      OUT	0x18,R24
(0017)     DDRB |= 0x60;
    017B B387      IN	R24,0x17
    017C 6680      ORI	R24,0x60
    017D BB87      OUT	0x17,R24
(0018)     return;
    017E 9508      RET
(0019) }
(0020) //led on.
(0021) void tips_led_on(void)
(0022) {
(0023)     LED_ON;
_tips_led_on:
    017F B388      IN	R24,0x18
    0180 7B8F      ANDI	R24,0xBF
    0181 BB88      OUT	0x18,R24
(0024)     return;
    0182 9508      RET
(0025) }
(0026) //led off.
(0027) void tips_led_off(void)
(0028) {
(0029)     LED_OFF;
_tips_led_off:
    0183 9AC6      SBI	0x18,6
(0030)     return;
    0184 9508      RET
(0031) }
(0032) //beep on.
(0033) void tips_beep_on(void)
(0034) {
(0035)     BEEP_ON;
_tips_beep_on:
    0185 B388      IN	R24,0x18
    0186 7D8F      ANDI	R24,0xDF
    0187 BB88      OUT	0x18,R24
(0036)     return;
    0188 9508      RET
(0037) }
(0038) //beep off.
(0039) void tips_beep_off(void)
(0040) {
(0041)     BEEP_OFF;
_tips_beep_off:
    0189 9AC5      SBI	0x18,5
(0042)     return;
    018A 9508      RET
(0043) }
(0044) //__------__ 6 pices.pice per 0.4 seconds.
(0045) void tips_ok(void)
(0046) {
(0047)     LED_ON;
_tips_ok:
    018B B388      IN	R24,0x18
    018C 7B8F      ANDI	R24,0xBF
    018D BB88      OUT	0x18,R24
    018E 940E0847  CALL	0x847
(0048)     BEEP_ON;
(0049)     //2.4 seconds.
(0050)     delay_ms(400);
    0190 DFD9      RCALL	_delay_ms
(0051)     LED_OFF;
    0191 9AC6      SBI	0x18,6
(0052)     BEEP_OFF;
    0192 9AC5      SBI	0x18,5
(0053)     return;
    0193 9508      RET
(0054) }
(0055) //_-_-___-_-_
(0056) void tips_err(void)
(0057) {
(0058)     BEEP_ON;
_tips_err:
    0194 940E07D8  CALL	0x7D8
(0059)     delay_ms(100);
    0196 DFD3      RCALL	_delay_ms
(0060)     BEEP_OFF;
    0197 9AC5      SBI	0x18,5
(0061)     delay_ms(100);
    0198 E604      LDI	R16,0x64
    0199 E010      LDI	R17,0
    019A DFCF      RCALL	_delay_ms
    019B 940E07D8  CALL	0x7D8
(0062)     BEEP_ON;
(0063)     delay_ms(100);
    019D DFCC      RCALL	_delay_ms
(0064)     BEEP_OFF;
    019E 9AC5      SBI	0x18,5
(0065)  
(0066)     delay_ms(200);
    019F EC08      LDI	R16,0xC8
    01A0 E010      LDI	R17,0
    01A1 DFC8      RCALL	_delay_ms
    01A2 940E07D8  CALL	0x7D8
(0067)  
(0068)     BEEP_ON;
(0069)     delay_ms(100);
    01A4 DFC5      RCALL	_delay_ms
(0070)     BEEP_OFF;
    01A5 9AC5      SBI	0x18,5
(0071)     delay_ms(100);
    01A6 E604      LDI	R16,0x64
    01A7 E010      LDI	R17,0
    01A8 DFC1      RCALL	_delay_ms
    01A9 940E07D8  CALL	0x7D8
(0072)     BEEP_ON;
(0073)     delay_ms(100);
    01AB DFBE      RCALL	_delay_ms
(0074)     BEEP_OFF;
    01AC 9AC5      SBI	0x18,5
(0075)     return;
    01AD 9508      RET
(0076) }
(0077) //_----_-_-_
(0078) void tips_id_ok(void)
(0079) {
(0080)     BEEP_ON;
_tips_id_ok:
    01AE B388      IN	R24,0x18
    01AF 7D8F      ANDI	R24,0xDF
    01B0 BB88      OUT	0x18,R24
(0081)     delay_ms(200);
    01B1 EC08      LDI	R16,0xC8
    01B2 E010      LDI	R17,0
    01B3 DFB6      RCALL	_delay_ms
(0082)     BEEP_OFF;
    01B4 9AC5      SBI	0x18,5
(0083)     delay_ms(200);
    01B5 EC08      LDI	R16,0xC8
    01B6 E010      LDI	R17,0
    01B7 DFB2      RCALL	_delay_ms
    01B8 940E07D8  CALL	0x7D8
(0084) 
(0085)     BEEP_ON;
(0086)     delay_ms(100);
    01BA DFAF      RCALL	_delay_ms
(0087)     BEEP_OFF;
    01BB 9AC5      SBI	0x18,5
(0088)     delay_ms(100);
    01BC E604      LDI	R16,0x64
    01BD E010      LDI	R17,0
    01BE DFAB      RCALL	_delay_ms
    01BF 940E07D8  CALL	0x7D8
(0089)     BEEP_ON;
(0090)     delay_ms(100);
    01C1 DFA8      RCALL	_delay_ms
(0091)     BEEP_OFF;
    01C2 9AC5      SBI	0x18,5
(0092)     return;
    01C3 9508      RET
    01C4 940E0847  CALL	0x847
(0093) }
(0094) //__------__-----__
(0095) void tips_ring_on(void)
(0096) {
(0097)     BEEP_ON;
(0098)     //2.4 seconds.
(0099)     delay_ms(400);
_tips_ring_on:
    01C6 DFA3      RCALL	_delay_ms
(0100)     BEEP_OFF;
    01C7 9AC5      SBI	0x18,5
(0101)     delay_ms(400);
    01C8 E900      LDI	R16,0x90
    01C9 E011      LDI	R17,1
    01CA DF9F      RCALL	_delay_ms
    01CB 940E0847  CALL	0x847
(0102)     BEEP_ON;
(0103)     //2.4 seconds.
(0104)     delay_ms(400);
    01CD DF9C      RCALL	_delay_ms
(0105)     BEEP_OFF;
    01CE 9AC5      SBI	0x18,5
(0106)     return;
    01CF 9508      RET
_readPasswordItemNum:
  num                  --> Y+3
    01D0 9724      SBIW	R28,4
FILE: D:\smarthome\smarthome\门禁系统资料\code\password.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "log.h"
(0005) #include "locker.h"
(0006) #include "tips.h"
(0007) #include "timer.h"
(0008) #include "iic.h"
(0009) #include "eeprom.h"
(0010) #include "password.h"
(0011) #include "ringandscreen.h"
(0012) 
(0013) //eeprom 
(0014) //addr: 0 number.
(0015) 
(0016) // 1: flags
(0017) // 2,3,4,5: id Card.
(0018) // 6,7,8,9: password H
(0019) // 10,11,12,13 :password L
(0020) 
(0021) // 14: flags
(0022) // 15,16,17,18: id Card.
(0023) // 19,20,21,22: password H
(0024) // 23,24,25,26 :password L
(0025) 
(0026) unsigned char readPasswordItemNum(void)
(0027) {
(0028)     unsigned char num = 0;
    01D1 2422      CLR	R2
    01D2 822B      STD	Y+3,R2
(0029) 
(0030)     rw24c256(&num, 1, 0, RWREAD);
    01D3 E081      LDI	R24,1
    01D4 838A      STD	Y+2,R24
    01D5 940E085B  CALL	0x85B
    01D7 D2A7      RCALL	_rw24c256
(0031)     return num;
    01D8 810B      LDD	R16,Y+3
    01D9 9624      ADIW	R28,4
    01DA 9508      RET
_readPasswordItem:
  t                    --> Y+16
  item                 --> Y+3
  index                --> R22
    01DB D488      RCALL	push_gset2
    01DC 2F62      MOV	R22,R18
    01DD 01A8      MOVW	R20,R16
    01DE 9761      SBIW	R28,0x11
(0032) }
(0033) 
(0034) passwordItem_t readPasswordItem(unsigned char index)
(0035) {
(0036)     passwordItem_t item;
(0037)     unsigned char t = 0;
    01DF 2422      CLR	R2
    01E0 8A28      STD	Y+16,R2
    01E1 940E0807  CALL	0x807
    01E3 940E089B  CALL	0x89B
(0038) 
(0039)     rw24c256(&t, 1, index*13+1, RWREAD);
    01E5 018E      MOVW	R16,R28
    01E6 5F00      SUBI	R16,0xF0
    01E7 4F1F      SBCI	R17,0xFF
    01E8 D296      RCALL	_rw24c256
(0040)     item.flags = t;
    01E9 8828      LDD	R2,Y+16
    01EA 822B      STD	Y+3,R2
    01EB 940E0807  CALL	0x807
(0041) 
(0042)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWREAD);
    01ED 9602      ADIW	R24,2
    01EE 940E086D  CALL	0x86D
    01F0 5F0C      SUBI	R16,0xFC
    01F1 4F1F      SBCI	R17,0xFF
    01F2 D28C      RCALL	_rw24c256
    01F3 940E0807  CALL	0x807
(0043)     
(0044)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWREAD);
    01F5 9606      ADIW	R24,6
    01F6 940E086D  CALL	0x86D
    01F8 5F08      SUBI	R16,0xF8
    01F9 4F1F      SBCI	R17,0xFF
    01FA D284      RCALL	_rw24c256
    01FB 940E0807  CALL	0x807
(0045) 	
(0046)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWREAD);
    01FD 960A      ADIW	R24,0xA
    01FE 940E086D  CALL	0x86D
    0200 5F04      SUBI	R16,0xF4
    0201 4F1F      SBCI	R17,0xFF
    0202 D27C      RCALL	_rw24c256
(0047)     
(0048)     return item;
    0203 01CE      MOVW	R24,R28
    0204 9603      ADIW	R24,3
    0205 E00D      LDI	R16,0xD
    0206 E010      LDI	R17,0
    0207 935A      ST	R21,-Y
    0208 934A      ST	R20,-Y
    0209 939A      ST	R25,-Y
    020A 938A      ST	R24,-Y
    020B D4FA      RCALL	asgnblk
    020C 9661      ADIW	R28,0x11
    020D D44A      RCALL	pop_gset2
    020E 9508      RET
_insertPasswordItem:
  item                 --> R20
  index                --> R22
    020F D454      RCALL	push_gset2
    0210 01A9      MOVW	R20,R18
    0211 2F60      MOV	R22,R16
    0212 9723      SBIW	R28,3
    0213 940E0823  CALL	0x823
    0215 940E089B  CALL	0x89B
(0049) }
(0050) 
(0051) void insertPasswordItem(unsigned char index, passwordItem_t item)
(0052) {
(0053)     rw24c256(&(item.flags), 1, index*13+1, RWWRITE);
    0217 018A      MOVW	R16,R20
    0218 D266      RCALL	_rw24c256
    0219 940E0823  CALL	0x823
(0054) 	
(0055)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWWRITE);
    021B 9602      ADIW	R24,2
    021C 940E0868  CALL	0x868
    021E 5F0F      SUBI	R16,0xFF
    021F 4F1F      SBCI	R17,0xFF
    0220 D25E      RCALL	_rw24c256
    0221 940E0823  CALL	0x823
(0056) 	
(0057)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWWRITE);
    0223 9606      ADIW	R24,6
    0224 940E0868  CALL	0x868
    0226 5F0B      SUBI	R16,0xFB
    0227 4F1F      SBCI	R17,0xFF
    0228 D256      RCALL	_rw24c256
    0229 940E0823  CALL	0x823
(0058) 	
(0059)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWWRITE);
    022B 960A      ADIW	R24,0xA
    022C 940E0868  CALL	0x868
    022E 5F07      SUBI	R16,0xF7
    022F 4F1F      SBCI	R17,0xFF
    0230 D24E      RCALL	_rw24c256
(0060) 	
(0061)     return;
    0231 9623      ADIW	R28,3
    0232 D425      RCALL	pop_gset2
    0233 9508      RET
_writePasswordItemNum:
  num                  --> Y+3
    0234 931A      ST	R17,-Y
    0235 930A      ST	R16,-Y
    0236 9723      SBIW	R28,3
(0062) }
(0063) 
(0064) void writePasswordItemNum(unsigned char num)
(0065) {
(0066)     rw24c256(&num, 1, 0, RWWRITE);
    0237 2422      CLR	R2
    0238 822A      STD	Y+2,R2
    0239 940E085B  CALL	0x85B
    023B D243      RCALL	_rw24c256
(0067)     return;
    023C 9625      ADIW	R28,5
    023D 9508      RET
_clear_pswd_status:
    023E D425      RCALL	push_gset2
    023F 940E078E  CALL	0x78E
(0068) }
(0069) 
(0070) #define PASSWORDREADIDCARDUNKOWN    0
(0071) #define PASSWORDREADIDCARDOK                1
(0072) #define PASSWORDREADIDANDPSWDOK         2
(0073) 
(0074) static unsigned char password_read_flags = 0;
(0075) static unsigned char current_index = 0;
(0076) static unsigned char input_err_count = 0;
(0077) 
(0078) //You input xxx then password is 1xxx.
(0079) static unsigned long passwordH = 1;
(0080) static unsigned long passwordL = 1;
(0081) 
(0082) static void clear_pswd_status(void)
(0083) {
(0084)     //clear last password input.
(0085)     passwordH = 1;
    0241 9350006B  STS	passwordH+1,R21
    0243 9340006A  STS	passwordH,R20
    0245 9370006D  STS	passwordH+3,R23
    0247 9360006C  STS	passwordH+2,R22
    0249 940E078E  CALL	0x78E
    024B 940E0833  CALL	0x833
(0086)     passwordL = 1;
(0087)     tips_led_off();
    024D DF35      RCALL	_tips_led_off
(0088)     password_read_flags = PASSWORDREADIDCARDUNKOWN;
    024E 2422      CLR	R2
    024F 92200067  STS	password_read_flags,R2
(0089)     current_index = 0;
    0251 92200068  STS	current_index,R2
(0090)     stop_timer(PASSWORDTIMEOUTTIMER);
    0253 E001      LDI	R16,1
    0254 D170      RCALL	_stop_timer
(0091)     return;
    0255 D402      RCALL	pop_gset2
    0256 9508      RET
(0092) }
(0093) 
(0094) //cannot input timeout.
(0095) static void cannot_input_time_out(char timer)
(0096) {
(0097)     if(timer==PASSWORDTIMEOUTTIMER)
_cannot_input_time_out:
  timer                --> R16
    0257 3001      CPI	R16,1
    0258 F419      BNE	0x025C
(0098)         input_err_count = 0;
    0259 2422      CLR	R2
    025A 92200069  STS	input_err_count,R2
(0099)     return;
    025C 9508      RET
_input_time_out:
  timer                --> R20
    025D D408      RCALL	push_gset1
    025E 2F40      MOV	R20,R16
(0100) }
(0101) 
(0102) //input timeout.
(0103) static void input_time_out(char timer)
(0104) {
(0105)     if(timer==PASSWORDTIMEOUTTIMER)
    025F 3041      CPI	R20,1
    0260 F409      BNE	0x0262
(0106)         clear_pswd_status();
    0261 DFDC      RCALL	_clear_pswd_status
(0107)     return;
    0262 D406      RCALL	pop_gset1
    0263 9508      RET
_password_handle:
  current_item         --> Y+25
  pswd_item_num        --> R10
  i                    --> R12
  item                 --> Y+12
  code                 --> Y+48
  type                 --> R14
    0264 933A      ST	R19,-Y
    0265 932A      ST	R18,-Y
    0266 D3F7      RCALL	push_gset5
    0267 2EE0      MOV	R14,R16
    0268 97A6      SBIW	R28,0x26
(0108) }
(0109) 
(0110) void password_handle(char type, unsigned long code)
(0111) {
(0112)     unsigned char pswd_item_num = 0;
    0269 24AA      CLR	R10
(0113)     unsigned char i;
(0114)     passwordItem_t item;
(0115) 
(0116) 	//on screen
(0117) 	screen_on();
    026A D203      RCALL	_screen_on
(0118)     //if input error count is too large.
(0119)     if(input_err_count>5)
    026B E085      LDI	R24,5
    026C 90200069  LDS	R2,input_err_count
    026E 1582      CP	R24,R2
    026F F458      BCC	0x027B
(0120)     {
(0121)         clear_pswd_status();
    0270 DFCD      RCALL	_clear_pswd_status
(0122)         tips_err();
    0271 DF22      RCALL	_tips_err
(0123)         //set time out. 100ms*10*60
(0124)         set_timer(PASSWORDTIMEOUTTIMER, 600, cannot_input_time_out);
    0272 E588      LDI	R24,0x58
    0273 E090      LDI	R25,0
    0274 8399      STD	Y+1,R25
    0275 8388      STD	Y+0,R24
    0276 E528      LDI	R18,0x58
    0277 E032      LDI	R19,2
    0278 E001      LDI	R16,1
    0279 D12B      RCALL	_set_timer
(0125)         return;
    027A C117      RJMP	0x0392
(0126)     }
(0127)  
(0128)     //read a card.
(0129)     if(type==IDREADEDIDCARD)
    027B 20EE      TST	R14
    027C F009      BEQ	0x027E
    027D C03F      RJMP	0x02BD
(0130)     {
(0131)         clear_pswd_status();
    027E DFBF      RCALL	_clear_pswd_status
(0132)         //read paswd item num.
(0133)         pswd_item_num = readPasswordItemNum();
    027F DF50      RCALL	_readPasswordItemNum
    0280 2EA0      MOV	R10,R16
(0134)         //loop find it.
(0135)         for(i=0;i<pswd_item_num;++i)
    0281 24CC      CLR	R12
    0282 C02D      RJMP	0x02B0
(0136)         {
(0137)             //read a item.
(0138)             item = readPasswordItem(i);
    0283 940E0896  CALL	0x896
    0285 DF55      RCALL	_readPasswordItem
(0139)             //if item need id card, and is this id card.
(0140)             if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
    0286 842C      LDD	R2,Y+12
    0287 FE20      SBRS	R2,0
    0288 C026      RJMP	0x02AF
    0289 01FE      MOVW	R30,R28
    028A A820      LDD	R2,Z+48
    028B A831      LDD	R3,Z+49
    028C A842      LDD	R4,Z+50
    028D A853      LDD	R5,Z+51
    028E 01FE      MOVW	R30,R28
    028F 8465      LDD	R6,Z+13
    0290 8476      LDD	R7,Z+14
    0291 8487      LDD	R8,Z+15
    0292 8890      LDD	R9,Z+16
    0293 940E0829  CALL	0x829
    0295 F009      BEQ	0x0297
    0296 C018      RJMP	0x02AF
(0141)             {
(0142)                 //need paswd.
(0143)                 if(item.flags&PASSWORDFLAGS_PASSWORD)
    0297 842C      LDD	R2,Y+12
    0298 FE21      SBRS	R2,1
    0299 C00A      RJMP	0x02A4
(0144)                 {
(0145)                     //id card ok, but need password.
(0146)                     //tips_id_ok();
(0147)                     //id card ok, but not input password, led on.
(0148)                     tips_led_on();
    029A DEE4      RCALL	_tips_led_on
(0149)                     current_index = i;
    029B 92C00068  STS	current_index,R12
(0150)                     password_read_flags = PASSWORDREADIDCARDOK;
    029D E081      LDI	R24,1
    029E 93800067  STS	password_read_flags,R24
    02A0 940E0853  CALL	0x853
(0151)                     //set time out. 100ms*10*30
(0152)                     set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    02A2 D102      RCALL	_set_timer
(0153)                 }
    02A3 C0EE      RJMP	0x0392
(0154)                 else //only id card.
(0155)                 {
(0156)                     //record log
(0157)                     log(LOGTYPEIDOK, i, code, 0, 0);
    02A4 940E076B  CALL	0x76B
    02A6 2D2C      MOV	R18,R12
    02A7 E001      LDI	R16,1
    02A8 D18D      RCALL	_log
(0158)                     //clear pswd statuc.
(0159)                     clear_pswd_status();
    02A9 DF94      RCALL	_clear_pswd_status
(0160)                     //tips_ok();
(0161)                     locker_unlock();
    02AA D1A3      RCALL	_locker_unlock
(0162)                     //error count clear.
(0163)                     input_err_count = 0;
    02AB 2422      CLR	R2
    02AC 92200069  STS	input_err_count,R2
(0164)                 } //else
(0165)                 return;
    02AE C0E3      RJMP	0x0392
    02AF 94C3      INC	R12
    02B0 14CA      CP	R12,R10
    02B1 F408      BCC	0x02B3
    02B2 CFD0      RJMP	0x0283
(0166)             }  //if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
(0167)         }	  //for(i=0;i<pswd_item_num;++i)
(0168)         //unkown id card.
(0169)         log(LOGTYPEIDERR, 0, code, 0, 0);
    02B3 940E076B  CALL	0x76B
    02B5 2722      CLR	R18
    02B6 E002      LDI	R16,2
    02B7 D17E      RCALL	_log
(0170)         //clear password.
(0171)         clear_pswd_status();
    02B8 DF85      RCALL	_clear_pswd_status
(0172)         //error password and log.
(0173)         tips_err();
    02B9 DEDA      RCALL	_tips_err
    02BA 940E0841  CALL	0x841
(0174)         //error count ++
(0175)         ++input_err_count;
(0176)         return;
    02BC C0D5      RJMP	0x0392
(0177)     }	  //if(type==IDREADEDIDCARD)
(0178)     else if(type==IDREADEDKEYPAD) // read a keypad input.
    02BD 2D8E      MOV	R24,R14
    02BE 3081      CPI	R24,1
    02BF F009      BEQ	0x02C1
    02C0 C0D1      RJMP	0x0392
(0179)     {
(0180)         code &= 0x0000000f;
    02C1 E04F      LDI	R20,0xF
    02C2 940E0766  CALL	0x766
    02C4 940E07E4  CALL	0x7E4
    02C6 940E07E9  CALL	0x7E9
    02C8 01FE      MOVW	R30,R28
    02C9 AA20      STD	Z+48,R2
    02CA AA31      STD	Z+49,R3
    02CB AA42      STD	Z+50,R4
    02CC AA53      STD	Z+51,R5
(0181)         if(code == 0x0000000a)  //*
    02CD E04A      LDI	R20,0xA
    02CE 940E0766  CALL	0x766
    02D0 940E07E4  CALL	0x7E4
    02D2 940E0891  CALL	0x891
    02D4 F411      BNE	0x02D7
(0182)         {
(0183)             //clear password.
(0184)             clear_pswd_status();
    02D5 DF68      RCALL	_clear_pswd_status
(0185)         }
    02D6 C0BB      RJMP	0x0392
(0186)         else if(code == 0x0000000b) //#
    02D7 E04B      LDI	R20,0xB
    02D8 940E0766  CALL	0x766
    02DA 940E07E4  CALL	0x7E4
    02DC 940E0891  CALL	0x891
    02DE F009      BEQ	0x02E0
    02DF C07B      RJMP	0x035B
(0187)         {
(0188)             //need id card password.
(0189)             if(password_read_flags==PASSWORDREADIDCARDOK)
    02E0 91800067  LDS	R24,password_read_flags
    02E2 3081      CPI	R24,1
    02E3 F009      BEQ	0x02E5
    02E4 C034      RJMP	0x0319
(0190)             {
(0191)                 passwordItem_t current_item = readPasswordItem(current_index);
    02E5 91200068  LDS	R18,current_index
    02E7 018E      MOVW	R16,R28
    02E8 5E07      SUBI	R16,0xE7
    02E9 4F1F      SBCI	R17,0xFF
    02EA DEF0      RCALL	_readPasswordItem
    02EB 940E0785  CALL	0x785
(0192)                 //password is ok.
(0193)                 if((current_item.passwordH==passwordH)&&(current_item.passwordL==passwordL))
    02ED 01FE      MOVW	R30,R28
    02EE 8C66      LDD	R6,Z+30
    02EF 8C77      LDD	R7,Z+31
    02F0 A080      LDD	R8,Z+32
    02F1 A091      LDD	R9,Z+33
    02F2 940E0829  CALL	0x829
    02F4 F009      BEQ	0x02F6
    02F5 C016      RJMP	0x030C
    02F6 940E07B6  CALL	0x7B6
    02F8 01FE      MOVW	R30,R28
    02F9 A062      LDD	R6,Z+34
    02FA A073      LDD	R7,Z+35
    02FB A084      LDD	R8,Z+36
    02FC A095      LDD	R9,Z+37
    02FD 940E0829  CALL	0x829
    02FF F461      BNE	0x030C
    0300 940E0755  CALL	0x755
    0302 940E07F3  CALL	0x7F3
(0194)                 {
(0195)                     log(LOGTYPEIDANDPSWDOK, current_index, current_item.idCard, passwordH, passwordL);
    0304 E003      LDI	R16,3
    0305 D130      RCALL	_log
(0196)                     //clear password status.
(0197)                     clear_pswd_status();
    0306 DF37      RCALL	_clear_pswd_status
(0198)                     //unlock and write log.
(0199)                     //tips_ok();
(0200)                     locker_unlock();
    0307 D146      RCALL	_locker_unlock
(0201)                     //error count clear.
(0202)                     input_err_count = 0;
    0308 2422      CLR	R2
    0309 92200069  STS	input_err_count,R2
(0203)                 }
    030B C086      RJMP	0x0392
(0204)                 else //password is error.
(0205)                 {
(0206)                     log(LOGTYPEIDANDPSWDERR, current_index, current_item.idCard, passwordH, passwordL);
    030C 940E07B6  CALL	0x7B6
    030E 940E0755  CALL	0x755
    0310 940E07F3  CALL	0x7F3
    0312 E004      LDI	R16,4
    0313 D122      RCALL	_log
(0207)                     //clear password.
(0208)                     clear_pswd_status();
    0314 DF29      RCALL	_clear_pswd_status
(0209)                     //error password and log.
(0210)                     tips_err();
    0315 DE7E      RCALL	_tips_err
    0316 940E0841  CALL	0x841
(0211)                     //error count ++.
(0212)                     ++input_err_count;
(0213)                 }
(0214)             }
    0318 C079      RJMP	0x0392
(0215)             else //only password.
(0216)             {
(0217)                 //read paswd item num.
(0218)                 pswd_item_num = readPasswordItemNum();
    0319 DEB6      RCALL	_readPasswordItemNum
    031A 2EA0      MOV	R10,R16
(0219)                 //loop find it.
(0220)                 for(i=0;i<pswd_item_num;++i)
    031B 24CC      CLR	R12
    031C C02B      RJMP	0x0348
(0221)                 {
(0222)                     //read a item.
(0223)                     item = readPasswordItem(i);
    031D 940E0896  CALL	0x896
    031F DEBB      RCALL	_readPasswordItem
(0224)                     //if item need id card, and is this id card.
(0225)                     if((item.flags==PASSWORDFLAGS_PASSWORD)&&(item.passwordH==passwordH)
    0320 858C      LDD	R24,Y+12
    0321 3082      CPI	R24,2
    0322 F009      BEQ	0x0324
    0323 C023      RJMP	0x0347
    0324 940E0785  CALL	0x785
    0326 01FE      MOVW	R30,R28
    0327 8861      LDD	R6,Z+17
    0328 8872      LDD	R7,Z+18
    0329 8883      LDD	R8,Z+19
    032A 8894      LDD	R9,Z+20
    032B 940E0829  CALL	0x829
    032D F4C9      BNE	0x0347
    032E 940E07B6  CALL	0x7B6
    0330 01FE      MOVW	R30,R28
    0331 8865      LDD	R6,Z+21
    0332 8876      LDD	R7,Z+22
    0333 8887      LDD	R8,Z+23
    0334 8C90      LDD	R9,Z+24
    0335 940E0829  CALL	0x829
    0337 F479      BNE	0x0347
    0338 940E0755  CALL	0x755
    033A 940E07B1  CALL	0x7B1
    033C 940E08A0  CALL	0x8A0
(0226)                         &&(item.passwordL==passwordL))
(0227)                     {
(0228)                         log(LOGTYPEPSWDOK, i, 0, passwordH, passwordL);
    033E 2D2C      MOV	R18,R12
    033F E005      LDI	R16,5
    0340 D0F5      RCALL	_log
(0229)                         //clear password.
(0230)                         clear_pswd_status();
    0341 DEFC      RCALL	_clear_pswd_status
(0231)                         //password is right. unlock and log.
(0232)                         //tips_ok();
(0233)                         locker_unlock();
    0342 D10B      RCALL	_locker_unlock
(0234)                         //error count clear.
(0235)                         input_err_count = 0;
    0343 2422      CLR	R2
    0344 92200069  STS	input_err_count,R2
(0236)                         return;
    0346 C04B      RJMP	0x0392
    0347 94C3      INC	R12
    0348 14CA      CP	R12,R10
    0349 F408      BCC	0x034B
    034A CFD2      RJMP	0x031D
(0237)                     }
(0238)                 }
(0239)                 //password is error.
(0240)                 log(LOGTYPEPSWDERR, 0, 0, passwordH, passwordL);
    034B 940E07B6  CALL	0x7B6
    034D 940E0755  CALL	0x755
    034F 940E07B1  CALL	0x7B1
    0351 940E08A0  CALL	0x8A0
    0353 2722      CLR	R18
    0354 E006      LDI	R16,6
    0355 D0E0      RCALL	_log
(0241)                 //clear password.
(0242)                 clear_pswd_status();
    0356 DEE7      RCALL	_clear_pswd_status
(0243)                 //password is error, and log.
(0244)                 tips_err();
    0357 DE3C      RCALL	_tips_err
    0358 940E0841  CALL	0x841
(0245)                 //error count++.
(0246)                 ++input_err_count;
(0247)                 return;
    035A C037      RJMP	0x0392
(0248)             }
(0249)         }
(0250)         else
(0251)         {
(0252)             tips_led_on();
    035B DE23      RCALL	_tips_led_on
    035C 940E0853  CALL	0x853
(0253)             //set time out. 100ms*10*30
(0254)             set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    035E D046      RCALL	_set_timer
    035F 940E07B6  CALL	0x7B6
(0255)             passwordL = passwordL*10 + code;
    0361 E04A      LDI	R20,0xA
    0362 E050      LDI	R21,0
    0363 E060      LDI	R22,0
    0364 E070      LDI	R23,0
    0365 940E08AA  CALL	0x8AA
    0367 018A      MOVW	R16,R20
    0368 019B      MOVW	R18,R22
    0369 D2C2      RCALL	empy32s
    036A 0118      MOVW	R2,R16
    036B 0129      MOVW	R4,R18
    036C 01FE      MOVW	R30,R28
    036D A860      LDD	R6,Z+48
    036E A871      LDD	R7,Z+49
    036F A882      LDD	R8,Z+50
    0370 A893      LDD	R9,Z+51
    0371 0C26      ADD	R2,R6
    0372 1C37      ADC	R3,R7
    0373 1C48      ADC	R4,R8
    0374 1C59      ADC	R5,R9
    0375 9230006F  STS	passwordL+1,R3
    0377 9220006E  STS	passwordL,R2
    0379 92500071  STS	passwordL+3,R5
    037B 92400070  STS	passwordL+2,R4
(0256)             //passwordH save password hight 9 num.
(0257)             if(passwordL>999999999)
    037D EF4F      LDI	R20,0xFF
    037E EC59      LDI	R21,0xC9
    037F E96A      LDI	R22,0x9A
    0380 E37B      LDI	R23,0x3B
    0381 1542      CP	R20,R2
    0382 0553      CPC	R21,R3
    0383 0564      CPC	R22,R4
    0384 0575      CPC	R23,R5
    0385 F460      BCC	0x0392
(0258)             {
(0259)                 passwordH = passwordL;
    0386 9230006B  STS	passwordH+1,R3
    0388 9220006A  STS	passwordH,R2
    038A 9250006D  STS	passwordH+3,R5
    038C 9240006C  STS	passwordH+2,R4
    038E 940E078E  CALL	0x78E
    0390 940E0833  CALL	0x833
(0260)                 passwordL = 1;
(0261)             }
(0262)         }
(0263)     }
(0264)     return;
    0392 96A6      ADIW	R28,0x26
    0393 D2C8      RCALL	pop_gset5
    0394 9622      ADIW	R28,2
    0395 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\timer.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "timer.h"
(0005) 
(0006) void timer_init(void)
(0007) {
(0008)     //enable interrupt.
(0009)     SREG |= 0x80;
_timer_init:
    0396 9478      BSET	7
(0010)     //timer0 normal mode.ck/1024.
(0011)     TCCR0 |= 0x05;
    0397 B783      IN	R24,0x33
    0398 6085      ORI	R24,5
    0399 BF83      OUT	0x33,R24
(0012)     //init TCNT0.
(0013)     TCNT0 = 0;
    039A 2422      CLR	R2
    039B BE22      OUT	0x32,R2
(0014)     //TIMSK
(0015)     //TIMSK |= 0x01;
(0016)     return; 
    039C 9508      RET
(0017) }
(0018) //cpu timer0 start
(0019) static void t0_start(void)
(0020) {
(0021)     TIMSK |= 0x01;
_t0_start:
    039D B789      IN	R24,0x39
    039E 6081      ORI	R24,1
    039F BF89      OUT	0x39,R24
(0022)     return;
    03A0 9508      RET
(0023) }
(0024) //cpu timer0 stop
(0025) static void t0_stop(void)
(0026) {
(0027)     TIMSK &= 0xfe;
_t0_stop:
    03A1 B789      IN	R24,0x39
    03A2 7F8E      ANDI	R24,0xFE
    03A3 BF89      OUT	0x39,R24
(0028)     return;
    03A4 9508      RET
_set_timer:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    03A5 D2BE      RCALL	push_gset2
    03A6 01B9      MOVW	R22,R18
    03A7 2F40      MOV	R20,R16
(0029) }
(0030) //
(0031) static timer_t g_timer[MAXTIMER];
(0032) //set timer and start timer. set value 0, need wait a cpu timer pice.
(0033) void set_timer(char timer, int value, timerCB cb)
(0034) {
(0035)     //value=0, stoped timer.
(0036)     g_timer[timer].value = value+1;
    03A8 E084      LDI	R24,4
    03A9 9F84      MUL	R24,R20
    03AA 940E07C9  CALL	0x7C9
    03AC 01CB      MOVW	R24,R22
    03AD 9601      ADIW	R24,1
    03AE 8391      STD	Z+1,R25
    03AF 8380      STD	Z+0,R24
(0037)     g_timer[timer].cb = cb;
    03B0 E084      LDI	R24,4
    03B1 9F84      MUL	R24,R20
    03B2 940E081D  CALL	0x81D
    03B4 800C      LDD	R0,Y+4
    03B5 801D      LDD	R1,Y+5
    03B6 8211      STD	Z+1,R1
    03B7 8200      STD	Z+0,R0
(0038)     if(g_timer[timer].value)
    03B8 E084      LDI	R24,4
    03B9 9F84      MUL	R24,R20
    03BA 940E07C9  CALL	0x7C9
    03BC 8020      LDD	R2,Z+0
    03BD 8031      LDD	R3,Z+1
    03BE 2022      TST	R2
    03BF F411      BNE	0x03C2
    03C0 2033      TST	R3
    03C1 F009      BEQ	0x03C3
(0039)         t0_start();
    03C2 DFDA      RCALL	_t0_start
(0040)     return;
    03C3 D294      RCALL	pop_gset2
    03C4 9508      RET
(0041) }
(0042) //stop timer and clean timer.
(0043) void stop_timer(char timer)
(0044) {
(0045)     if(g_timer[timer].value)
_stop_timer:
  timer                --> R16
    03C5 E084      LDI	R24,4
    03C6 9F80      MUL	R24,R16
    03C7 940E07C9  CALL	0x7C9
    03C9 8020      LDD	R2,Z+0
    03CA 8031      LDD	R3,Z+1
    03CB 2022      TST	R2
    03CC F411      BNE	0x03CF
    03CD 2033      TST	R3
    03CE F059      BEQ	0x03DA
(0046)     {
(0047)         //stop this timer.
(0048)         g_timer[timer].value = 0;
    03CF E084      LDI	R24,4
    03D0 9F80      MUL	R24,R16
    03D1 940E07C9  CALL	0x7C9
    03D3 940E0879  CALL	0x879
(0049)         g_timer[timer].cb = 0;
    03D5 9F80      MUL	R24,R16
    03D6 940E081D  CALL	0x81D
    03D8 8231      STD	Z+1,R3
    03D9 8220      STD	Z+0,R2
(0050)     }
(0051)     return;
    03DA 9508      RET
_timer0_isr:
  running_timer_count  --> R20
  i                    --> R22
    03DB D2CF      RCALL	push_lset
    03DC D287      RCALL	push_gset2
(0052) }
(0053) //timer spank.
(0054) #pragma interrupt_handler timer0_isr:10
(0055) void timer0_isr(void)
(0056) {
(0057)     static char time_pices = 0;
(0058)     ++time_pices;
    03DD 91800072  LDS	R24,time_pices
    03DF 5F8F      SUBI	R24,0xFF
    03E0 93800072  STS	time_pices,R24
(0059)     //200ms.
(0060)     if(time_pices == 2)
    03E2 3082      CPI	R24,2
    03E3 F009      BEQ	0x03E5
    03E4 C04E      RJMP	0x0433
(0061)     {
(0062)         char running_timer_count = 0;
    03E5 2744      CLR	R20
(0063)         char i;
(0064)         for(i=0;i<MAXTIMER;i++)
    03E6 2766      CLR	R22
    03E7 C042      RJMP	0x042A
(0065)         {
(0066)             if(g_timer[i].value>1)
    03E8 E084      LDI	R24,4
    03E9 9F86      MUL	R24,R22
    03EA 940E07C9  CALL	0x7C9
    03EC 8020      LDD	R2,Z+0
    03ED 8031      LDD	R3,Z+1
    03EE E081      LDI	R24,1
    03EF E090      LDI	R25,0
    03F0 1582      CP	R24,R2
    03F1 0593      CPC	R25,R3
    03F2 F478      BCC	0x0402
(0067)             {
(0068)                 --g_timer[i].value;
    03F3 E084      LDI	R24,4
    03F4 9F86      MUL	R24,R22
    03F5 0110      MOVW	R2,R0
    03F6 E783      LDI	R24,0x73
    03F7 E090      LDI	R25,0
    03F8 0E28      ADD	R2,R24
    03F9 1E39      ADC	R3,R25
    03FA 01F1      MOVW	R30,R2
    03FB 8180      LDD	R24,Z+0
    03FC 8191      LDD	R25,Z+1
    03FD 9701      SBIW	R24,1
    03FE 8391      STD	Z+1,R25
    03FF 8380      STD	Z+0,R24
(0069)                 ++running_timer_count;
    0400 9543      INC	R20
(0070)             }
    0401 C027      RJMP	0x0429
(0071)             //timer call back.
(0072)             else if(g_timer[i].value==1)
    0402 E084      LDI	R24,4
    0403 9F86      MUL	R24,R22
    0404 940E07C9  CALL	0x7C9
    0406 8180      LDD	R24,Z+0
    0407 8191      LDD	R25,Z+1
    0408 3081      CPI	R24,1
    0409 E0E0      LDI	R30,0
    040A 079E      CPC	R25,R30
    040B F4E9      BNE	0x0429
(0073)             {
(0074)                 g_timer[i].value = 0;
    040C E084      LDI	R24,4
    040D 9F86      MUL	R24,R22
    040E 940E07C9  CALL	0x7C9
    0410 940E0879  CALL	0x879
(0075)                 if(g_timer[i].cb)
    0412 9F86      MUL	R24,R22
    0413 01F0      MOVW	R30,R0
    0414 E785      LDI	R24,0x75
    0415 E090      LDI	R25,0
    0416 0FE8      ADD	R30,R24
    0417 1FF9      ADC	R31,R25
    0418 8020      LDD	R2,Z+0
    0419 8031      LDD	R3,Z+1
    041A 2022      TST	R2
    041B F411      BNE	0x041E
    041C 2033      TST	R3
    041D F059      BEQ	0x0429
(0076)                 {
(0077)                     //disable cpu timer.
(0078)                     t0_stop();
    041E DF82      RCALL	_t0_stop
(0079)                     (g_timer[i].cb)(i);
    041F 2F06      MOV	R16,R22
    0420 E084      LDI	R24,4
    0421 9F86      MUL	R24,R22
    0422 940E081D  CALL	0x81D
    0424 81A0      LDD	R26,Z+0
    0425 81B1      LDD	R27,Z+1
    0426 01FD      MOVW	R30,R26
    0427 D255      RCALL	xicall
(0080)                     //enable cpu timer.
(0081)                     t0_start();
    0428 DF74      RCALL	_t0_start
    0429 9563      INC	R22
    042A 3064      CPI	R22,4
    042B F408      BCC	0x042D
    042C CFBB      RJMP	0x03E8
(0082)                 }
(0083)             }
(0084)         }
(0085)         time_pices = 0;
    042D 2422      CLR	R2
    042E 92200072  STS	time_pices,R2
(0086)         //if no timer running, stop cpu timer.
(0087)         if(!running_timer_count) t0_stop();
    0430 2344      TST	R20
    0431 F409      BNE	0x0433
    0432 DF6E      RCALL	_t0_stop
(0088)     }
(0089)     return;
    0433 D224      RCALL	pop_gset2
    0434 D289      RCALL	pop_lset
    0435 9518      RETI
FILE: D:\smarthome\smarthome\门禁系统资料\code\log.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "log.h"
(0004) 
(0005) void log(char type, unsigned char index, unsigned long id_code, unsigned long pswdH, unsigned long pswdL)
(0006) {
_log:
  pswdL                --> Y+12
  pswdH                --> Y+8
  id_code              --> Y+4
  index                --> Y+2
  type                 --> Y+0
    0436 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\locker.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "timer.h"
(0004) #include "util.h"
(0005) #include "locker.h"
(0006) 
(0007) #define LOCKERINIT (PORTB&=0xe7)
(0008) #define LOCKERUNLOCK (PORTB&=0xf7,PORTB|=0x10)
(0009) #define LOCKERLOCK (PORTB&=0xef,PORTB|=0x08)
(0010) 
(0011) void locker_init(void)
(0012) {
(0013)     //pb3 pb4 OUTPUT.
(0014)     DDRB |= 0x18;
_locker_init:
    0437 B387      IN	R24,0x17
    0438 6188      ORI	R24,0x18
    0439 BB87      OUT	0x17,R24
(0015)     //output low
(0016)     PORTB &= 0xe7;
    043A B388      IN	R24,0x18
    043B 7E87      ANDI	R24,0xE7
    043C BB88      OUT	0x18,R24
(0017)     return;
    043D 9508      RET
_unlock_time_out:
  timer                --> R20
    043E D227      RCALL	push_gset1
    043F 2F40      MOV	R20,R16
(0018) }
(0019) 
(0020) //unlock timeout.
(0021) static void unlock_time_out(char timer)
(0022) {
(0023)     if(timer==UNLOCKTIMEOUTTIMER)
    0440 3042      CPI	R20,2
    0441 F451      BNE	0x044C
(0024)     {
(0025) 		LOCKERLOCK;
    0442 B388      IN	R24,0x18
    0443 7E8F      ANDI	R24,0xEF
    0444 BB88      OUT	0x18,R24
    0445 9AC3      SBI	0x18,3
(0026) 		delay_ms(800);
    0446 E200      LDI	R16,0x20
    0447 E013      LDI	R17,3
    0448 DD21      RCALL	_delay_ms
(0027) 		LOCKERINIT;
    0449 B388      IN	R24,0x18
    044A 7E87      ANDI	R24,0xE7
    044B BB88      OUT	0x18,R24
(0028) 	}
(0029)     return;
    044C D21C      RCALL	pop_gset1
    044D 9508      RET
_locker_unlock:
    044E 9722      SBIW	R28,2
(0030) }
(0031) 
(0032) void locker_unlock(void)
(0033) {
(0034) 	LOCKERUNLOCK;
    044F B388      IN	R24,0x18
    0450 7F87      ANDI	R24,0xF7
    0451 BB88      OUT	0x18,R24
    0452 9AC4      SBI	0x18,4
(0035)     delay_ms(800);
    0453 E200      LDI	R16,0x20
    0454 E013      LDI	R17,3
    0455 DD14      RCALL	_delay_ms
(0036) 	LOCKERINIT;
    0456 B388      IN	R24,0x18
    0457 7E87      ANDI	R24,0xE7
    0458 BB88      OUT	0x18,R24
(0037) 	//set time out. 
(0038) 	set_timer(UNLOCKTIMEOUTTIMER, 100, unlock_time_out);
    0459 E58A      LDI	R24,0x5A
    045A E090      LDI	R25,0
    045B 8399      STD	Y+1,R25
    045C 8388      STD	Y+0,R24
    045D E624      LDI	R18,0x64
    045E E030      LDI	R19,0
    045F E002      LDI	R16,2
    0460 DF44      RCALL	_set_timer
(0039) 	return;
    0461 9622      ADIW	R28,2
    0462 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\ringandscreen.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "timer.h"
(0007) #include "ringandscreen.h"
(0008) 
(0009) //door monitor input is pa0.
(0010) //screen power output pb7.
(0011) 
(0012) #define SCREEN_ON (PORTB &= 0x7f)
(0013) #define SCREEN_OFF (PORTB |= 0x80)
(0014) 
(0015) void doorandscreen_init(void)
(0016) {
(0017)     //PA0 INPUT.
(0018)     DDRA &= 0xfe;
_doorandscreen_init:
    0463 B38A      IN	R24,0x1A
    0464 7F8E      ANDI	R24,0xFE
    0465 BB8A      OUT	0x1A,R24
(0019) 	PORTA |= 0x01;
    0466 9AD8      SBI	0x1B,0
(0020)     //pb7 hi-z
(0021)     DDRB &= 0x7f;
    0467 B387      IN	R24,0x17
    0468 778F      ANDI	R24,0x7F
    0469 BB87      OUT	0x17,R24
(0022)     PORTB &= 0x7f;
    046A B388      IN	R24,0x18
    046B 778F      ANDI	R24,0x7F
    046C BB88      OUT	0x18,R24
(0023)     //init interrput.
(0024)     return;
    046D 9508      RET
(0025) }
(0026) 
(0027) /**
(0028) #define SCREEN_RESET_START (PORTC&=0xef)
(0029) #define SCREEN_RESET_STOP (PORTC|=0x10)
(0030) #define RING_ON (PORTC&=0xdf)
(0031) #define RING_OFF (PORTC&=0x20)
(0032) 
(0033) void ringandscreen_init(void)
(0034) {
(0035)     //PC0,PC1,PC2 INPUT.
(0036)     DDRC &= 0xf8;
(0037)     //PC3,PC4,PC5 OUTPUT.
(0038)     DDRC |= 0x38;
(0039)     //
(0040)     PORTC = 0xff;
(0041)     //init interrput.
(0042)     return;
(0043) }
(0044) 
(0045) static void disable_input(void)
(0046) {
(0047) 
(0048) }
(0049) 
(0050) static void enable_input(void)
(0051) {
(0052) 
(0053) }
(0054) 
(0055) void screen_on(void)
(0056) {
(0057)     if((PORTC&=0x04))
(0058)     {
(0059)         SCREEN_ON;
(0060)         delay_ms(500);
(0061)         SCREEN_RESET_START;
(0062)         delay_ms(100);
(0063)         SCREEN_RESET_STOP;
(0064)     }
(0065)     return;
(0066) }
(0067) 
(0068) void screen_off(void)
(0069) {
(0070)     SCREEN_OFF;
(0071)     return;
(0072) }
(0073) 
(0074) void ring_on(void)
(0075) {
(0076)     RING_ON;
(0077)     delay_ms(20);
(0078)     RING_OFF;
(0079)     return;
(0080) }
(0081) 
(0082) void ring_screen_timeout(char timer)
(0083) {
(0084)     if(timer==RINGANDSCREENINPUTTIMER)
(0085)     {
(0086)         screen_off();
(0087)     }
(0088) }
(0089) 
(0090) void door_minitor_timeout(char timer)
(0091) {
(0092)     if(timer==RINGANDSCREENINPUTTIMER)
(0093)     {
(0094)         tips_err();
(0095)         //start timer. 10s.
(0096)         set_timer(RINGANDSCREENINPUTTIMER, 140, door_minitor_timeout); 
(0097)     }
(0098) }
(0099) 
(0100) void input_isr(void)
(0101) {
(0102)     disable_input();
(0103)     //
(0104)     delay_ms(100);
(0105)     if(!(PINC&0x01)) //ring input.
(0106)     {
(0107)         screen_on();
(0108)         ring_on();
(0109)         tips_ring_on();
(0110)         //start timer. 50s.
(0111)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0112)     }
(0113)     else if(!(PIND&0x02)) //screen key input.
(0114)     {
(0115)         screen_on();
(0116)         delay_ms(800);
(0117)         //start timer. 50s.
(0118)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0119)     }
(0120)     enable_input();
(0121)     return;
(0122) }
(0123) **/
(0124) 
(0125) void screen_on(void)
(0126) {
(0127)     //pb7 OUTPUT.
(0128)     DDRB |= 0x80;
_screen_on:
    046E 9ABF      SBI	0x17,7
(0129)     
(0130)     SCREEN_ON;
    046F B388      IN	R24,0x18
    0470 778F      ANDI	R24,0x7F
    0471 BB88      OUT	0x18,R24
(0131) 	delay_ms(25);
    0472 E109      LDI	R16,0x19
    0473 E010      LDI	R17,0
    0474 DCF5      RCALL	_delay_ms
(0132) 	SCREEN_OFF;
    0475 9AC7      SBI	0x18,7
(0133) 
(0134)     //pb7 hi-z
(0135)     DDRB &= 0x7f;
    0476 B387      IN	R24,0x17
    0477 778F      ANDI	R24,0x7F
    0478 BB87      OUT	0x17,R24
(0136)     PORTB &= 0x7f;
    0479 B388      IN	R24,0x18
    047A 778F      ANDI	R24,0x7F
    047B BB88      OUT	0x18,R24
(0137)     return;
    047C 9508      RET
(0138) }
(0139) 
(0140) //when door open, return 1.
(0141) char check_door(void)
(0142) {
(0143)     return 0;//(PINA&0x01);
_check_door:
    047D 2700      CLR	R16
    047E 9508      RET
_rw24c256:
  rwFlag               --> Y+11
  addr                 --> Y+9
  len                  --> R22
  data                 --> R20
    047F D1E4      RCALL	push_gset2
    0480 2F62      MOV	R22,R18
    0481 01A8      MOVW	R20,R16
    0482 9725      SBIW	R28,5
FILE: D:\smarthome\smarthome\门禁系统资料\code\eeprom.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "iic.h"
(0006) #include "eeprom.h"
(0007) 
(0008) /* 一个通用的24C01－24C256共9种EEPROM的字节读写操作程序，   
(0009) 此程序有五个入口条件，分别为读写数据缓冲区指针,   
(0010) 进行读写的字节数，EEPROM首址，EEPROM控制字节，   
(0011) 以及EEPROM类型。此程序结构性良好，具有极好的容错性，程序机器码也不多:   
(0012) DataBuff为读写数据输入／输出缓冲区的首址   
(0013) Length 为要读写数据的字节数量   
(0014) Addr 为EEPROM的片内地址 AT24256为0～32767   
(0015) Control 为EEPROM的控制字节，具体形式为(1)(0)(1)(0)(A2)(A1)(A0)(R/W),其中R/W=1,   
(0016) 表示读操作,R/W=0为写操作,A2,A1,A0为EEPROM的页选或片选地址;   
(0017) enumer为枚举变量,需为AT2401至AT24256中的一种,分别对应AT24C01至AT24C256;   
(0018) 函数返回值为一个位变量，若返回1表示此次操作失效，0表示操作成功;   
(0019) ERROR为允许最大次数，若出现ERRORCOUNT次操作失效后，则函数中止操作，并返回1   
(0020) SDA和SCL由用户自定义，这里暂定义为P3^0和P3^1; */   
(0021) /*对于1K位，2K位，4K位，8K位，16K位芯片采用一个8位长的字节地址码，对于32K位以上   
(0022) 的采用2个8位长的字节地址码直接寻址，而4K位，8K位，16K位配合页面地址来寻址*/   
(0023)    
(0024) /* －－－－－  AT24C01～AT24C256 的读写程序 －－－－－－ */
(0025) 
(0026) #define AT24C256DEVADDR 0xa0
(0027) 
(0028) char rw24c256(unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)
(0029) {
(0030)     return rwiic(AT24C256DEVADDR, data, len, addr, rwFlag);
    0483 840B      LDD	R0,Y+11
    0484 820C      STD	Y+4,R0
    0485 8409      LDD	R0,Y+9
    0486 841A      LDD	R1,Y+10
    0487 821B      STD	Y+3,R1
    0488 820A      STD	Y+2,R0
    0489 8368      STD	Y+0,R22
    048A 019A      MOVW	R18,R20
    048B EA00      LDI	R16,0xA0
    048C D0AA      RCALL	_rwiic
    048D 9625      ADIW	R28,5
    048E D1C9      RCALL	pop_gset2
    048F 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\uart.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "uart.h"
(0005) 
(0006) //uart0 init. for printf.
(0007) void uart0_init(void)
(0008) {
(0009)     UCSRB = 0x00;                //禁止UART发送和接收
_uart0_init:
    0490 2422      CLR	R2
    0491 B82A      OUT	0x0A,R2
(0010)     UCSRA = 0x02;               //倍速
    0492 E082      LDI	R24,2
    0493 B98B      OUT	0x0B,R24
(0011)     UCSRC = 0x06;                //8位数据
    0494 E086      LDI	R24,6
    0495 BD80      OUT	0x20,R24
(0012)     UBRRL = 0x67;                 //9600bps
    0496 E687      LDI	R24,0x67
    0497 B989      OUT	0x09,R24
(0013)     UBRRH = 0x00;
    0498 BC20      OUT	0x20,R2
(0014)     UCSRB = 0x18;
    0499 E188      LDI	R24,0x18
    049A B98A      OUT	0x0A,R24
    049B 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\iic.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "iic.h"
(0005) 
(0006) #define SET_SCL (PORTC|=0x80)
(0007) #define CLR_SCL (PORTC&=0x7f)
(0008) #define SET_SDA (PORTC|=0x40)
(0009) #define CLR_SDA (PORTC&=0xbf)
(0010) #define TEST_SDA ((PINC&0x40)?1:0)
(0011) #define SDA_OUT (DDRC|=0x40)
(0012) #define SDA_IN (DDRC&=0xbf,PORTC|=0x40)
(0013) 
(0014) //pc7 scl
(0015) //pc6 sda
(0016) void iicport_init(void)
(0017) {
(0018)     //hi-z
(0019)     DDRC &= 0x3f;
_iicport_init:
    049C B384      IN	R24,0x14
    049D 738F      ANDI	R24,0x3F
    049E BB84      OUT	0x14,R24
(0020)     PORTC &= 0x3f;
    049F B385      IN	R24,0x15
    04A0 738F      ANDI	R24,0x3F
    04A1 BB85      OUT	0x15,R24
(0021)     return;
    04A2 9508      RET
(0022) }
(0023) 
(0024) /* * * * * 以下是对IIC总线的操作子程序 * * * * */   
(0025) /* * * * * * 启动总线 * * * * */   
(0026) void start(void)    
(0027) {
(0028)     //pc6 and pc7 output mode.
(0029)     DDRC |= 0xc0;
_start:
    04A3 B384      IN	R24,0x14
    04A4 6C80      ORI	R24,0xC0
    04A5 BB84      OUT	0x14,R24
(0030)     PORTC |= 0xc0;
    04A6 B385      IN	R24,0x15
    04A7 6C80      ORI	R24,0xC0
    04A8 BB85      OUT	0x15,R24
(0031)     NOP();
    04A9 0000      NOP
(0032)     //SCL=0; /* SCL处于高电平时,SDA从高电平转向低电平表示 */   
(0033)     //CLR_SCL;
(0034)     //SDA=1; /* 一个"开始"状态,该状态必须在其他命令之前执行 */   
(0035)     SET_SDA;
    04AA 9AAE      SBI	0x15,6
(0036)     NOP();
    04AB 0000      NOP
    04AC 940E082E  CALL	0x82E
(0037)     //SCL=1;
(0038)     SET_SCL;
(0039)     NOP(); NOP(); NOP();    
(0040)     //SDA=0;
(0041)     CLR_SDA;
    04AE B385      IN	R24,0x15
    04AF 7B8F      ANDI	R24,0xBF
    04B0 BB85      OUT	0x15,R24
    04B1 940E07FF  CALL	0x7FF
(0042)     NOP(); NOP(); NOP(); NOP();    
(0043)     //SCL=0;
(0044)     CLR_SCL;
(0045)     //SDA=1;
(0046)     //SET_SDA;
(0047) 
(0048)     return;
    04B3 9508      RET
(0049) }    
(0050)    
(0051) /* * * * * 停止IIC总线 * * * * */   
(0052) void stop(void)    
(0053) {     
(0054)     //SCL=0; /*SCL处于高电平时,SDA从低电平转向高电平 */
(0055)     //CLR_SCL;   
(0056)     //SDA=0; /*表示一个"停止"状态,该状态终止所有通讯 */
(0057)     CLR_SDA;
_stop:
    04B4 B385      IN	R24,0x15
    04B5 7B8F      ANDI	R24,0xBF
    04B6 BB85      OUT	0x15,R24
(0058)     NOP();
    04B7 0000      NOP
    04B8 940E082E  CALL	0x82E
(0059)     //SCL=1;
(0060)     SET_SCL;
(0061)     NOP(); NOP(); NOP(); /* 空操作 */
(0062)     //SDA=1;
(0063)     SET_SDA;
    04BA 9AAE      SBI	0x15,6
(0064)     NOP(); NOP(); NOP();
    04BB 0000      NOP
    04BC 0000      NOP
    04BD 0000      NOP
(0065)     //SCL=0;
(0066)     //CLR_SCL;
(0067) 
(0068)     //hi-z
(0069)     DDRC &= 0x3f;
    04BE B384      IN	R24,0x14
    04BF 738F      ANDI	R24,0x3F
    04C0 BB84      OUT	0x14,R24
(0070)     PORTC &= 0x3f;
    04C1 B385      IN	R24,0x15
    04C2 738F      ANDI	R24,0x3F
    04C3 BB85      OUT	0x15,R24
(0071)     return;
    04C4 9508      RET
(0072) }    
(0073)    
(0074) /* * * * * 检查应答位 * * * * */   
(0075) unsigned char recAck(void)    
(0076) {
(0077)     unsigned char result;
(0078)      unsigned char i=0;
_recAck:
  result               --> R16
  i                    --> R16
    04C5 2700      CLR	R16
    04C6 940E087F  CALL	0x87F
    04C8 940E082E  CALL	0x82E
(0079)     
(0080)     //SCL=0;
(0081)     //CLR_SCL;   
(0082)     //SDA=1;
(0083)     SET_SDA;
(0084)     SDA_IN;
(0085)     //SCL=1;
(0086)     SET_SCL;
(0087)     //change sda input mode.
(0088)     NOP(); NOP(); NOP(); NOP();
    04CA 0000      NOP
    04CB C001      RJMP	0x04CD
(0089)     //CY=SDA;     /* 因为返回值总是放在CY中的 */
(0090)     while(TEST_SDA&&(i>250)) i++;
    04CC 9503      INC	R16
    04CD 9B9E      SBIS	0x13,6
    04CE C003      RJMP	0x04D2
    04CF E021      LDI	R18,1
    04D0 E030      LDI	R19,0
    04D1 C002      RJMP	0x04D4
    04D2 2722      CLR	R18
    04D3 2733      CLR	R19
    04D4 3020      CPI	R18,0
    04D5 0723      CPC	R18,R19
    04D6 F019      BEQ	0x04DA
    04D7 EF8A      LDI	R24,0xFA
    04D8 1780      CP	R24,R16
    04D9 F390      BCS	0x04CC
(0091)     result = TEST_SDA;
    04DA 9B9E      SBIS	0x13,6
    04DB C003      RJMP	0x04DF
    04DC E001      LDI	R16,1
    04DD E010      LDI	R17,0
    04DE C002      RJMP	0x04E1
    04DF 2700      CLR	R16
    04E0 2711      CLR	R17
(0092)     //SCL=0;
(0093)     CLR_SCL;
    04E1 B385      IN	R24,0x15
    04E2 778F      ANDI	R24,0x7F
    04E3 BB85      OUT	0x15,R24
(0094)     //SDA_OUT;
(0095)     SDA_OUT;
    04E4 9AA6      SBI	0x14,6
(0096)     return result;
    04E5 9508      RET
(0097) }    
(0098)    
(0099) /* * * * *对IIC总线产生应答 * * * * */   
(0100) void ack(void)    
(0101) {     
(0102)     //SDA=0; /* EEPROM通过在收到每个地址或数据之后, */
(0103)     CLR_SDA;
_ack:
    04E6 B385      IN	R24,0x15
    04E7 7B8F      ANDI	R24,0xBF
    04E8 BB85      OUT	0x15,R24
(0104)     //SCL=1; /* 置SDA低电平的方式确认表示收到读SDA口状态 */
(0105)     SET_SCL;
    04E9 9AAF      SBI	0x15,7
    04EA 940E07FF  CALL	0x7FF
(0106)     NOP(); NOP(); NOP(); NOP();
(0107)     //SCL=0;
(0108)     CLR_SCL;   
(0109)     NOP();
    04EC 0000      NOP
(0110)     //SDA=1;
(0111)     SET_SDA;
    04ED 9AAE      SBI	0x15,6
(0112) 
(0113)     return;
    04EE 9508      RET
(0114) }    
(0115)    
(0116) /* * * * * * * * * 不对IIC总线产生应答 * * * * */   
(0117) void noAck(void)    
(0118) {    
(0119)     //SDA=1;
(0120)     SET_SDA;
_noAck:
    04EF 9AAE      SBI	0x15,6
(0121)     //SCL=1;
(0122)     SET_SCL;
    04F0 9AAF      SBI	0x15,7
    04F1 940E07FF  CALL	0x7FF
(0123)     NOP(); NOP(); NOP(); NOP();    
(0124)     //SCL=0;
(0125)     CLR_SCL;
(0126)     
(0127)     return;
    04F3 9508      RET
_sendByte:
  mask                 --> R20
  byte                 --> R16
    04F4 D171      RCALL	push_gset1
(0128) }    
(0129)    
(0130) /* * * * * * * * * 向IIC总线写数据 * * * * */   
(0131) void sendByte(unsigned char byte)    
(0132) {
(0133)     unsigned char mask = 0x80;
    04F5 E840      LDI	R20,0x80
(0134)     for(;mask>0;)    
    04F6 C011      RJMP	0x0508
(0135)     {
(0136)         //SCL=0;
(0137)         CLR_SCL;
    04F7 940E0863  CALL	0x863
(0138)         NOP();NOP();
    04F9 0000      NOP
(0139)         if(mask&byte)
    04FA 2E24      MOV	R2,R20
    04FB 2220      AND	R2,R16
    04FC F011      BEQ	0x04FF
(0140)         {
(0141)             //SDA=1;
(0142)             SET_SDA;
    04FD 9AAE      SBI	0x15,6
(0143)         }
    04FE C003      RJMP	0x0502
(0144)         else
(0145)         {
(0146)             //SDA=0;
(0147)             CLR_SDA;
    04FF B385      IN	R24,0x15
    0500 7B8F      ANDI	R24,0xBF
    0501 BB85      OUT	0x15,R24
(0148)         }
(0149)         mask >>= 1;
    0502 9546      LSR	R20
(0150)         NOP();NOP();
    0503 0000      NOP
    0504 0000      NOP
(0151)         //SCL=1;
(0152)         SET_SCL;
    0505 9AAF      SBI	0x15,7
(0153)         NOP();NOP();
    0506 0000      NOP
    0507 0000      NOP
    0508 2422      CLR	R2
    0509 1624      CP	R2,R20
    050A F360      BCS	0x04F7
(0154)     }
(0155)     //SCL=0;
(0156)     CLR_SCL;
    050B B385      IN	R24,0x15
    050C 778F      ANDI	R24,0x7F
    050D BB85      OUT	0x15,R24
(0157) 
(0158)     return;
    050E D15A      RCALL	pop_gset1
    050F 9508      RET
_receiveByte:
  i                    --> R16
  receivebyte          --> R18
    0510 D155      RCALL	push_gset1
(0159) }
(0160)    
(0161) /* * * * * * * * * 从IIC总线上读数据子程序 * * * * */   
(0162) unsigned char receiveByte(void)    
(0163) {     
(0164)     unsigned char receivebyte = 0, i=8;     
    0511 2722      CLR	R18
    0512 E008      LDI	R16,0x8
(0165)     //SCL=0;
(0166)     CLR_SCL;
    0513 B385      IN	R24,0x15
    0514 778F      ANDI	R24,0x7F
    0515 BB85      OUT	0x15,R24
    0516 940E087F  CALL	0x87F
(0167)     //SDA = 1;
(0168)     SET_SDA;
(0169)     SDA_IN;
(0170)     NOP();NOP();
    0518 0000      NOP
    0519 0000      NOP
    051A C013      RJMP	0x052E
(0171)     while(i--)    
(0172)     {     
(0173)         //SCL=1;
(0174)         SET_SCL;
    051B 9AAF      SBI	0x15,7
(0175)         NOP();NOP();
    051C 0000      NOP
    051D 0000      NOP
(0176)         receivebyte = (receivebyte <<1 ) | TEST_SDA;
    051E 9B9E      SBIS	0x13,6
    051F C003      RJMP	0x0523
    0520 E041      LDI	R20,1
    0521 E050      LDI	R21,0
    0522 C002      RJMP	0x0525
    0523 2744      CLR	R20
    0524 2755      CLR	R21
    0525 2E22      MOV	R2,R18
    0526 2433      CLR	R3
    0527 0C22      LSL	R2
    0528 1C33      ROL	R3
    0529 2A24      OR	R2,R20
    052A 2A35      OR	R3,R21
    052B 2D22      MOV	R18,R2
    052C 940E0863  CALL	0x863
    052E 2E20      MOV	R2,R16
    052F 2433      CLR	R3
    0530 5001      SUBI	R16,1
    0531 2022      TST	R2
    0532 F741      BNE	0x051B
(0177)         //SCL=0;
(0178)         CLR_SCL;
(0179)         NOP();
(0180)     }
(0181)     SDA_OUT;
    0533 9AA6      SBI	0x14,6
(0182)     return receivebyte;    
    0534 2F02      MOV	R16,R18
    0535 D133      RCALL	pop_gset1
    0536 9508      RET
_rwiic:
  i                    --> R10
  err                  --> R20
  rwFlag               --> R22
  addr                 --> R12
  len                  --> R14
  data                 --> Y+12
  comAddr              --> Y+10
    0537 D0F1      RCALL	push_arg4
    0538 D125      RCALL	push_gset5
    0539 84EE      LDD	R14,Y+14
    053A 88C8      LDD	R12,Y+16
    053B 88D9      LDD	R13,Y+17
    053C 896A      LDD	R22,Y+18
(0183) }
(0184) 
(0185) 
(0186) #define MAXRETRY    10
(0187) 
(0188) char rwiic(unsigned char comAddr, unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)    
(0189) {
(0190)     unsigned char i = MAXRETRY;
    053D E08A      LDI	R24,0xA
    053E 2EA8      MOV	R10,R24
(0191)     char err = 1;  /*   出错标志   */   
    053F E041      LDI	R20,1
    0540 C048      RJMP	0x0589
(0192)     while(i--)    
(0193)     {    
(0194)         start();  /*   启动总线   */
    0541 DF61      RCALL	_start
(0195)         sendByte(comAddr |0x00); /*   向IIC总线写数据，器件地址 */   
    0542 850A      LDD	R16,Y+10
    0543 DFB0      RCALL	_sendByte
(0196)         if(recAck()) continue; /*   如写不正确结束本次循环   */   
    0544 DF80      RCALL	_recAck
    0545 2300      TST	R16
    0546 F009      BEQ	0x0548
    0547 C041      RJMP	0x0589
(0197)         sendByte((unsigned char)(addr >> 8));//把整型数据转换为字符型数据：弃高取低，只取低8位.如果容量大于32K位，使用16位地址寻址，写入高八位地址    
    0548 0186      MOVW	R16,R12
    0549 2F01      MOV	R16,R17
    054A 2711      CLR	R17
    054B DFA8      RCALL	_sendByte
(0198)         if(recAck())  continue;    
    054C DF78      RCALL	_recAck
    054D 2300      TST	R16
    054E F009      BEQ	0x0550
    054F C039      RJMP	0x0589
(0199)         sendByte((unsigned char)addr); /*   向IIC总线写数据   */   
    0550 2D0C      MOV	R16,R12
    0551 DFA2      RCALL	_sendByte
(0200)         if(recAck())  continue; /*   如写正确结束本次循环   */
    0552 DF72      RCALL	_recAck
    0553 2300      TST	R16
    0554 F009      BEQ	0x0556
    0555 C033      RJMP	0x0589
(0201)         if(rwFlag == RWWRITE)   //判断是读器件还是写器件    
    0556 2366      TST	R22
    0557 F4A1      BNE	0x056C
(0202)         {
(0203)             err=0;         /* 清错误特征位 */   
    0558 2744      CLR	R20
    0559 C00C      RJMP	0x0566
(0204)             while(len--)    
(0205)             {
(0206)                 sendByte(*(data++)); /*   向IIC总线写数据   */   
    055A 85EC      LDD	R30,Y+12
    055B 85FD      LDD	R31,Y+13
    055C 9101      LD	R16,Z+
    055D 87FD      STD	Y+13,R31
    055E 87EC      STD	Y+12,R30
    055F DF94      RCALL	_sendByte
(0207)                 if(!recAck()) continue; /*   如写正确结束本次循环   */   
    0560 DF64      RCALL	_recAck
    0561 2300      TST	R16
    0562 F409      BNE	0x0564
    0563 C002      RJMP	0x0566
(0208)                 err=1;    
    0564 E041      LDI	R20,1
(0209)                 break;    
    0565 C003      RJMP	0x0569
    0566 940E0872  CALL	0x872
    0568 F789      BNE	0x055A
(0210)             }    
(0211)             if(err==1) continue;    
    0569 3041      CPI	R20,1
    056A F531      BNE	0x0591
    056B C01D      RJMP	0x0589
(0212)             break;    
(0213)         }    
(0214)         else   
(0215)         { 
(0216)             start();  /*   启动总线   */   
    056C DF36      RCALL	_start
(0217)             sendByte(comAddr |0x01); /*   向IIC总线写数据   */   
    056D 850A      LDD	R16,Y+10
    056E 6001      ORI	R16,1
    056F DF84      RCALL	_sendByte
(0218)             if(recAck()) continue;//器件没应答结束本次本层循环    
    0570 DF54      RCALL	_recAck
    0571 2300      TST	R16
    0572 F009      BEQ	0x0574
    0573 C015      RJMP	0x0589
(0219)             //循环数量要减一。
(0220)             len--;
    0574 94EA      DEC	R14
    0575 C008      RJMP	0x057E
(0221)             while(len--)  /*   字节长为0结束   */   
(0222)             {
(0223)                 *(data++)= receiveByte();    
    0576 DF99      RCALL	_receiveByte
    0577 2E20      MOV	R2,R16
    0578 85EC      LDD	R30,Y+12
    0579 85FD      LDD	R31,Y+13
    057A 9221      ST	R2,Z+
    057B 87FD      STD	Y+13,R31
    057C 87EC      STD	Y+12,R30
(0224)                 ack();   /*   对IIC总线产生应答   */   
    057D DF68      RCALL	_ack
    057E 940E0872  CALL	0x872
    0580 F7A9      BNE	0x0576
(0225)             }    
(0226)             *data=receiveByte(); /* 读最后一个字节 */   
    0581 DF8E      RCALL	_receiveByte
    0582 2E20      MOV	R2,R16
    0583 85EC      LDD	R30,Y+12
    0584 85FD      LDD	R31,Y+13
    0585 8220      STD	Z+0,R2
(0227)             noAck();  /*   不对IIC总线产生应答   */   
    0586 DF68      RCALL	_noAck
(0228)             err=0;    
    0587 2744      CLR	R20
(0229)             break;    
    0588 C008      RJMP	0x0591
    0589 2C2A      MOV	R2,R10
    058A 2433      CLR	R3
    058B 2D82      MOV	R24,R2
    058C 5081      SUBI	R24,1
    058D 2EA8      MOV	R10,R24
    058E 2022      TST	R2
    058F F009      BEQ	0x0591
    0590 CFB0      RJMP	0x0541
(0230)         }    
(0231)     }    
(0232)     stop();  /*   停止IIC总线   */   
    0591 DF22      RCALL	_stop
(0233)     if(rwFlag == RWWRITE)    
    0592 2366      TST	R22
    0593 F419      BNE	0x0597
(0234)     {     
(0235)         delay_ms(50);    
    0594 E302      LDI	R16,0x32
    0595 E010      LDI	R17,0
    0596 DBD3      RCALL	_delay_ms
(0236)     }    
(0237)     return err;    
    0597 2F04      MOV	R16,R20
    0598 D0C3      RCALL	pop_gset5
    0599 9624      ADIW	R28,4
    059A 9508      RET
_rwiicInt:
  tmp                  --> Y+9
  out                  --> Y+5
  rwFlag               --> Y+25
  addr                 --> Y+23
  data                 --> Y+19
  comAddr              --> R10
    059B 933A      ST	R19,-Y
    059C 932A      ST	R18,-Y
    059D D0C4      RCALL	push_gset3
    059E 2EA0      MOV	R10,R16
    059F 972D      SBIW	R28,0xD
(0238) }    
(0239) 
(0240) unsigned long rwiicInt(unsigned char comAddr, unsigned long data, unsigned int addr, unsigned char rwFlag)
(0241) {
(0242)     unsigned char tmp[4] = {0, 0, 0, 0};
    05A0 E58C      LDI	R24,0x5C
    05A1 E090      LDI	R25,0
    05A2 01FE      MOVW	R30,R28
    05A3 9639      ADIW	R30,0x9
    05A4 E004      LDI	R16,4
    05A5 E010      LDI	R17,0
    05A6 93FA      ST	R31,-Y
    05A7 93EA      ST	R30,-Y
    05A8 939A      ST	R25,-Y
    05A9 938A      ST	R24,-Y
    05AA D142      RCALL	asgncblk
(0243) 	unsigned long out = 0;
    05AB E040      LDI	R20,0
    05AC 940E0766  CALL	0x766
    05AE 940E07EE  CALL	0x7EE
(0244) 
(0245)     if(rwFlag==RWWRITE)
    05B0 8C09      LDD	R0,Y+25
    05B1 2000      TST	R0
    05B2 F009      BEQ	0x05B4
    05B3 C03E      RJMP	0x05F2
(0246)     {
(0247)         tmp[0] = (unsigned char)(data&0x000000ff);
    05B4 EF4F      LDI	R20,0xFF
    05B5 940E0766  CALL	0x766
    05B7 940E0818  CALL	0x818
    05B9 940E07E9  CALL	0x7E9
    05BB 8629      STD	Y+9,R2
(0248)         tmp[1] = (unsigned char)((data>>8)&0x000000ff);
    05BC E088      LDI	R24,0x8
    05BD E090      LDI	R25,0
    05BE 940E07DE  CALL	0x7DE
    05C0 938A      ST	R24,-Y
    05C1 0181      MOVW	R16,R2
    05C2 0192      MOVW	R18,R4
    05C3 D11D      RCALL	lsr32
    05C4 0118      MOVW	R2,R16
    05C5 0129      MOVW	R4,R18
    05C6 940E083C  CALL	0x83C
    05C8 940E07E9  CALL	0x7E9
    05CA 862A      STD	Y+10,R2
(0249)         tmp[2] = (unsigned char)((data>>16)&0x000000ff);
    05CB EF4F      LDI	R20,0xFF
    05CC 940E0766  CALL	0x766
    05CE 940E0818  CALL	0x818
    05D0 0112      MOVW	R2,R4
    05D1 2444      CLR	R4
    05D2 2455      CLR	R5
    05D3 940E07E9  CALL	0x7E9
    05D5 862B      STD	Y+11,R2
(0250)         tmp[3] = (unsigned char)((data>>24)&0x000000ff);
    05D6 E188      LDI	R24,0x18
    05D7 E090      LDI	R25,0
    05D8 940E07DE  CALL	0x7DE
    05DA 938A      ST	R24,-Y
    05DB 0181      MOVW	R16,R2
    05DC 0192      MOVW	R18,R4
    05DD D103      RCALL	lsr32
    05DE 0118      MOVW	R2,R16
    05DF 0129      MOVW	R4,R18
    05E0 940E083C  CALL	0x83C
    05E2 940E07E9  CALL	0x7E9
    05E4 862C      STD	Y+12,R2
(0251)         rwiic(comAddr, (unsigned char*)&tmp, 4, addr, RWWRITE);
    05E5 2422      CLR	R2
    05E6 822C      STD	Y+4,R2
    05E7 940E080D  CALL	0x80D
    05E9 DF4D      RCALL	_rwiic
    05EA 940E07DE  CALL	0x7DE
(0252) 		out = data;
    05EC 01FE      MOVW	R30,R28
    05ED 8225      STD	Z+5,R2
    05EE 8236      STD	Z+6,R3
    05EF 8247      STD	Z+7,R4
    05F0 8650      STD	Z+8,R5
(0253)     }
    05F1 C02E      RJMP	0x0620
(0254)     else
(0255)     {
(0256)         rwiic(comAddr, (unsigned char*)&tmp, 4, addr, RWREAD);
    05F2 E081      LDI	R24,1
    05F3 838C      STD	Y+4,R24
    05F4 940E080D  CALL	0x80D
    05F6 DF40      RCALL	_rwiic
(0257) 
(0258)         out= 0;
    05F7 E040      LDI	R20,0
    05F8 940E0766  CALL	0x766
    05FA 940E07EE  CALL	0x7EE
(0259)         out |= tmp[0];
    05FC 8429      LDD	R2,Y+9
    05FD 940E071E  CALL	<created procedures>
(0260)         out <<= 8;
    05FF D0D5      RCALL	lsl32
    0600 940E084D  CALL	0x84D
(0261)         out |= tmp[1];
    0602 842A      LDD	R2,Y+10
    0603 940E071E  CALL	<created procedures>
(0262)         out <<= 8;
    0605 D0CF      RCALL	lsl32
    0606 940E084D  CALL	0x84D
(0263)         out |= tmp[2];
    0608 842B      LDD	R2,Y+11
    0609 940E071E  CALL	<created procedures>
(0264)         out <<= 8;
    060B D0C9      RCALL	lsl32
    060C 940E084D  CALL	0x84D
(0265)         out |= tmp[3];
    060E 842C      LDD	R2,Y+12
    060F 2433      CLR	R3
    0610 2444      CLR	R4
    0611 2455      CLR	R5
    0612 01FE      MOVW	R30,R28
    0613 8065      LDD	R6,Z+5
    0614 8076      LDD	R7,Z+6
    0615 8087      LDD	R8,Z+7
    0616 8490      LDD	R9,Z+8
    0617 2862      OR	R6,R2
    0618 2873      OR	R7,R3
    0619 2884      OR	R8,R4
    061A 2895      OR	R9,R5
    061B 01FE      MOVW	R30,R28
    061C 8265      STD	Z+5,R6
    061D 8276      STD	Z+6,R7
    061E 8287      STD	Z+7,R8
    061F 8690      STD	Z+8,R9
(0266)     }
(0267)     return out;
FILE: <library>
    0620 01FE      MOVW	R30,R28
    0621 8105      LDD	R16,Z+5
    0622 8116      LDD	R17,Z+6
    0623 8127      LDD	R18,Z+7
    0624 8530      LDD	R19,Z+8
    0625 962D      ADIW	R28,0xD
    0626 D033      RCALL	pop_gset3
    0627 9622      ADIW	R28,2
    0628 9508      RET
push_arg4:
    0629 940E08A5  CALL	0x8A5
push_arg2:
    062B 9508      RET
empy32s:
empy32u:
    062C D059      RCALL	long_prolog
    062D 927F      PUSH	R7
    062E D070      RCALL	tstzero1
    062F F131      BEQ	0x0656
    0630 2477      CLR	R7
    0631 D073      RCALL	tstzero2
    0632 F419      BNE	0x0636
    0633 018C      MOVW	R16,R24
    0634 019D      MOVW	R18,R26
    0635 C020      RJMP	0x0656
    0636 9F08      MUL	R16,R24
    0637 2CB0      MOV	R11,R0
    0638 2CA1      MOV	R10,R1
    0639 9F28      MUL	R18,R24
    063A 2C90      MOV	R9,R0
    063B 2C81      MOV	R8,R1
    063C 9F18      MUL	R17,R24
    063D 0CA0      ADD	R10,R0
    063E 1C91      ADC	R9,R1
    063F 1C87      ADC	R8,R7
    0640 9F09      MUL	R16,R25
    0641 0CA0      ADD	R10,R0
    0642 1C91      ADC	R9,R1
    0643 1C87      ADC	R8,R7
    0644 9F19      MUL	R17,R25
    0645 0C90      ADD	R9,R0
    0646 1C81      ADC	R8,R1
    0647 9F0A      MUL	R16,R26
    0648 0C90      ADD	R9,R0
    0649 1C81      ADC	R8,R1
    064A 9F38      MUL	R19,R24
    064B 0C80      ADD	R8,R0
    064C 9F29      MUL	R18,R25
    064D 0C80      ADD	R8,R0
    064E 9F1A      MUL	R17,R26
    064F 0C80      ADD	R8,R0
    0650 9F0B      MUL	R16,R27
    0651 0C80      ADD	R8,R0
    0652 2D0B      MOV	R16,R11
    0653 2D1A      MOV	R17,R10
    0654 2D29      MOV	R18,R9
    0655 2D38      MOV	R19,R8
    0656 907F      POP	R7
    0657 C03C      RJMP	long_epilog
pop_gset2:
    0658 E0E2      LDI	R30,2
    0659 C010      RJMP	pop
pop_gset3:
    065A E0E4      LDI	R30,4
    065B C00E      RJMP	pop
pop_gset5:
    065C 27EE      CLR	R30
    065D C00C      RJMP	pop
push_gset5:
    065E 92FA      ST	R15,-Y
    065F 92EA      ST	R14,-Y
push_gset4:
    0660 92DA      ST	R13,-Y
    0661 92CA      ST	R12,-Y
push_gset3:
    0662 92BA      ST	R11,-Y
    0663 92AA      ST	R10,-Y
push_gset2:
    0664 937A      ST	R23,-Y
    0665 936A      ST	R22,-Y
push_gset1:
    0666 935A      ST	R21,-Y
    0667 934A      ST	R20,-Y
    0668 9508      RET
pop_gset1:
    0669 E0E1      LDI	R30,1
pop:
    066A 9149      LD	R20,Y+
    066B 9159      LD	R21,Y+
    066C FDE0      SBRC	R30,0
    066D 9508      RET
    066E 9169      LD	R22,Y+
    066F 9179      LD	R23,Y+
    0670 FDE1      SBRC	R30,1
    0671 9508      RET
    0672 90A9      LD	R10,Y+
    0673 90B9      LD	R11,Y+
    0674 FDE2      SBRC	R30,2
    0675 9508      RET
    0676 90C9      LD	R12,Y+
    0677 90D9      LD	R13,Y+
    0678 FDE3      SBRC	R30,3
    0679 9508      RET
    067A 90E9      LD	R14,Y+
    067B 90F9      LD	R15,Y+
    067C 9508      RET
xicall:
    067D 920A      ST	R0,-Y
    067E 95C8      LPM
    067F 920A      ST	R0,-Y
    0680 9631      ADIW	R30,1
    0681 95C8      LPM
    0682 2DF0      MOV	R31,R0
    0683 91E9      LD	R30,Y+
    0684 9009      LD	R0,Y+
    0685 9409      IJMP
long_prolog:
    0686 928A      ST	R8,-Y
    0687 929A      ST	R9,-Y
    0688 92AA      ST	R10,-Y
    0689 92BA      ST	R11,-Y
    068A 93EA      ST	R30,-Y
    068B 938A      ST	R24,-Y
    068C 939A      ST	R25,-Y
    068D 93AA      ST	R26,-Y
    068E 93BA      ST	R27,-Y
    068F 8589      LDD	R24,Y+9
    0690 859A      LDD	R25,Y+10
    0691 85AB      LDD	R26,Y+11
    0692 85BC      LDD	R27,Y+12
    0693 9508      RET
long_epilog:
    0694 91B9      LD	R27,Y+
    0695 91A9      LD	R26,Y+
    0696 9199      LD	R25,Y+
    0697 9189      LD	R24,Y+
    0698 91E9      LD	R30,Y+
    0699 90B9      LD	R11,Y+
    069A 90A9      LD	R10,Y+
    069B 9099      LD	R9,Y+
    069C 9089      LD	R8,Y+
    069D 9624      ADIW	R28,4
    069E 9508      RET
tstzero1:
    069F 27EE      CLR	R30
    06A0 2BE0      OR	R30,R16
    06A1 2BE1      OR	R30,R17
    06A2 2BE2      OR	R30,R18
    06A3 2BE3      OR	R30,R19
    06A4 9508      RET
tstzero2:
    06A5 27EE      CLR	R30
    06A6 2BE8      OR	R30,R24
    06A7 2BE9      OR	R30,R25
    06A8 2BEA      OR	R30,R26
    06A9 2BEB      OR	R30,R27
    06AA 9508      RET
push_lset:
    06AB 93FA      ST	R31,-Y
    06AC 93EA      ST	R30,-Y
    06AD 93BA      ST	R27,-Y
    06AE 93AA      ST	R26,-Y
    06AF 939A      ST	R25,-Y
    06B0 938A      ST	R24,-Y
    06B1 940E08A5  CALL	0x8A5
    06B3 929A      ST	R9,-Y
    06B4 928A      ST	R8,-Y
    06B5 927A      ST	R7,-Y
    06B6 926A      ST	R6,-Y
    06B7 940E08AA  CALL	0x8AA
    06B9 921A      ST	R1,-Y
    06BA 920A      ST	R0,-Y
    06BB B60F      IN	R0,0x3F
    06BC 920A      ST	R0,-Y
    06BD 9508      RET
pop_lset:
    06BE 9009      LD	R0,Y+
    06BF BE0F      OUT	0x3F,R0
    06C0 9009      LD	R0,Y+
    06C1 9019      LD	R1,Y+
    06C2 9029      LD	R2,Y+
    06C3 9039      LD	R3,Y+
    06C4 9049      LD	R4,Y+
    06C5 9059      LD	R5,Y+
    06C6 9069      LD	R6,Y+
    06C7 9079      LD	R7,Y+
    06C8 9089      LD	R8,Y+
    06C9 9099      LD	R9,Y+
    06CA 9109      LD	R16,Y+
    06CB 9119      LD	R17,Y+
    06CC 9129      LD	R18,Y+
    06CD 9139      LD	R19,Y+
    06CE 9189      LD	R24,Y+
    06CF 9199      LD	R25,Y+
    06D0 91A9      LD	R26,Y+
    06D1 91B9      LD	R27,Y+
    06D2 91E9      LD	R30,Y+
    06D3 91F9      LD	R31,Y+
    06D4 9508      RET
lsl32:
    06D5 920F      PUSH	R0
    06D6 9009      LD	R0,Y+
    06D7 2000      TST	R0
    06D8 F031      BEQ	0x06DF
    06D9 0F00      LSL	R16
    06DA 1F11      ROL	R17
    06DB 1F22      ROL	R18
    06DC 1F33      ROL	R19
    06DD 940A      DEC	R0
    06DE CFF8      RJMP	0x06D7
    06DF 900F      POP	R0
    06E0 9508      RET
lsr32:
    06E1 920F      PUSH	R0
    06E2 9009      LD	R0,Y+
    06E3 2000      TST	R0
    06E4 F031      BEQ	0x06EB
    06E5 9536      LSR	R19
    06E6 9527      ROR	R18
    06E7 9517      ROR	R17
    06E8 9507      ROR	R16
    06E9 940A      DEC	R0
    06EA CFF8      RJMP	0x06E3
    06EB 900F      POP	R0
    06EC 9508      RET
asgncblk:
    06ED 93AA      ST	R26,-Y
    06EE 93BA      ST	R27,-Y
    06EF 93EA      ST	R30,-Y
    06F0 93FA      ST	R31,-Y
    06F1 920A      ST	R0,-Y
    06F2 81AF      LDD	R26,Y+7
    06F3 85B8      LDD	R27,Y+8
    06F4 81ED      LDD	R30,Y+5
    06F5 81FE      LDD	R31,Y+6
    06F6 3000      CPI	R16,0
    06F7 0701      CPC	R16,R17
    06F8 F031      BEQ	0x06FF
    06F9 95C8      LPM
    06FA 920D      ST	R0,X+
    06FB 9631      ADIW	R30,1
    06FC 5001      SUBI	R16,1
    06FD 4010      SBCI	R17,0
    06FE CFF7      RJMP	0x06F6
    06FF 9009      LD	R0,Y+
    0700 91F9      LD	R31,Y+
    0701 91E9      LD	R30,Y+
    0702 91B9      LD	R27,Y+
    0703 91A9      LD	R26,Y+
    0704 9624      ADIW	R28,4
    0705 9508      RET
asgnblk:
    0706 93AA      ST	R26,-Y
    0707 93BA      ST	R27,-Y
    0708 93EA      ST	R30,-Y
    0709 93FA      ST	R31,-Y
    070A 920A      ST	R0,-Y
    070B 81AF      LDD	R26,Y+7
    070C 85B8      LDD	R27,Y+8
    070D 81ED      LDD	R30,Y+5
    070E 81FE      LDD	R31,Y+6
    070F 3000      CPI	R16,0
    0710 0701      CPC	R16,R17
    0711 F029      BEQ	0x0717
    0712 9001      LD	R0,Z+
    0713 920D      ST	R0,X+
    0714 5001      SUBI	R16,1
    0715 4010      SBCI	R17,0
    0716 CFF8      RJMP	0x070F
    0717 9009      LD	R0,Y+
    0718 91F9      LD	R31,Y+
    0719 91E9      LD	R30,Y+
    071A 91B9      LD	R27,Y+
    071B 91A9      LD	R26,Y+
    071C 9624      ADIW	R28,4
    071D 9508      RET
<created procedures>:
    071E 2433      CLR	R3
    071F 2444      CLR	R4
    0720 2455      CLR	R5
    0721 01FE      MOVW	R30,R28
    0722 8065      LDD	R6,Z+5
    0723 8076      LDD	R7,Z+6
    0724 8087      LDD	R8,Z+7
    0725 8490      LDD	R9,Z+8
    0726 2862      OR	R6,R2
    0727 2873      OR	R7,R3
    0728 2884      OR	R8,R4
    0729 2895      OR	R9,R5
    072A 01FE      MOVW	R30,R28
    072B 8265      STD	Z+5,R6
    072C 8276      STD	Z+6,R7
    072D 8287      STD	Z+7,R8
    072E 8690      STD	Z+8,R9
    072F E088      LDI	R24,0x8
    0730 E090      LDI	R25,0
    0731 01FE      MOVW	R30,R28
    0732 8025      LDD	R2,Z+5
    0733 8036      LDD	R3,Z+6
    0734 8047      LDD	R4,Z+7
    0735 8450      LDD	R5,Z+8
    0736 938A      ST	R24,-Y
    0737 0181      MOVW	R16,R2
    0738 0192      MOVW	R18,R4
    0739 9508      RET
    073A E070      LDI	R23,0
    073B 01FE      MOVW	R30,R28
    073C 8341      STD	Z+1,R20
    073D 8352      STD	Z+2,R21
    073E 8363      STD	Z+3,R22
    073F 8374      STD	Z+4,R23
    0740 E041      LDI	R20,1
    0741 E050      LDI	R21,0
    0742 E060      LDI	R22,0
    0743 E070      LDI	R23,0
    0744 01FE      MOVW	R30,R28
    0745 8345      STD	Z+5,R20
    0746 8356      STD	Z+6,R21
    0747 8367      STD	Z+7,R22
    0748 8770      STD	Z+8,R23
    0749 E041      LDI	R20,1
    074A E050      LDI	R21,0
    074B E060      LDI	R22,0
    074C E070      LDI	R23,0
    074D 01FE      MOVW	R30,R28
    074E 8741      STD	Z+9,R20
    074F 8752      STD	Z+10,R21
    0750 8763      STD	Z+11,R22
    0751 8774      STD	Z+12,R23
    0752 01CE      MOVW	R24,R28
    0753 01FE      MOVW	R30,R28
    0754 9508      RET
    0755 8628      STD	Y+8,R2
    0756 8639      STD	Y+9,R3
    0757 864A      STD	Y+10,R4
    0758 865B      STD	Y+11,R5
    0759 9040006C  LDS	R4,passwordH+2
    075B 9050006D  LDS	R5,passwordH+3
    075D 9020006A  LDS	R2,passwordH
    075F 9030006B  LDS	R3,passwordH+1
    0761 822C      STD	Y+4,R2
    0762 823D      STD	Y+5,R3
    0763 824E      STD	Y+6,R4
    0764 825F      STD	Y+7,R5
    0765 9508      RET
    0766 E050      LDI	R21,0
    0767 E060      LDI	R22,0
    0768 E070      LDI	R23,0
    0769 01FE      MOVW	R30,R28
    076A 9508      RET
    076B E040      LDI	R20,0
    076C E050      LDI	R21,0
    076D E060      LDI	R22,0
    076E E070      LDI	R23,0
    076F 8748      STD	Y+8,R20
    0770 8759      STD	Y+9,R21
    0771 876A      STD	Y+10,R22
    0772 877B      STD	Y+11,R23
    0773 E040      LDI	R20,0
    0774 E050      LDI	R21,0
    0775 E060      LDI	R22,0
    0776 E070      LDI	R23,0
    0777 834C      STD	Y+4,R20
    0778 835D      STD	Y+5,R21
    0779 836E      STD	Y+6,R22
    077A 837F      STD	Y+7,R23
    077B 01FE      MOVW	R30,R28
    077C A820      LDD	R2,Z+48
    077D A831      LDD	R3,Z+49
    077E A842      LDD	R4,Z+50
    077F A853      LDD	R5,Z+51
    0780 8228      STD	Y+0,R2
    0781 8239      STD	Y+1,R3
    0782 824A      STD	Y+2,R4
    0783 825B      STD	Y+3,R5
    0784 9508      RET
    0785 9040006C  LDS	R4,passwordH+2
    0787 9050006D  LDS	R5,passwordH+3
    0789 9020006A  LDS	R2,passwordH
    078B 9030006B  LDS	R3,passwordH+1
    078D 9508      RET
    078E E041      LDI	R20,1
    078F E050      LDI	R21,0
    0790 E060      LDI	R22,0
    0791 E070      LDI	R23,0
    0792 9508      RET
    0793 90400062  LDS	R4,id_code+2
    0795 90500063  LDS	R5,id_code+3
    0797 90200060  LDS	R2,id_code
    0799 90300061  LDS	R3,id_code+1
    079B 0C22      LSL	R2
    079C 1C33      ROL	R3
    079D 1C44      ROL	R4
    079E 1C55      ROL	R5
    079F 92300061  STS	id_code+1,R3
    07A1 92200060  STS	id_code,R2
    07A3 92500063  STS	id_code+3,R5
    07A5 92400062  STS	id_code+2,R4
    07A7 9508      RET
    07A8 92300061  STS	id_code+1,R3
    07AA 92200060  STS	id_code,R2
    07AC 92500063  STS	id_code+3,R5
    07AE 92400062  STS	id_code+2,R4
    07B0 9508      RET
    07B1 E040      LDI	R20,0
    07B2 E050      LDI	R21,0
    07B3 E060      LDI	R22,0
    07B4 E070      LDI	R23,0
    07B5 9508      RET
    07B6 90400070  LDS	R4,passwordL+2
    07B8 90500071  LDS	R5,passwordL+3
    07BA 9020006E  LDS	R2,passwordL
    07BC 9030006F  LDS	R3,passwordL+1
    07BE 9508      RET
    07BF E00D      LDI	R16,0xD
    07C0 E010      LDI	R17,0
    07C1 93FA      ST	R31,-Y
    07C2 93EA      ST	R30,-Y
    07C3 939A      ST	R25,-Y
    07C4 938A      ST	R24,-Y
    07C5 940E0706  CALL	asgnblk
    07C7 019E      MOVW	R18,R28
    07C8 9508      RET
    07C9 01F0      MOVW	R30,R0
    07CA E783      LDI	R24,0x73
    07CB E090      LDI	R25,0
    07CC 0FE8      ADD	R30,R24
    07CD 1FF9      ADC	R31,R25
    07CE 9508      RET
    07CF 90400062  LDS	R4,id_code+2
    07D1 90500063  LDS	R5,id_code+3
    07D3 90200060  LDS	R2,id_code
    07D5 90300061  LDS	R3,id_code+1
    07D7 9508      RET
    07D8 B388      IN	R24,0x18
    07D9 7D8F      ANDI	R24,0xDF
    07DA BB88      OUT	0x18,R24
    07DB E604      LDI	R16,0x64
    07DC E010      LDI	R17,0
    07DD 9508      RET
    07DE 01FE      MOVW	R30,R28
    07DF 8823      LDD	R2,Z+19
    07E0 8834      LDD	R3,Z+20
    07E1 8845      LDD	R4,Z+21
    07E2 8856      LDD	R5,Z+22
    07E3 9508      RET
    07E4 A820      LDD	R2,Z+48
    07E5 A831      LDD	R3,Z+49
    07E6 A842      LDD	R4,Z+50
    07E7 A853      LDD	R5,Z+51
    07E8 9508      RET
    07E9 2224      AND	R2,R20
    07EA 2235      AND	R3,R21
    07EB 2246      AND	R4,R22
    07EC 2257      AND	R5,R23
    07ED 9508      RET
    07EE 8345      STD	Z+5,R20
    07EF 8356      STD	Z+6,R21
    07F0 8367      STD	Z+7,R22
    07F1 8770      STD	Z+8,R23
    07F2 9508      RET
    07F3 01FE      MOVW	R30,R28
    07F4 8C22      LDD	R2,Z+26
    07F5 8C33      LDD	R3,Z+27
    07F6 8C44      LDD	R4,Z+28
    07F7 8C55      LDD	R5,Z+29
    07F8 8228      STD	Y+0,R2
    07F9 8239      STD	Y+1,R3
    07FA 824A      STD	Y+2,R4
    07FB 825B      STD	Y+3,R5
    07FC 91200068  LDS	R18,current_index
    07FE 9508      RET
    07FF 0000      NOP
    0800 0000      NOP
    0801 0000      NOP
    0802 0000      NOP
    0803 B385      IN	R24,0x15
    0804 778F      ANDI	R24,0x7F
    0805 BB85      OUT	0x15,R24
    0806 9508      RET
    0807 E081      LDI	R24,1
    0808 838A      STD	Y+2,R24
    0809 E08D      LDI	R24,0xD
    080A 9F86      MUL	R24,R22
    080B 01C0      MOVW	R24,R0
    080C 9508      RET
    080D 880F      LDD	R0,Y+23
    080E 8C18      LDD	R1,Y+24
    080F 821B      STD	Y+3,R1
    0810 820A      STD	Y+2,R0
    0811 E084      LDI	R24,4
    0812 8388      STD	Y+0,R24
    0813 019E      MOVW	R18,R28
    0814 5F27      SUBI	R18,0xF7
    0815 4F3F      SBCI	R19,0xFF
    0816 2D0A      MOV	R16,R10
    0817 9508      RET
    0818 8823      LDD	R2,Z+19
    0819 8834      LDD	R3,Z+20
    081A 8845      LDD	R4,Z+21
    081B 8856      LDD	R5,Z+22
    081C 9508      RET
    081D 01F0      MOVW	R30,R0
    081E E785      LDI	R24,0x75
    081F E090      LDI	R25,0
    0820 0FE8      ADD	R30,R24
    0821 1FF9      ADC	R31,R25
    0822 9508      RET
    0823 2422      CLR	R2
    0824 822A      STD	Y+2,R2
    0825 E08D      LDI	R24,0xD
    0826 9F86      MUL	R24,R22
    0827 01C0      MOVW	R24,R0
    0828 9508      RET
    0829 1462      CP	R6,R2
    082A 0473      CPC	R7,R3
    082B 0484      CPC	R8,R4
    082C 0495      CPC	R9,R5
    082D 9508      RET
    082E 9AAF      SBI	0x15,7
    082F 0000      NOP
    0830 0000      NOP
    0831 0000      NOP
    0832 9508      RET
    0833 9350006F  STS	passwordL+1,R21
    0835 9340006E  STS	passwordL,R20
    0837 93700071  STS	passwordL+3,R23
    0839 93600070  STS	passwordL+2,R22
    083B 9508      RET
    083C EF4F      LDI	R20,0xFF
    083D E050      LDI	R21,0
    083E E060      LDI	R22,0
    083F E070      LDI	R23,0
    0840 9508      RET
    0841 91800069  LDS	R24,input_err_count
    0843 5F8F      SUBI	R24,0xFF
    0844 93800069  STS	input_err_count,R24
    0846 9508      RET
    0847 B388      IN	R24,0x18
    0848 7D8F      ANDI	R24,0xDF
    0849 BB88      OUT	0x18,R24
    084A E900      LDI	R16,0x90
    084B E011      LDI	R17,1
    084C 9508      RET
    084D 01FE      MOVW	R30,R28
    084E 8305      STD	Z+5,R16
    084F 8316      STD	Z+6,R17
    0850 8327      STD	Z+7,R18
    0851 8730      STD	Z+8,R19
    0852 9508      RET
    0853 E586      LDI	R24,0x56
    0854 E090      LDI	R25,0
    0855 8399      STD	Y+1,R25
    0856 8388      STD	Y+0,R24
    0857 E22C      LDI	R18,0x2C
    0858 E031      LDI	R19,1
    0859 E001      LDI	R16,1
    085A 9508      RET
    085B 2433      CLR	R3
    085C 8239      STD	Y+1,R3
    085D 8228      STD	Y+0,R2
    085E E021      LDI	R18,1
    085F 018E      MOVW	R16,R28
    0860 5F0D      SUBI	R16,0xFD
    0861 4F1F      SBCI	R17,0xFF
    0862 9508      RET
    0863 B385      IN	R24,0x15
    0864 778F      ANDI	R24,0x7F
    0865 BB85      OUT	0x15,R24
    0866 0000      NOP
    0867 9508      RET
    0868 8399      STD	Y+1,R25
    0869 8388      STD	Y+0,R24
    086A E024      LDI	R18,4
    086B 018A      MOVW	R16,R20
    086C 9508      RET
    086D 8399      STD	Y+1,R25
    086E 8388      STD	Y+0,R24
    086F E024      LDI	R18,4
    0870 018E      MOVW	R16,R28
    0871 9508      RET
    0872 2C2E      MOV	R2,R14
    0873 2433      CLR	R3
    0874 2D82      MOV	R24,R2
    0875 5081      SUBI	R24,1
    0876 2EE8      MOV	R14,R24
    0877 2022      TST	R2
    0878 9508      RET
    0879 2422      CLR	R2
    087A 2433      CLR	R3
    087B 8231      STD	Z+1,R3
    087C 8220      STD	Z+0,R2
    087D E084      LDI	R24,4
    087E 9508      RET
    087F 9AAE      SBI	0x15,6
    0880 B384      IN	R24,0x14
    0881 7B8F      ANDI	R24,0xBF
    0882 BB84      OUT	0x14,R24
    0883 9AAE      SBI	0x15,6
    0884 9508      RET
    0885 91800066  LDS	R24,read_count
    0887 5F8F      SUBI	R24,0xFF
    0888 93800066  STS	read_count,R24
    088A 9508      RET
    088B E090      LDI	R25,0
    088C 93900065  STS	id_reader_flags+1,R25
    088E 93800064  STS	id_reader_flags,R24
    0890 9508      RET
    0891 1624      CP	R2,R20
    0892 0635      CPC	R3,R21
    0893 0646      CPC	R4,R22
    0894 0657      CPC	R5,R23
    0895 9508      RET
    0896 2D2C      MOV	R18,R12
    0897 018E      MOVW	R16,R28
    0898 5F04      SUBI	R16,0xF4
    0899 4F1F      SBCI	R17,0xFF
    089A 9508      RET
    089B 9601      ADIW	R24,1
    089C 8399      STD	Y+1,R25
    089D 8388      STD	Y+0,R24
    089E E021      LDI	R18,1
    089F 9508      RET
    08A0 8348      STD	Y+0,R20
    08A1 8359      STD	Y+1,R21
    08A2 836A      STD	Y+2,R22
    08A3 837B      STD	Y+3,R23
    08A4 9508      RET
    08A5 933A      ST	R19,-Y
    08A6 932A      ST	R18,-Y
    08A7 931A      ST	R17,-Y
    08A8 930A      ST	R16,-Y
    08A9 9508      RET
    08AA 925A      ST	R5,-Y
    08AB 924A      ST	R4,-Y
    08AC 923A      ST	R3,-Y
    08AD 922A      ST	R2,-Y
    08AE 9508      RET
