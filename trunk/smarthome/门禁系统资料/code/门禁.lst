__start:
__text_start:
    003B E5CF      LDI	R28,0x5F
    003C E0D4      LDI	R29,4
    003D BFCD      OUT	0x3D,R28
    003E BFDE      OUT	0x3E,R29
    003F 51C0      SUBI	R28,0x10
    0040 40D0      SBCI	R29,0
    0041 EA0A      LDI	R16,0xAA
    0042 8308      STD	Y+0,R16
    0043 2400      CLR	R0
    0044 E7E8      LDI	R30,0x78
    0045 E0F0      LDI	R31,0
    0046 E010      LDI	R17,0
    0047 39E6      CPI	R30,0x96
    0048 07F1      CPC	R31,R17
    0049 F011      BEQ	0x004C
    004A 9201      ST	R0,Z+
    004B CFFB      RJMP	0x0047
    004C 8300      STD	Z+0,R16
    004D E5EE      LDI	R30,0x5E
    004E E0F0      LDI	R31,0
    004F E6A0      LDI	R26,0x60
    0050 E0B0      LDI	R27,0
    0051 E010      LDI	R17,0
    0052 37E6      CPI	R30,0x76
    0053 07F1      CPC	R31,R17
    0054 F021      BEQ	0x0059
    0055 95C8      LPM
    0056 9631      ADIW	R30,1
    0057 920D      ST	R0,X+
    0058 CFF9      RJMP	0x0052
    0059 D001      RCALL	_main
_exit:
    005A CFFF      RJMP	_exit
FILE: D:\smarthome\smarthome\门禁系统资料\code\main.c
(0001) #include <stdio.h>
(0002) #include <stdlib.h>
(0003) #include <string.h>
(0004) 
(0005) #include<iom16v.h>
(0006) #include <macros.h>
(0007) 
(0008) #include "uart.h"
(0009) #include "wg26.h"
(0010) #include "util.h"
(0011) #include "tips.h"
(0012) #include "timer.h"
(0013) #include "ringandscreen.h"
(0014) #include "iic.h"
(0015) #include "eeprom.h"
(0016) #include "password.h"
(0017) #include "locker.h"
(0018) 
(0019) int main(void)
(0020) {
(0021)     //unsigned int door_minitor_count = 0;
(0022)     CLI();
_main:
    005B 94F8      BCLR	7
(0023) 	
(0024)     wg26_init_interrupt();
    005C D00E      RCALL	_wg26_init_interrupt
(0025)     tips_port_init();
    005D D0E3      RCALL	_tips_port_init
(0026)     timer_init();
    005E D2FA      RCALL	_timer_init
(0027)     iicport_init();
    005F 940E0650  CALL	_iicport_init
(0028) 	locker_init();
    0061 D3C4      RCALL	_locker_init
(0029) 	doorandscreen_init();
    0062 D3F1      RCALL	_doorandscreen_init
(0030)     uart0_init();
    0063 D419      RCALL	_uart0_init
(0031) 
(0032) 	SEI();
    0064 9478      BSET	7
    0065 C001      RJMP	0x0067
(0033)     //SREG |= 0x80;
(0034) /*
(0035)     t.flags = PASSWORDFLAGS_PASSWORD;
(0036)     t.idCard = 0;
(0037)     t.passwordH = 1135642406;
(0038)     t.passwordL = 100;
(0039)     insertPasswordItem(0, t);
(0040) 
(0041)     t.flags = PASSWORDFLAGS_ID;
(0042)     t.idCard = 9512827;
(0043)     t.passwordH = 1;
(0044)     t.passwordL = 1;
(0045)     insertPasswordItem(1, t);
(0046) 
(0047)     t.flags = PASSWORDFLAGS_ID;
(0048)     t.idCard = 1392618;
(0049)     t.passwordH = 1;
(0050)     t.passwordL = 1;
(0051)     insertPasswordItem(2, t);
(0052) 
(0053)     writePasswordItemNum(3);
(0054) */
(0055)     while(1)
(0056)     {
(0057)         /*
(0058) 		//door_minitor_count++;
(0059) 		if(door_minitor_count>20)
(0060) 		{
(0061) 			//door open.
(0062) 			if(check_door())
(0063) 			{
(0064) 				tips_err();
(0065) 			}
(0066) 			door_minitor_count = 0;
(0067) 		}
(0068) 		delay_ms(500);
(0069) 		*/
(0070) 		//set_sleep_mode(SLEEP_MODE_IDLE);
(0071)         //sleep_mode();
(0072)         wg26_spank();
    0066 D0A6      RCALL	_wg26_spank
    0067 CFFE      RJMP	0x0066
(0073)     }
(0074)     return 0;
    0068 2700      CLR	R16
    0069 2711      CLR	R17
    006A 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\wg26.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "password.h"
(0005) #include "timer.h"
(0006) 
(0007) //pc0 input wg26 d0, pc1 input wg26 d1.
(0008) //wg26 d0 is 0, d1 is 1.
(0009) void wg26_init_interrupt(void)
(0010) {
(0011)     //pc0,pc1 input mode.
(0012)     DDRC &= 0xfc;
_wg26_init_interrupt:
    006B B384      IN	R24,0x14
    006C 7F8C      ANDI	R24,0xFC
    006D BB84      OUT	0x14,R24
(0013)     //上拉。
(0014)     PORTC |= 0x03;
    006E B385      IN	R24,0x15
    006F 6083      ORI	R24,3
    0070 BB85      OUT	0x15,R24
(0015)     //enable interrupt.
(0016)     //pd2 input mode.
(0017)     DDRD &= 0xfb;
    0071 B381      IN	R24,0x11
    0072 7F8B      ANDI	R24,0xFB
    0073 BB81      OUT	0x11,R24
(0018) 	//
(0019) 	PORTD |= 0x04;
    0074 9A92      SBI	0x12,2
(0020) 	
(0021)     //SREG |= 0x80;
(0022)     //int0 enable.
(0023)     GICR |= 0x40;
    0075 B78B      IN	R24,0x3B
    0076 6480      ORI	R24,0x40
    0077 BF8B      OUT	0x3B,R24
(0024)     //int0 fall edge.
(0025)     MCUCR |= 0x02;
    0078 B785      IN	R24,0x35
    0079 6082      ORI	R24,2
    007A BF85      OUT	0x35,R24
(0026)     return;
    007B 9508      RET
(0027) }
(0028) //diable reader.
(0029) static void disable_reader(void)
(0030) {
(0031) 	CLI();
_disable_reader:
    007C 94F8      BCLR	7
(0032)     GICR &= 0xbf;
    007D B78B      IN	R24,0x3B
    007E 7B8F      ANDI	R24,0xBF
    007F BF8B      OUT	0x3B,R24
(0033) 	SEI();
    0080 9478      BSET	7
(0034)     return;
    0081 9508      RET
(0035) }
(0036) //enable reader.
(0037) static void enable_reader(void)
(0038) {
(0039) 	CLI();
_enable_reader:
    0082 94F8      BCLR	7
(0040)     GICR |= 0x40;
    0083 B78B      IN	R24,0x3B
    0084 6480      ORI	R24,0x40
    0085 BF8B      OUT	0x3B,R24
(0041) 	SEI();
    0086 9478      BSET	7
(0042) 	return;
    0087 9508      RET
_id_reader_check:
  id_code              --> Y+0
    0088 940E0750  CALL	push_arg4
(0043) }
(0044) 
(0045) static unsigned char havePassword = 0;
(0046) 
(0047) static unsigned char type = IDREADEDUNKOWN;
(0048) //id card id.
(0049) static unsigned long id_code = 0;
(0050) //read flags.
(0051) static unsigned int id_reader_flags = 0;
(0052) //read count.
(0053) static char read_count = 0;
(0054) //define reader flags.
(0055) #define IDREADERFLAG_WAITING 0x0000
(0056) #define IDREADERFLAG_READING 0x0001
(0057) #define IDREADERFLAG_READED 0x0002
(0058) //id code check.
(0059) static char id_reader_check(unsigned long id_code)
(0060) {
(0061)     return 0;
    008A 2700      CLR	R16
    008B 9624      ADIW	R28,4
    008C 9508      RET
_read_time_out:
  timer                --> R10
    008D 940E078B  CALL	push_gset3
    008F 2EA0      MOV	R10,R16
(0062) }
(0063) 
(0064) //read timeout.
(0065) static void read_time_out(char timer)
(0066) {
(0067)     if(timer == IDREADERTIMEOUTTIMER)
    0090 20AA      TST	R10
    0091 F009      BEQ	0x0093
    0092 C03C      RJMP	0x00CF
(0068)     {
(0069)         //disable reader.
(0070)         disable_reader();
    0093 DFE8      RCALL	_disable_reader
(0071)         id_reader_flags = IDREADERFLAG_READED;
    0094 E082      LDI	R24,2
    0095 940E0978  CALL	0x978
(0072)         //read ok.
(0073)         if(read_count==26) //id card.
    0097 91800068  LDS	R24,read_count
    0099 318A      CPI	R24,0x1A
    009A F509      BNE	0x00BC
(0074)         {
(0075)             if(!id_reader_check(id_code))
    009B 91200064  LDS	R18,id_code+2
    009D 91300065  LDS	R19,id_code+3
    009F 91000062  LDS	R16,id_code
    00A1 91100063  LDS	R17,id_code+1
    00A3 DFE4      RCALL	_id_reader_check
    00A4 2300      TST	R16
    00A5 F501      BNE	0x00C6
(0076)             {
(0077)                 id_code &= 0x01fffffe;
    00A6 EF4E      LDI	R20,0xFE
    00A7 EF5F      LDI	R21,0xFF
    00A8 EF6F      LDI	R22,0xFF
    00A9 E071      LDI	R23,1
    00AA 940E08BE  CALL	0x8BE
    00AC 940E0915  CALL	0x915
    00AE 940E088F  CALL	0x88F
(0078)                 id_code >>= 1;
    00B0 9456      LSR	R5
    00B1 9447      ROR	R4
    00B2 9437      ROR	R3
    00B3 9427      ROR	R2
    00B4 940E088F  CALL	0x88F
(0079)                 type = IDREADEDIDCARD;
    00B6 E081      LDI	R24,1
    00B7 93800061  STS	type,R24
(0080)                 havePassword = 1;
    00B9 93800060  STS	havePassword,R24
(0081)                 //password_handle(IDREADEDIDCARD, id_code);
(0082)             }
(0083)         }
    00BB C00A      RJMP	0x00C6
(0084)         else if(read_count==4)//keypad input.
    00BC 91800068  LDS	R24,read_count
    00BE 3084      CPI	R24,4
    00BF F431      BNE	0x00C6
(0085)         {
(0086)             type = IDREADEDKEYPAD;
    00C0 E082      LDI	R24,2
    00C1 93800061  STS	type,R24
(0087)             havePassword = 1;
    00C3 E081      LDI	R24,1
    00C4 93800060  STS	havePassword,R24
(0088)             //password_handle(IDREADEDKEYPAD, id_code);
(0089)         }
(0090)         //enable reader.
(0091)         enable_reader();
    00C6 DFBB      RCALL	_enable_reader
(0092)         id_reader_flags = IDREADERFLAG_WAITING;
    00C7 2422      CLR	R2
    00C8 2433      CLR	R3
    00C9 92300067  STS	id_reader_flags+1,R3
    00CB 92200066  STS	id_reader_flags,R2
(0093)         read_count = 0;
    00CD 92200068  STS	read_count,R2
(0094)     }
(0095)     return;
    00CF 940E0781  CALL	pop_gset3
    00D1 9508      RET
_set_id_reading_status:
    00D2 940E078D  CALL	push_gset2
    00D4 9722      SBIW	R28,2
(0096) }
(0097) //set status.
(0098) static void set_id_reading_status(void)
(0099) {
(0100)     if(id_reader_flags!=IDREADERFLAG_READING)
    00D5 91800066  LDS	R24,id_reader_flags
    00D7 91900067  LDS	R25,id_reader_flags+1
    00D9 3081      CPI	R24,1
    00DA E0E0      LDI	R30,0
    00DB 079E      CPC	R25,R30
    00DC F061      BEQ	0x00E9
(0101)     {
(0102)         id_reader_flags = IDREADERFLAG_READING;
    00DD E081      LDI	R24,1
    00DE 940E0978  CALL	0x978
    00E0 940E083B  CALL	0x83B
    00E2 940E091A  CALL	0x91A
(0103)         id_code = 0;
(0104)         //1*100ms.
(0105)         set_timer(IDREADERTIMEOUTTIMER, 2, read_time_out);
    00E4 E584      LDI	R24,0x54
    00E5 940E0972  CALL	0x972
    00E7 2700      CLR	R16
    00E8 D284      RCALL	_set_timer
(0106)     }
(0107)     return;
    00E9 9622      ADIW	R28,2
    00EA 940E077F  CALL	pop_gset2
    00EC 9508      RET
_int0_isr:
    00ED 940E07D4  CALL	push_lset
    00EF 940E078D  CALL	push_gset2
(0108) }
(0109) //pull id card id and keypad input.
(0110) #pragma interrupt_handler int0_isr:2
(0111) void int0_isr(void)
(0112) {
(0113)     set_id_reading_status();
    00F1 DFE0      RCALL	_set_id_reading_status
(0114)     if(!(PINC&0x02))
    00F2 9999      SBIC	0x13,1
    00F3 C00B      RJMP	0x00FF
    00F4 940E087A  CALL	0x87A
    00F6 940E08EE  CALL	0x8EE
(0115)     {
(0116)         id_code <<= 1;
(0117)         id_code |= 1;
    00F8 2A24      OR	R2,R20
    00F9 2A35      OR	R3,R21
    00FA 2A46      OR	R4,R22
    00FB 2A57      OR	R5,R23
    00FC 940E088F  CALL	0x88F
(0118)     }
    00FE C004      RJMP	0x0103
(0119)     else if(!(PINC&0x01))
    00FF 9998      SBIC	0x13,0
    0100 C002      RJMP	0x0103
    0101 940E087A  CALL	0x87A
(0120)     {
(0121)         id_code <<= 1;
(0122)     }
(0123)     ++read_count;
    0103 91800068  LDS	R24,read_count
    0105 5F8F      SUBI	R24,0xFF
    0106 93800068  STS	read_count,R24
(0124)     return;
    0108 940E077F  CALL	pop_gset2
    010A 940E07E7  CALL	pop_lset
    010C 9518      RETI
_wg26_spank:
    010D 940E078D  CALL	push_gset2
    010F 9722      SBIW	R28,2
(0125) }
(0126) 
(0127) void wg26_spank(void)
(0128) {
(0129)     if(1==havePassword)
    0110 91800060  LDS	R24,havePassword
    0112 3081      CPI	R24,1
    0113 F489      BNE	0x0125
    0114 940E08BE  CALL	0x8BE
(0130)     {
(0131)         password_handle(type, id_code);
    0116 8248      STD	Y+0,R4
    0117 8259      STD	Y+1,R5
    0118 0191      MOVW	R18,R2
    0119 91000061  LDS	R16,type
    011B D0FE      RCALL	_password_handle
(0132)         havePassword = 0;
    011C 2422      CLR	R2
    011D 92200060  STS	havePassword,R2
(0133)         type = IDREADEDUNKOWN;
    011F 92200061  STS	type,R2
    0121 940E083B  CALL	0x83B
    0123 940E091A  CALL	0x91A
(0134)         id_code = 0;
(0135)     }
(0136)     return;
    0125 9622      ADIW	R28,2
    0126 940E077F  CALL	pop_gset2
    0128 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\util.c
(0001) #include "util.h"
(0002) 
(0003) #define XTAL    8
(0004) void delay_1ms(void)
(0005) {
(0006)     int i;
(0007)     //XTAL*143-2 = 1142
(0008)     for(i=1;i<1142;i++);
_delay_1ms:
  i                    --> R16
    0129 E001      LDI	R16,1
    012A E010      LDI	R17,0
    012B 5F0F      SUBI	R16,0xFF
    012C 4F1F      SBCI	R17,0xFF
    012D 3706      CPI	R16,0x76
    012E E0E4      LDI	R30,4
    012F 071E      CPC	R17,R30
    0130 F3D4      BLT	0x012B
    0131 9508      RET
_delay_ms:
  i                    --> R20
  ms                   --> R22
    0132 940E078D  CALL	push_gset2
    0134 01B8      MOVW	R22,R16
(0009) }
(0010) //=========================================
(0011) void delay_ms(int ms)
(0012) {
(0013)     int i=0;
    0135 2744      CLR	R20
    0136 2755      CLR	R21
    0137 C003      RJMP	0x013B
(0014)     while(i<ms)
(0015)     {
(0016)         delay_1ms();
    0138 DFF0      RCALL	_delay_1ms
(0017)         i++;
    0139 5F4F      SUBI	R20,0xFF
    013A 4F5F      SBCI	R21,0xFF
    013B 1746      CP	R20,R22
    013C 0757      CPC	R21,R23
    013D F3D4      BLT	0x0138
    013E 940E077F  CALL	pop_gset2
    0140 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\tips.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "tips.h"
(0005) #include "util.h"
(0006) 
(0007) #define BEEP_ON (PORTB&=0xdf)
(0008) #define BEEP_OFF (PORTB|=0x20)
(0009) #define LED_ON (PORTB&=0xbf)
(0010) #define LED_OFF (PORTB|=0x40)
(0011) #define BOARD_LED_ON (PORTB&=0x7f)
(0012) #define BOARD_LED_OFF (PORTB|=0x80)
(0013) 
(0014) //pb5 beep,pb6 led, pb7 board led.
(0015) void tips_port_init(void)
(0016) {
(0017)     //PINB5 & PINB6 PINB0 tips led. OUTPUT AND pull-up resistors.
(0018)     PORTB |= 0xe0;
_tips_port_init:
    0141 B388      IN	R24,0x18
    0142 6E80      ORI	R24,0xE0
    0143 BB88      OUT	0x18,R24
(0019)     DDRB |= 0xe0;
    0144 B387      IN	R24,0x17
    0145 6E80      ORI	R24,0xE0
    0146 BB87      OUT	0x17,R24
(0020)     return;
    0147 9508      RET
(0021) }
(0022) //led on.
(0023) void tips_led_on(void)
(0024) {
(0025)     LED_ON;
_tips_led_on:
    0148 B388      IN	R24,0x18
    0149 7B8F      ANDI	R24,0xBF
    014A BB88      OUT	0x18,R24
(0026)     return;
    014B 9508      RET
(0027) }
(0028) //led off.
(0029) void tips_led_off(void)
(0030) {
(0031)     LED_OFF;
_tips_led_off:
    014C 9AC6      SBI	0x18,6
(0032)     return;
    014D 9508      RET
(0033) }
(0034) //beep on.
(0035) void tips_beep_on(void)
(0036) {
(0037)     BEEP_ON;
_tips_beep_on:
    014E B388      IN	R24,0x18
    014F 7D8F      ANDI	R24,0xDF
    0150 BB88      OUT	0x18,R24
(0038)     return;
    0151 9508      RET
(0039) }
(0040) //beep off.
(0041) void tips_beep_off(void)
(0042) {
(0043)     BEEP_OFF;
_tips_beep_off:
    0152 9AC5      SBI	0x18,5
(0044)     return;
    0153 9508      RET
(0045) }
(0046) /*
(0047) //__------__ 6 pices.pice per 0.4 seconds.
(0048) void tips_ok(void)
(0049) {
(0050)     LED_ON;
(0051)     BEEP_ON;
(0052)     //2.4 seconds.
(0053)     delay_ms(400);
(0054)     LED_OFF;
(0055)     BEEP_OFF;
(0056)     return;
(0057) }
(0058) */
(0059) //_-_-___-_-_
(0060) void tips_err(void)
(0061) {
(0062)     BEEP_ON;
_tips_err:
    0154 940E08F3  CALL	0x8F3
(0063)     delay_ms(100);
    0156 DFDB      RCALL	_delay_ms
(0064)     BEEP_OFF;
    0157 9AC5      SBI	0x18,5
(0065)     delay_ms(100);
    0158 E604      LDI	R16,0x64
    0159 E010      LDI	R17,0
    015A DFD7      RCALL	_delay_ms
    015B 940E08F3  CALL	0x8F3
(0066)     BEEP_ON;
(0067)     delay_ms(100);
    015D DFD4      RCALL	_delay_ms
(0068)     BEEP_OFF;
    015E 9AC5      SBI	0x18,5
(0069)  
(0070)     delay_ms(200);
    015F EC08      LDI	R16,0xC8
    0160 E010      LDI	R17,0
    0161 DFD0      RCALL	_delay_ms
    0162 940E08F3  CALL	0x8F3
(0071)  
(0072)     BEEP_ON;
(0073)     delay_ms(100);
    0164 DFCD      RCALL	_delay_ms
(0074)     BEEP_OFF;
    0165 9AC5      SBI	0x18,5
(0075)     delay_ms(100);
    0166 E604      LDI	R16,0x64
    0167 E010      LDI	R17,0
    0168 DFC9      RCALL	_delay_ms
    0169 940E08F3  CALL	0x8F3
(0076)     BEEP_ON;
(0077)     delay_ms(100);
    016B DFC6      RCALL	_delay_ms
(0078)     BEEP_OFF;
    016C 9AC5      SBI	0x18,5
(0079)     return;
    016D 9508      RET
(0080) }
(0081) /*
(0082) //_----_-_-_
(0083) void tips_id_ok(void)
(0084) {
(0085)     BEEP_ON;
(0086)     delay_ms(200);
(0087)     BEEP_OFF;
(0088)     delay_ms(200);
(0089) 
(0090)     BEEP_ON;
(0091)     delay_ms(100);
(0092)     BEEP_OFF;
(0093)     delay_ms(100);
(0094)     BEEP_ON;
(0095)     delay_ms(100);
(0096)     BEEP_OFF;
(0097)     return;
(0098) }
(0099) */
(0100) /*
(0101) //__------__-----__
(0102) void tips_ring_on(void)
(0103) {
(0104)     BEEP_ON;
(0105)     //2.4 seconds.
(0106)     delay_ms(400);
(0107)     BEEP_OFF;
(0108)     delay_ms(400);
(0109)     BEEP_ON;
(0110)     //2.4 seconds.
(0111)     delay_ms(400);
(0112)     BEEP_OFF;
(0113)     return;
(0114) }*/
(0115) void tips_board_led_on(void)
(0116) {
(0117) 	BOARD_LED_ON;
_tips_board_led_on:
    016E B388      IN	R24,0x18
    016F 778F      ANDI	R24,0x7F
    0170 BB88      OUT	0x18,R24
    0171 9508      RET
(0118) }
(0119) 
(0120) void tips_board_led_off(void)
(0121) {
(0122) 	BOARD_LED_OFF;
_tips_board_led_off:
    0172 9AC7      SBI	0x18,7
    0173 9508      RET
_readPasswordItemNum:
  num                  --> Y+3
    0174 9724      SBIW	R28,4
FILE: D:\smarthome\smarthome\门禁系统资料\code\password.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "log.h"
(0005) #include "locker.h"
(0006) #include "tips.h"
(0007) #include "timer.h"
(0008) #include "iic.h"
(0009) #include "eeprom.h"
(0010) #include "uart.h"
(0011) #include "password.h"
(0012) #include "ringandscreen.h"
(0013) 
(0014) //eeprom 
(0015) //addr: 0 number.
(0016) 
(0017) // 1: flags
(0018) // 2,3,4,5: id Card.
(0019) // 6,7,8,9: password H
(0020) // 10,11,12,13 :password L
(0021) 
(0022) // 14: flags
(0023) // 15,16,17,18: id Card.
(0024) // 19,20,21,22: password H
(0025) // 23,24,25,26 :password L
(0026) 
(0027) unsigned char readPasswordItemNum(void)
(0028) {
(0029)     unsigned char num = 0;
    0175 2422      CLR	R2
    0176 822B      STD	Y+3,R2
(0030) 
(0031)     rw24c256(&num, 1, 0, RWREAD);
    0177 E081      LDI	R24,1
    0178 838A      STD	Y+2,R24
    0179 940E093B  CALL	0x93B
    017B D2F0      RCALL	_rw24c256
(0032)     return num;
    017C 810B      LDD	R16,Y+3
    017D 9624      ADIW	R28,4
    017E 9508      RET
_readPasswordItem:
  t                    --> Y+16
  item                 --> Y+3
  index                --> R22
    017F 940E078D  CALL	push_gset2
    0181 2F62      MOV	R22,R18
    0182 01A8      MOVW	R20,R16
    0183 9761      SBIW	R28,0x11
(0033) }
(0034) 
(0035) passwordItem_t readPasswordItem(unsigned char index)
(0036) {
(0037)     passwordItem_t item;
(0038)     unsigned char t = 0;
    0184 2422      CLR	R2
    0185 8A28      STD	Y+16,R2
    0186 940E0904  CALL	0x904
    0188 940E0999  CALL	0x999
(0039) 
(0040)     rw24c256(&t, 1, index*13+1, RWREAD);
    018A 018E      MOVW	R16,R28
    018B 5F00      SUBI	R16,0xF0
    018C 4F1F      SBCI	R17,0xFF
    018D D2DE      RCALL	_rw24c256
(0041)     item.flags = t;
    018E 8828      LDD	R2,Y+16
    018F 822B      STD	Y+3,R2
    0190 940E0904  CALL	0x904
(0042) 
(0043)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWREAD);
    0192 9602      ADIW	R24,2
    0193 8399      STD	Y+1,R25
    0194 8388      STD	Y+0,R24
    0195 940E0968  CALL	0x968
    0197 D2D4      RCALL	_rw24c256
    0198 940E0904  CALL	0x904
(0044)     
(0045)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWREAD);
    019A 9606      ADIW	R24,6
    019B 8399      STD	Y+1,R25
    019C 8388      STD	Y+0,R24
    019D 940E0963  CALL	0x963
    019F D2CC      RCALL	_rw24c256
    01A0 940E0904  CALL	0x904
(0046) 	
(0047)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWREAD);
    01A2 960A      ADIW	R24,0xA
    01A3 8399      STD	Y+1,R25
    01A4 8388      STD	Y+0,R24
    01A5 940E094B  CALL	0x94B
    01A7 D2C4      RCALL	_rw24c256
(0048)     
(0049)     return item;
    01A8 01CE      MOVW	R24,R28
    01A9 9603      ADIW	R24,3
    01AA E00D      LDI	R16,0xD
    01AB E010      LDI	R17,0
    01AC 935A      ST	R21,-Y
    01AD 934A      ST	R20,-Y
    01AE 939A      ST	R25,-Y
    01AF 938A      ST	R24,-Y
    01B0 940E080A  CALL	asgnblk
    01B2 9661      ADIW	R28,0x11
    01B3 940E077F  CALL	pop_gset2
    01B5 9508      RET
_insertPasswordItem:
  item                 --> R20
  index                --> R22
    01B6 940E078D  CALL	push_gset2
    01B8 01A9      MOVW	R20,R18
    01B9 2F60      MOV	R22,R16
    01BA 9723      SBIW	R28,3
    01BB 940E08F9  CALL	0x8F9
    01BD 940E0999  CALL	0x999
(0050) }
(0051) 
(0052) void insertPasswordItem(unsigned char index, passwordItem_t item)
(0053) {
(0054)     rw24c256(&(item.flags), 1, index*13+1, RWWRITE);
    01BF 018A      MOVW	R16,R20
    01C0 D2AB      RCALL	_rw24c256
    01C1 940E08F9  CALL	0x8F9
(0055) 	
(0056)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWWRITE);
    01C3 9602      ADIW	R24,2
    01C4 940E096D  CALL	0x96D
    01C6 5F0F      SUBI	R16,0xFF
    01C7 4F1F      SBCI	R17,0xFF
    01C8 D2A3      RCALL	_rw24c256
    01C9 940E08F9  CALL	0x8F9
(0057) 	
(0058)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWWRITE);
    01CB 9606      ADIW	R24,6
    01CC 940E096D  CALL	0x96D
    01CE 5F0B      SUBI	R16,0xFB
    01CF 4F1F      SBCI	R17,0xFF
    01D0 D29B      RCALL	_rw24c256
    01D1 940E08F9  CALL	0x8F9
(0059) 	
(0060)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWWRITE);
    01D3 960A      ADIW	R24,0xA
    01D4 940E096D  CALL	0x96D
    01D6 5F07      SUBI	R16,0xF7
    01D7 4F1F      SBCI	R17,0xFF
    01D8 D293      RCALL	_rw24c256
(0061) 	
(0062)     return;
    01D9 9623      ADIW	R28,3
    01DA 940E077F  CALL	pop_gset2
    01DC 9508      RET
_writePasswordItemNum:
  num                  --> Y+3
    01DD 931A      ST	R17,-Y
    01DE 930A      ST	R16,-Y
    01DF 9723      SBIW	R28,3
(0063) }
(0064) 
(0065) void writePasswordItemNum(unsigned char num)
(0066) {
(0067)     rw24c256(&num, 1, 0, RWWRITE);
    01E0 2422      CLR	R2
    01E1 822A      STD	Y+2,R2
    01E2 940E093B  CALL	0x93B
    01E4 D287      RCALL	_rw24c256
(0068)     return;
    01E5 9625      ADIW	R28,5
    01E6 9508      RET
_clear_pswd_status:
    01E7 940E078D  CALL	push_gset2
    01E9 940E08EE  CALL	0x8EE
(0069) }
(0070) 
(0071) #define PASSWORDREADIDCARDUNKOWN    0
(0072) #define PASSWORDREADIDCARDOK                1
(0073) #define PASSWORDREADIDANDPSWDOK         2
(0074) 
(0075) static unsigned long current_id = 1; //no card id is 1
(0076) static unsigned char input_err_count = 0;
(0077) 
(0078) //You input xxx then password is 1xxx.
(0079) static unsigned long passwordH = 1;
(0080) static unsigned long passwordL = 1;
(0081) 
(0082) static void clear_pswd_status(void)
(0083) {
(0084)     //clear last password input.
(0085)     passwordH = 1;
    01EB 9350006F  STS	passwordH+1,R21
    01ED 9340006E  STS	passwordH,R20
    01EF 93700071  STS	passwordH+3,R23
    01F1 93600070  STS	passwordH+2,R22
    01F3 940E08CF  CALL	0x8CF
    01F5 940E08EE  CALL	0x8EE
(0086)     passwordL = 1;
(0087)     current_id = 1;
    01F7 9350006A  STS	current_id+1,R21
    01F9 93400069  STS	current_id,R20
    01FB 9370006C  STS	current_id+3,R23
    01FD 9360006B  STS	current_id+2,R22
(0088)     tips_led_off();
    01FF DF4C      RCALL	_tips_led_off
(0089)     stop_timer(PASSWORDTIMEOUTTIMER);
    0200 E001      LDI	R16,1
    0201 D185      RCALL	_stop_timer
(0090)     return;
    0202 D57C      RCALL	pop_gset2
    0203 9508      RET
(0091) }
(0092) 
(0093) //cannot input timeout.
(0094) static void cannot_input_time_out(char timer)
(0095) {
(0096)     if(timer==PASSWORDTIMEOUTTIMER)
_cannot_input_time_out:
  timer                --> R16
    0204 3001      CPI	R16,1
    0205 F419      BNE	0x0209
(0097)         input_err_count = 0;
    0206 2422      CLR	R2
    0207 9220006D  STS	input_err_count,R2
(0098)     return;
    0209 9508      RET
_input_time_out:
  timer                --> R20
    020A D584      RCALL	push_gset1
    020B 2F40      MOV	R20,R16
(0099) }
(0100) 
(0101) //input timeout.
(0102) static void input_time_out(char timer)
(0103) {
(0104)     if(timer==PASSWORDTIMEOUTTIMER)
    020C 3041      CPI	R20,1
    020D F409      BNE	0x020F
(0105)         clear_pswd_status();
    020E DFD8      RCALL	_clear_pswd_status
(0106)     return;
    020F D582      RCALL	pop_gset1
    0210 9508      RET
(0107) }
(0108) 
(0109) void password_handle_err(void)
(0110) {
(0111)     clear_pswd_status();
_password_handle_err:
    0211 DFD5      RCALL	_clear_pswd_status
(0112)     tips_err();
    0212 DF41      RCALL	_tips_err
    0213 9508      RET
(0113) }
(0114) void password_handle_ok(void)
(0115) {
(0116)     //clear pswd statuc.
(0117)     clear_pswd_status();
_password_handle_ok:
    0214 DFD2      RCALL	_clear_pswd_status
(0118)     //tips_ok();
(0119)     locker_unlock();
    0215 D228      RCALL	_locker_unlock
(0120)     //error count clear.
(0121)     input_err_count = 0;
    0216 2422      CLR	R2
    0217 9220006D  STS	input_err_count,R2
    0219 9508      RET
_password_handle:
  pswd_item_num        --> R10
  i                    --> R12
  item                 --> Y+12
  code                 --> Y+35
  type                 --> R14
    021A 933A      ST	R19,-Y
    021B 932A      ST	R18,-Y
    021C D56A      RCALL	push_gset5
    021D 2EE0      MOV	R14,R16
    021E 9769      SBIW	R28,0x19
(0122) }
(0123) void password_handle(char type, unsigned long code)
(0124) {
(0125)     unsigned char pswd_item_num = 0;
    021F 24AA      CLR	R10
(0126)     unsigned char i;
(0127)     passwordItem_t item;
(0128) 
(0129) 	//on screen
(0130) 	screen_on_pinLow();
    0220 D23E      RCALL	_screen_on_pinLow
(0131)     //if input error count is too large.
(0132)     if(input_err_count>5)
    0221 E085      LDI	R24,5
    0222 9020006D  LDS	R2,input_err_count
    0224 1582      CP	R24,R2
    0225 F458      BCC	0x0231
(0133)     {
(0134)         password_handle_err();
    0226 DFEA      RCALL	_password_handle_err
(0135)         //set time out. 100ms*10*60
(0136)         set_timer(PASSWORDTIMEOUTTIMER, 600, cannot_input_time_out);
    0227 E588      LDI	R24,0x58
    0228 E090      LDI	R25,0
    0229 8399      STD	Y+1,R25
    022A 8388      STD	Y+0,R24
    022B E528      LDI	R18,0x58
    022C E032      LDI	R19,2
    022D E001      LDI	R16,1
    022E D13E      RCALL	_set_timer
(0137)         screen_on_pinHigh();
    022F D234      RCALL	_screen_on_pinHigh
(0138) 		return;
    0230 C124      RJMP	0x0355
(0139)     }
(0140)     //deal with keypad input.
(0141)     if((type==IDREADEDKEYPAD)&&(code!=0x0000000b))
    0231 2D8E      MOV	R24,R14
    0232 3082      CPI	R24,2
    0233 F009      BEQ	0x0235
    0234 C055      RJMP	0x028A
    0235 E04B      LDI	R20,0xB
    0236 E050      LDI	R21,0
    0237 E060      LDI	R22,0
    0238 E070      LDI	R23,0
    0239 940E08AF  CALL	0x8AF
    023B 940E099E  CALL	0x99E
    023D F409      BNE	0x023F
    023E C04B      RJMP	0x028A
(0142)     {
(0143)         code &= 0x0000000f;
    023F E04F      LDI	R20,0xF
    0240 E050      LDI	R21,0
    0241 E060      LDI	R22,0
    0242 E070      LDI	R23,0
    0243 940E08AF  CALL	0x8AF
    0245 940E0915  CALL	0x915
    0247 01FE      MOVW	R30,R28
    0248 A223      STD	Z+35,R2
    0249 A234      STD	Z+36,R3
    024A A245      STD	Z+37,R4
    024B A256      STD	Z+38,R5
    024C 940E0994  CALL	0x994
    024E 940E08AF  CALL	0x8AF
    0250 940E099E  CALL	0x99E
(0144)         if(code == 0x0000000a)  //*
    0252 F411      BNE	0x0255
(0145)         {
(0146)             //clear password.
(0147)             clear_pswd_status();
    0253 DF93      RCALL	_clear_pswd_status
(0148)         }
    0254 C0FF      RJMP	0x0354
(0149)         else
(0150)         {
(0151)             tips_led_on();
    0255 DEF2      RCALL	_tips_led_on
    0256 940E0943  CALL	0x943
(0152)             //set time out. 100ms*10*30
(0153)             set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    0258 D114      RCALL	_set_timer
    0259 940E08B5  CALL	0x8B5
    025B 940E0994  CALL	0x994
    025D 940E098F  CALL	0x98F
(0154)             passwordL = passwordL*10 + code;
    025F 018A      MOVW	R16,R20
    0260 019B      MOVW	R18,R22
    0261 D4F1      RCALL	empy32u
    0262 0118      MOVW	R2,R16
    0263 0129      MOVW	R4,R18
    0264 01FE      MOVW	R30,R28
    0265 A063      LDD	R6,Z+35
    0266 A074      LDD	R7,Z+36
    0267 A085      LDD	R8,Z+37
    0268 A096      LDD	R9,Z+38
    0269 0C26      ADD	R2,R6
    026A 1C37      ADC	R3,R7
    026B 1C48      ADC	R4,R8
    026C 1C59      ADC	R5,R9
    026D 92300073  STS	passwordL+1,R3
    026F 92200072  STS	passwordL,R2
    0271 92500075  STS	passwordL+3,R5
    0273 92400074  STS	passwordL+2,R4
(0155)             //passwordH save password hight 9 num.
(0156)             if(passwordL>999999999)
    0275 EF4F      LDI	R20,0xFF
    0276 EC59      LDI	R21,0xC9
    0277 E96A      LDI	R22,0x9A
    0278 E37B      LDI	R23,0x3B
    0279 1542      CP	R20,R2
    027A 0553      CPC	R21,R3
    027B 0564      CPC	R22,R4
    027C 0575      CPC	R23,R5
    027D F008      BCS	0x027F
    027E C0D5      RJMP	0x0354
(0157)             {
(0158)                 passwordH = passwordL;
    027F 9230006F  STS	passwordH+1,R3
    0281 9220006E  STS	passwordH,R2
    0283 92500071  STS	passwordH+3,R5
    0285 92400070  STS	passwordH+2,R4
    0287 940E08CF  CALL	0x8CF
(0159)                 passwordL = 1;
(0160)             }
(0161)         }
(0162)     }
    0289 C0CA      RJMP	0x0354
(0163)     else    //deal with key
(0164)     {
(0165)         //read paswd item num.
(0166)         pswd_item_num = readPasswordItemNum();
    028A DEE9      RCALL	_readPasswordItemNum
    028B 2EA0      MOV	R10,R16
(0167)         //loop find it.
(0168)         for(i=0;i<pswd_item_num;++i)
    028C 24CC      CLR	R12
    028D C0B7      RJMP	0x0345
(0169)         {
(0170)             //read a item.
(0171)             item = readPasswordItem(i);
    028E 2D2C      MOV	R18,R12
    028F 018E      MOVW	R16,R28
    0290 5F04      SUBI	R16,0xF4
    0291 4F1F      SBCI	R17,0xFF
    0292 DEEC      RCALL	_readPasswordItem
(0172)             if((item.flags==PASSWORDFLAGS_ID)&&(type==IDREADEDIDCARD)&&(item.idCard==code))
    0293 858C      LDD	R24,Y+12
    0294 3081      CPI	R24,1
    0295 F009      BEQ	0x0297
    0296 C024      RJMP	0x02BB
    0297 2D8E      MOV	R24,R14
    0298 3081      CPI	R24,1
    0299 F009      BEQ	0x029B
    029A C020      RJMP	0x02BB
    029B 940E08AF  CALL	0x8AF
    029D 01FE      MOVW	R30,R28
    029E 8465      LDD	R6,Z+13
    029F 8476      LDD	R7,Z+14
    02A0 8487      LDD	R8,Z+15
    02A1 8890      LDD	R9,Z+16
    02A2 940E0898  CALL	0x898
    02A4 F4B1      BNE	0x02BB
    02A5 940E083B  CALL	0x83B
(0173)             {
(0174)                 //record log
(0175)                 log(COMMANDIDLOGOK, PASSWORDFLAGS_ID, code, 0, 0);
    02A7 8748      STD	Y+8,R20
    02A8 8759      STD	Y+9,R21
    02A9 876A      STD	Y+10,R22
    02AA 877B      STD	Y+11,R23
    02AB 940E083B  CALL	0x83B
    02AD 834C      STD	Y+4,R20
    02AE 835D      STD	Y+5,R21
    02AF 836E      STD	Y+6,R22
    02B0 837F      STD	Y+7,R23
    02B1 940E08AF  CALL	0x8AF
    02B3 940E0910  CALL	0x910
    02B5 E021      LDI	R18,1
    02B6 2700      CLR	R16
    02B7 D15C      RCALL	_log
(0176)                 password_handle_ok();
    02B8 DF5B      RCALL	_password_handle_ok
(0177)                 screen_on_pinHigh();
    02B9 D1AA      RCALL	_screen_on_pinHigh
(0178) 				return;
    02BA C09A      RJMP	0x0355
(0179)             }
(0180)             else if((item.flags==PASSWORDFLAGS_PASSWORD)&&(type==IDREADEDKEYPAD)&&
    02BB 858C      LDD	R24,Y+12
    02BC 3082      CPI	R24,2
    02BD F009      BEQ	0x02BF
    02BE C034      RJMP	0x02F3
    02BF 2D8E      MOV	R24,R14
    02C0 3082      CPI	R24,2
    02C1 F009      BEQ	0x02C3
    02C2 C030      RJMP	0x02F3
    02C3 940E0871  CALL	0x871
    02C5 01FE      MOVW	R30,R28
    02C6 8861      LDD	R6,Z+17
    02C7 8872      LDD	R7,Z+18
    02C8 8883      LDD	R8,Z+19
    02C9 8894      LDD	R9,Z+20
    02CA 940E0898  CALL	0x898
    02CC F531      BNE	0x02F3
    02CD 940E08B5  CALL	0x8B5
    02CF 01FE      MOVW	R30,R28
    02D0 8865      LDD	R6,Z+21
    02D1 8876      LDD	R7,Z+22
    02D2 8887      LDD	R8,Z+23
    02D3 8C90      LDD	R9,Z+24
    02D4 940E0898  CALL	0x898
    02D6 F4E1      BNE	0x02F3
(0181)                 (item.passwordH==passwordH)&&(item.passwordL==passwordL))
(0182)             {
(0183)                 log(COMMANDIDLOGOK, PASSWORDFLAGS_PASSWORD, 0, passwordH, passwordL);
    02D7 8628      STD	Y+8,R2
    02D8 8639      STD	Y+9,R3
    02D9 864A      STD	Y+10,R4
    02DA 865B      STD	Y+11,R5
    02DB 90400070  LDS	R4,passwordH+2
    02DD 90500071  LDS	R5,passwordH+3
    02DF 9020006E  LDS	R2,passwordH
    02E1 9030006F  LDS	R3,passwordH+1
    02E3 822C      STD	Y+4,R2
    02E4 823D      STD	Y+5,R3
    02E5 824E      STD	Y+6,R4
    02E6 825F      STD	Y+7,R5
    02E7 940E083B  CALL	0x83B
    02E9 8348      STD	Y+0,R20
    02EA 8359      STD	Y+1,R21
    02EB 836A      STD	Y+2,R22
    02EC 837B      STD	Y+3,R23
    02ED E022      LDI	R18,2
    02EE 2700      CLR	R16
    02EF D124      RCALL	_log
(0184)                 password_handle_ok();
    02F0 DF23      RCALL	_password_handle_ok
(0185)                 screen_on_pinHigh();
    02F1 D172      RCALL	_screen_on_pinHigh
(0186) 				return;
    02F2 C062      RJMP	0x0355
(0187)             }
(0188)             else if(item.flags==(PASSWORDFLAGS_ID|PASSWORDFLAGS_PASSWORD))
    02F3 858C      LDD	R24,Y+12
    02F4 3083      CPI	R24,3
    02F5 F009      BEQ	0x02F7
    02F6 C04D      RJMP	0x0344
(0189)             {
(0190)                 if((type==IDREADEDIDCARD)&&(item.idCard==code))
    02F7 2D8E      MOV	R24,R14
    02F8 3081      CPI	R24,1
    02F9 F4D1      BNE	0x0314
    02FA 940E08AF  CALL	0x8AF
    02FC 01FE      MOVW	R30,R28
    02FD 8465      LDD	R6,Z+13
    02FE 8476      LDD	R7,Z+14
    02FF 8487      LDD	R8,Z+15
    0300 8890      LDD	R9,Z+16
    0301 940E0898  CALL	0x898
    0303 F481      BNE	0x0314
(0191)                 {
(0192)                     //id card ok, but need password.
(0193)                     //tips_id_ok();
(0194)                     //id card ok, but not input password, led on.
(0195)                     tips_led_on();
    0304 DE43      RCALL	_tips_led_on
    0305 940E08AF  CALL	0x8AF
(0196)                     current_id = code;
    0307 9230006A  STS	current_id+1,R3
    0309 92200069  STS	current_id,R2
    030B 9250006C  STS	current_id+3,R5
    030D 9240006B  STS	current_id+2,R4
    030F 940E0943  CALL	0x943
(0197)                     //set time out. 100ms*10*30
(0198)                     set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    0311 D05B      RCALL	_set_timer
(0199)                     screen_on_pinHigh();
    0312 D151      RCALL	_screen_on_pinHigh
(0200) 					return;
    0313 C041      RJMP	0x0355
(0201)                 }
(0202)                 else if((type==IDREADEDKEYPAD)&&(current_id==item.idCard)&&
    0314 2D8E      MOV	R24,R14
    0315 3082      CPI	R24,2
    0316 F009      BEQ	0x0318
    0317 C02C      RJMP	0x0344
    0318 01FE      MOVW	R30,R28
    0319 8425      LDD	R2,Z+13
    031A 8436      LDD	R3,Z+14
    031B 8447      LDD	R4,Z+15
    031C 8850      LDD	R5,Z+16
    031D 9080006B  LDS	R8,current_id+2
    031F 9090006C  LDS	R9,current_id+3
    0321 90600069  LDS	R6,current_id
    0323 9070006A  LDS	R7,current_id+1
    0325 940E0898  CALL	0x898
    0327 F009      BEQ	0x0329
    0328 C01B      RJMP	0x0344
    0329 940E0871  CALL	0x871
    032B 01FE      MOVW	R30,R28
    032C 8861      LDD	R6,Z+17
    032D 8872      LDD	R7,Z+18
    032E 8883      LDD	R8,Z+19
    032F 8894      LDD	R9,Z+20
    0330 940E0898  CALL	0x898
    0332 F489      BNE	0x0344
    0333 940E08B5  CALL	0x8B5
    0335 01FE      MOVW	R30,R28
    0336 8865      LDD	R6,Z+21
    0337 8876      LDD	R7,Z+22
    0338 8887      LDD	R8,Z+23
    0339 8C90      LDD	R9,Z+24
    033A 940E0898  CALL	0x898
    033C F439      BNE	0x0344
    033D 940E0848  CALL	0x848
(0203)                     (item.passwordH==passwordH)&&(item.passwordL==passwordL))
(0204)                 {
(0205)                     log(COMMANDIDLOGOK, PASSWORDFLAGS_ID|PASSWORDFLAGS_PASSWORD, item.idCard, passwordH, passwordL);
    033F 2700      CLR	R16
    0340 D0D3      RCALL	_log
(0206)                     password_handle_ok();
    0341 DED2      RCALL	_password_handle_ok
(0207)                     screen_on_pinHigh();
    0342 D121      RCALL	_screen_on_pinHigh
(0208) 					return;
    0343 C011      RJMP	0x0355
    0344 94C3      INC	R12
    0345 14CA      CP	R12,R10
    0346 F408      BCC	0x0348
    0347 CF46      RJMP	0x028E
(0209)                 }
(0210)             }
(0211)         }
(0212)         ++input_err_count;
    0348 9180006D  LDS	R24,input_err_count
    034A 5F8F      SUBI	R24,0xFF
    034B 9380006D  STS	input_err_count,R24
    034D 940E08B5  CALL	0x8B5
    034F 940E0848  CALL	0x848
(0213)         log(COMMANDIDLOGERR, PASSWORDFLAGS_ID|PASSWORDFLAGS_PASSWORD, item.idCard, passwordH, passwordL);
    0351 E001      LDI	R16,1
    0352 D0C1      RCALL	_log
(0214)         password_handle_err();
    0353 DEBD      RCALL	_password_handle_err
(0215)     }
(0216)     screen_on_pinHigh();
    0354 D10F      RCALL	_screen_on_pinHigh
(0217) 	return;
    0355 9669      ADIW	R28,0x19
    0356 D42E      RCALL	pop_gset5
    0357 9622      ADIW	R28,2
    0358 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\timer.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "timer.h"
(0005) 
(0006) void timer_init(void)
(0007) {
(0008)     //enable interrupt.
(0009)     //SREG |= 0x80;
(0010)     //timer0 normal mode.ck/1024.
(0011)     TCCR0 |= 0x05;
_timer_init:
    0359 B783      IN	R24,0x33
    035A 6085      ORI	R24,5
    035B BF83      OUT	0x33,R24
(0012)     //init TCNT0.
(0013)     TCNT0 = 1;
    035C E081      LDI	R24,1
    035D BF82      OUT	0x32,R24
(0014)     //TIMSK
(0015)     //TIMSK |= 0x01;
(0016)     return; 
    035E 9508      RET
(0017) }
(0018) //cpu timer0 start
(0019) static void t0_start(void)
(0020) {
(0021) 	CLI();	
_t0_start:
    035F 94F8      BCLR	7
(0022)     TCNT0 = 1;
    0360 E081      LDI	R24,1
    0361 BF82      OUT	0x32,R24
(0023)     TIMSK |= 0x01;
    0362 B789      IN	R24,0x39
    0363 6081      ORI	R24,1
    0364 BF89      OUT	0x39,R24
(0024) 	SEI();
    0365 9478      BSET	7
(0025) 	return;
    0366 9508      RET
(0026) }
(0027) //cpu timer0 stop
(0028) static void t0_stop(void)
(0029) {
(0030) 	CLI();
_t0_stop:
    0367 94F8      BCLR	7
(0031)     TIMSK &= 0xfe;
    0368 B789      IN	R24,0x39
    0369 7F8E      ANDI	R24,0xFE
    036A BF89      OUT	0x39,R24
(0032) 	SEI();
    036B 9478      BSET	7
(0033)     return;
    036C 9508      RET
_set_timer:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    036D D41F      RCALL	push_gset2
    036E 01B9      MOVW	R22,R18
    036F 2F40      MOV	R20,R16
    0370 940E0840  CALL	0x840
(0034) }
(0035) //
(0036) static timer_t g_timer[MAXTIMER];
(0037) //set timer and start timer. set value 0, need wait a cpu timer pice.
(0038) void set_timer(char timer, int value, timerCB cb)
(0039) {
(0040)     //value=0, stoped timer.
(0041)     g_timer[timer].value = value+1;
    0372 01CB      MOVW	R24,R22
    0373 9601      ADIW	R24,1
    0374 8391      STD	Z+1,R25
    0375 8380      STD	Z+0,R24
    0376 940E08C7  CALL	0x8C7
(0042)     g_timer[timer].cb = cb;
    0378 800C      LDD	R0,Y+4
    0379 801D      LDD	R1,Y+5
    037A 8211      STD	Z+1,R1
    037B 8200      STD	Z+0,R0
    037C 940E0840  CALL	0x840
(0043)     if(g_timer[timer].value)
    037E 8020      LDD	R2,Z+0
    037F 8031      LDD	R3,Z+1
    0380 2022      TST	R2
    0381 F411      BNE	0x0384
    0382 2033      TST	R3
    0383 F009      BEQ	0x0385
(0044)         t0_start();
    0384 DFDA      RCALL	_t0_start
(0045)     return;
    0385 D3F9      RCALL	pop_gset2
    0386 9508      RET
(0046) }
(0047) //stop timer and clean timer.
(0048) void stop_timer(char timer)
(0049) {
(0050)     if(g_timer[timer].value)
_stop_timer:
  timer                --> R16
    0387 E084      LDI	R24,4
    0388 9F80      MUL	R24,R16
    0389 940E0863  CALL	0x863
    038B 8020      LDD	R2,Z+0
    038C 8031      LDD	R3,Z+1
    038D 2022      TST	R2
    038E F411      BNE	0x0391
    038F 2033      TST	R3
    0390 F071      BEQ	0x039F
(0051)     {
(0052)         //stop this timer.
(0053)         g_timer[timer].value = 0;
    0391 E084      LDI	R24,4
    0392 9F80      MUL	R24,R16
    0393 940E0863  CALL	0x863
    0395 940E0984  CALL	0x984
(0054)         g_timer[timer].cb = 0;
    0397 9F80      MUL	R24,R16
    0398 01F0      MOVW	R30,R0
    0399 E78A      LDI	R24,0x7A
    039A E090      LDI	R25,0
    039B 0FE8      ADD	R30,R24
    039C 1FF9      ADC	R31,R25
    039D 8231      STD	Z+1,R3
    039E 8220      STD	Z+0,R2
(0055)     }
(0056)     return;
    039F 9508      RET
_set_timer2:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    03A0 D3EC      RCALL	push_gset2
    03A1 01B9      MOVW	R22,R18
    03A2 2F40      MOV	R20,R16
    03A3 940E0840  CALL	0x840
(0057) }
(0058) 
(0059) void set_timer2(char timer, int value, timerCB cb)
(0060) {
(0061) 	if(g_timer[timer].value==0)
    03A5 8020      LDD	R2,Z+0
    03A6 8031      LDD	R3,Z+1
    03A7 2022      TST	R2
    03A8 F4B9      BNE	0x03C0
    03A9 2033      TST	R3
    03AA F4A9      BNE	0x03C0
    03AB 940E0840  CALL	0x840
(0062) 	{
(0063) 	    //value=0, stoped timer.
(0064) 	    g_timer[timer].value = value+1;
    03AD 01CB      MOVW	R24,R22
    03AE 9601      ADIW	R24,1
    03AF 8391      STD	Z+1,R25
    03B0 8380      STD	Z+0,R24
    03B1 940E08C7  CALL	0x8C7
(0065) 	    g_timer[timer].cb = cb;
    03B3 800C      LDD	R0,Y+4
    03B4 801D      LDD	R1,Y+5
    03B5 8211      STD	Z+1,R1
    03B6 8200      STD	Z+0,R0
    03B7 940E0840  CALL	0x840
(0066) 	    if(g_timer[timer].value)
    03B9 8020      LDD	R2,Z+0
    03BA 8031      LDD	R3,Z+1
    03BB 2022      TST	R2
    03BC F411      BNE	0x03BF
    03BD 2033      TST	R3
    03BE F009      BEQ	0x03C0
(0067) 	        t0_start();
    03BF DF9F      RCALL	_t0_start
(0068) 	}
(0069)     return;
    03C0 D3BE      RCALL	pop_gset2
    03C1 9508      RET
_timer0_isr:
  i                    --> R20
    03C2 D411      RCALL	push_lset
    03C3 D3CB      RCALL	push_gset1
(0070) }
(0071) static char running_timer_count = 0;
(0072) //timer spank.
(0073) #pragma interrupt_handler timer0_isr:10
(0074) void timer0_isr(void)
(0075) {
(0076)     //static char time_pices = 0;
(0077)     TCNT0 = 1;
    03C4 E081      LDI	R24,1
    03C5 BF82      OUT	0x32,R24
(0078)     //++time_pices;
(0079)     //200ms.
(0080)     //if(time_pices == 2)
(0081)     {
(0082)         char i;
(0083) 
(0084) 		running_timer_count = 0;
    03C6 2422      CLR	R2
    03C7 92200076  STS	running_timer_count,R2
(0085)         for(i=0;i<MAXTIMER;i++)
    03C9 2744      CLR	R20
    03CA C03E      RJMP	0x0409
(0086)         {
(0087) 			CLI();
    03CB 94F8      BCLR	7
    03CC 940E0840  CALL	0x840
(0088)             if(g_timer[i].value>1)
    03CE 8020      LDD	R2,Z+0
    03CF 8031      LDD	R3,Z+1
    03D0 E081      LDI	R24,1
    03D1 E090      LDI	R25,0
    03D2 1582      CP	R24,R2
    03D3 0593      CPC	R25,R3
    03D4 F498      BCC	0x03E8
(0089)             {
(0090)                 --(g_timer[i].value);
    03D5 E084      LDI	R24,4
    03D6 9F84      MUL	R24,R20
    03D7 0110      MOVW	R2,R0
    03D8 E788      LDI	R24,0x78
    03D9 E090      LDI	R25,0
    03DA 0E28      ADD	R2,R24
    03DB 1E39      ADC	R3,R25
    03DC 01F1      MOVW	R30,R2
    03DD 8180      LDD	R24,Z+0
    03DE 8191      LDD	R25,Z+1
    03DF 9701      SBIW	R24,1
    03E0 8391      STD	Z+1,R25
    03E1 8380      STD	Z+0,R24
(0091)                 ++running_timer_count;
    03E2 91800076  LDS	R24,running_timer_count
    03E4 5F8F      SUBI	R24,0xFF
    03E5 93800076  STS	running_timer_count,R24
(0092)             }
    03E7 C01F      RJMP	0x0407
(0093)             //timer call back.
(0094)             else if(g_timer[i].value==1)
    03E8 940E0840  CALL	0x840
    03EA 8180      LDD	R24,Z+0
    03EB 8191      LDD	R25,Z+1
    03EC 3081      CPI	R24,1
    03ED E0E0      LDI	R30,0
    03EE 079E      CPC	R25,R30
    03EF F4B9      BNE	0x0407
    03F0 940E0840  CALL	0x840
    03F2 940E0984  CALL	0x984
(0095)             {
(0096)                 g_timer[i].value = 0;
(0097)                 if(g_timer[i].cb)
    03F4 9F84      MUL	R24,R20
    03F5 01F0      MOVW	R30,R0
    03F6 E78A      LDI	R24,0x7A
    03F7 E090      LDI	R25,0
    03F8 0FE8      ADD	R30,R24
    03F9 1FF9      ADC	R31,R25
    03FA 8020      LDD	R2,Z+0
    03FB 8031      LDD	R3,Z+1
    03FC 2022      TST	R2
    03FD F411      BNE	0x0400
    03FE 2033      TST	R3
    03FF F039      BEQ	0x0407
(0098)                     (g_timer[i].cb)(i);
    0400 2F04      MOV	R16,R20
    0401 940E08C7  CALL	0x8C7
    0403 81A0      LDD	R26,Z+0
    0404 81B1      LDD	R27,Z+1
    0405 01FD      MOVW	R30,R26
    0406 D39F      RCALL	xicall
(0099)             }
(0100) 			SEI();
    0407 9478      BSET	7
    0408 9543      INC	R20
    0409 3044      CPI	R20,4
    040A F408      BCC	0x040C
    040B CFBF      RJMP	0x03CB
(0101)         }
(0102)         //time_pices = 0;
(0103)         //if no timer running, stop cpu timer.
(0104)         if(0==running_timer_count) t0_stop();
    040C 90200076  LDS	R2,running_timer_count
    040E 2022      TST	R2
    040F F409      BNE	0x0411
    0410 DF56      RCALL	_t0_stop
(0105)     }
(0106)     return;
    0411 D380      RCALL	pop_gset1
    0412 D3D4      RCALL	pop_lset
    0413 9518      RETI
_log:
  pswdL                --> Y+12
  pswdH                --> Y+8
  id_code              --> Y+4
  msgType              --> R20
  comId                --> R22
    0414 D378      RCALL	push_gset2
    0415 2F42      MOV	R20,R18
    0416 2F60      MOV	R22,R16
FILE: D:\smarthome\smarthome\门禁系统资料\code\log.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "uart.h"
(0004) #include "log.h"
(0005) 
(0006) /**
(0007) ok log                             0                             id&card                     x                            x                          x
(0008) err log                            1                             id&card                     x                            x                          x
(0009) */
(0010) 
(0011) void log(unsigned char comId, unsigned char msgType, unsigned long id_code, unsigned long pswdH, unsigned long pswdL)
(0012) {
(0013)     uart0_send(comId);
    0417 2F06      MOV	R16,R22
    0418 D075      RCALL	_uart0_send
(0014)     uart0_send(msgType);
    0419 2F04      MOV	R16,R20
    041A D073      RCALL	_uart0_send
    041B 940E0968  CALL	0x968
(0015)     uart0_send_buffer((unsigned char*)(&id_code), 4);
    041D D078      RCALL	_uart0_send_buffer
    041E 940E0963  CALL	0x963
(0016)     uart0_send_buffer((unsigned char*)(&pswdH), 4);
    0420 D075      RCALL	_uart0_send_buffer
    0421 940E094B  CALL	0x94B
(0017)     uart0_send_buffer((unsigned char*)(&pswdL), 4);
    0423 D072      RCALL	_uart0_send_buffer
(0018)     return;
    0424 D35A      RCALL	pop_gset2
    0425 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\locker.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "timer.h"
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "locker.h"
(0007) 
(0008) #define LOCKERINIT (PORTB&=0xe7)
(0009) #define LOCKERUNLOCK (PORTB&=0xf7,PORTB|=0x10)
(0010) #define LOCKERLOCK (PORTB&=0xef,PORTB|=0x08)
(0011) 
(0012) void locker_init(void)
(0013) {
(0014)     //pb3 pb4 OUTPUT.
(0015)     DDRB |= 0x18;
_locker_init:
    0426 B387      IN	R24,0x17
    0427 6188      ORI	R24,0x18
    0428 BB87      OUT	0x17,R24
(0016)     //output low
(0017)     PORTB &= 0xe7;
    0429 B388      IN	R24,0x18
    042A 7E87      ANDI	R24,0xE7
    042B BB88      OUT	0x18,R24
(0018)     return;
    042C 9508      RET
_unlock_time_out:
  timer                --> R20
    042D D361      RCALL	push_gset1
    042E 2F40      MOV	R20,R16
(0019) }
(0020) 
(0021) //unlock timeout.
(0022) static void unlock_time_out(char timer)
(0023) {
(0024)     if(timer==UNLOCKTIMEOUTTIMER)
    042F 3042      CPI	R20,2
    0430 F459      BNE	0x043C
(0025)     {
(0026) 		LOCKERLOCK;
    0431 B388      IN	R24,0x18
    0432 7E8F      ANDI	R24,0xEF
    0433 BB88      OUT	0x18,R24
    0434 9AC3      SBI	0x18,3
(0027) 		delay_ms(400);
    0435 E900      LDI	R16,0x90
    0436 E011      LDI	R17,1
    0437 DCFA      RCALL	_delay_ms
(0028) 		LOCKERINIT;
    0438 B388      IN	R24,0x18
    0439 7E87      ANDI	R24,0xE7
    043A BB88      OUT	0x18,R24
(0029) 		tips_board_led_off();
    043B DD36      RCALL	_tips_board_led_off
(0030) 	}
(0031)     return;
    043C D355      RCALL	pop_gset1
    043D 9508      RET
_locker_unlock:
    043E 9722      SBIW	R28,2
(0032) }
(0033) 
(0034) void locker_unlock(void)
(0035) {
(0036) 	LOCKERUNLOCK;	
    043F B388      IN	R24,0x18
    0440 7F87      ANDI	R24,0xF7
    0441 BB88      OUT	0x18,R24
    0442 9AC4      SBI	0x18,4
(0037)     delay_ms(400);
    0443 E900      LDI	R16,0x90
    0444 E011      LDI	R17,1
    0445 DCEC      RCALL	_delay_ms
(0038) 	LOCKERINIT;
    0446 B388      IN	R24,0x18
    0447 7E87      ANDI	R24,0xE7
    0448 BB88      OUT	0x18,R24
(0039) 	//set time out. 
(0040) 	set_timer(UNLOCKTIMEOUTTIMER, 100, unlock_time_out);
    0449 E58A      LDI	R24,0x5A
    044A E090      LDI	R25,0
    044B 8399      STD	Y+1,R25
    044C 8388      STD	Y+0,R24
    044D E624      LDI	R18,0x64
    044E E030      LDI	R19,0
    044F E002      LDI	R16,2
    0450 DF1C      RCALL	_set_timer
(0041) 	tips_board_led_on();
    0451 DD1C      RCALL	_tips_board_led_on
(0042) 	return;
    0452 9622      ADIW	R28,2
    0453 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\ringandscreen.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "timer.h"
(0007) #include "ringandscreen.h"
(0008) 
(0009) //door monitor input is pa0.
(0010) //screen power output pb2.
(0011) 
(0012) #define SCREEN_ON (PORTB &= 0xfb)
(0013) #define SCREEN_OFF (PORTB |= 0x04)
(0014) 
(0015) void doorandscreen_init(void)
(0016) {
(0017)     //PA0 INPUT.
(0018)     DDRA &= 0xfe;
_doorandscreen_init:
    0454 B38A      IN	R24,0x1A
    0455 7F8E      ANDI	R24,0xFE
    0456 BB8A      OUT	0x1A,R24
(0019) 	PORTA |= 0x01;
    0457 9AD8      SBI	0x1B,0
(0020)     //pb2 hi-z
(0021)     DDRB &= 0xfb;
    0458 B387      IN	R24,0x17
    0459 7F8B      ANDI	R24,0xFB
    045A BB87      OUT	0x17,R24
(0022)     PORTB &= 0xfb;
    045B B388      IN	R24,0x18
    045C 7F8B      ANDI	R24,0xFB
    045D BB88      OUT	0x18,R24
(0023)     //init interrput.
(0024)     return;
    045E 9508      RET
(0025) }
(0026) 
(0027) /**
(0028) #define SCREEN_RESET_START (PORTC&=0xef)
(0029) #define SCREEN_RESET_STOP (PORTC|=0x10)
(0030) #define RING_ON (PORTC&=0xdf)
(0031) #define RING_OFF (PORTC&=0x20)
(0032) 
(0033) void ringandscreen_init(void)
(0034) {
(0035)     //PC0,PC1,PC2 INPUT.
(0036)     DDRC &= 0xf8;
(0037)     //PC3,PC4,PC5 OUTPUT.
(0038)     DDRC |= 0x38;
(0039)     //
(0040)     PORTC = 0xff;
(0041)     //init interrput.
(0042)     return;
(0043) }
(0044) 
(0045) static void disable_input(void)
(0046) {
(0047) 
(0048) }
(0049) 
(0050) static void enable_input(void)
(0051) {
(0052) 
(0053) }
(0054) 
(0055) void screen_on(void)
(0056) {
(0057)     if((PORTC&=0x04))
(0058)     {
(0059)         SCREEN_ON;
(0060)         delay_ms(500);
(0061)         SCREEN_RESET_START;
(0062)         delay_ms(100);
(0063)         SCREEN_RESET_STOP;
(0064)     }
(0065)     return;
(0066) }
(0067) 
(0068) void screen_off(void)
(0069) {
(0070)     SCREEN_OFF;
(0071)     return;
(0072) }
(0073) 
(0074) void ring_on(void)
(0075) {
(0076)     RING_ON;
(0077)     delay_ms(20);
(0078)     RING_OFF;
(0079)     return;
(0080) }
(0081) 
(0082) void ring_screen_timeout(char timer)
(0083) {
(0084)     if(timer==RINGANDSCREENINPUTTIMER)
(0085)     {
(0086)         screen_off();
(0087)     }
(0088) }
(0089) 
(0090) void door_minitor_timeout(char timer)
(0091) {
(0092)     if(timer==RINGANDSCREENINPUTTIMER)
(0093)     {
(0094)         tips_err();
(0095)         //start timer. 10s.
(0096)         set_timer(RINGANDSCREENINPUTTIMER, 140, door_minitor_timeout); 
(0097)     }
(0098) }
(0099) 
(0100) void input_isr(void)
(0101) {
(0102)     disable_input();
(0103)     //
(0104)     delay_ms(100);
(0105)     if(!(PINC&0x01)) //ring input.
(0106)     {
(0107)         screen_on();
(0108)         ring_on();
(0109)         tips_ring_on();
(0110)         //start timer. 50s.
(0111)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0112)     }
(0113)     else if(!(PIND&0x02)) //screen key input.
(0114)     {
(0115)         screen_on();
(0116)         delay_ms(800);
(0117)         //start timer. 50s.
(0118)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0119)     }
(0120)     enable_input();
(0121)     return;
(0122) }
(0123) **/
(0124) 
(0125) void screen_on_pinLow(void)
(0126) {
(0127)     //pb2 OUTPUT.
(0128)     DDRB |= 0x04;
_screen_on_pinLow:
    045F 9ABA      SBI	0x17,2
(0129)     SCREEN_ON;
    0460 B388      IN	R24,0x18
    0461 7F8B      ANDI	R24,0xFB
    0462 BB88      OUT	0x18,R24
(0130)     return;
    0463 9508      RET
(0131) }
(0132) 
(0133) void screen_on_pinHigh(void)
(0134) {
(0135) 	SCREEN_OFF;
_screen_on_pinHigh:
    0464 9AC2      SBI	0x18,2
(0136)     //pb2 hi-z
(0137)     DDRB &= 0xfb;
    0465 B387      IN	R24,0x17
    0466 7F8B      ANDI	R24,0xFB
    0467 BB87      OUT	0x17,R24
(0138)     PORTB &= 0xfb;
    0468 B388      IN	R24,0x18
    0469 7F8B      ANDI	R24,0xFB
    046A BB88      OUT	0x18,R24
(0139)     return;
    046B 9508      RET
_rw24c256:
  rwFlag               --> Y+11
  addr                 --> Y+9
  len                  --> R22
  data                 --> R20
    046C D320      RCALL	push_gset2
    046D 2F62      MOV	R22,R18
    046E 01A8      MOVW	R20,R16
    046F 9725      SBIW	R28,5
FILE: D:\smarthome\smarthome\门禁系统资料\code\eeprom.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "iic.h"
(0006) #include "eeprom.h"
(0007) 
(0008) /* 一个通用的24C01－24C256共9种EEPROM的字节读写操作程序，   
(0009) 此程序有五个入口条件，分别为读写数据缓冲区指针,   
(0010) 进行读写的字节数，EEPROM首址，EEPROM控制字节，   
(0011) 以及EEPROM类型。此程序结构性良好，具有极好的容错性，程序机器码也不多:   
(0012) DataBuff为读写数据输入／输出缓冲区的首址   
(0013) Length 为要读写数据的字节数量   
(0014) Addr 为EEPROM的片内地址 AT24256为0～32767   
(0015) Control 为EEPROM的控制字节，具体形式为(1)(0)(1)(0)(A2)(A1)(A0)(R/W),其中R/W=1,   
(0016) 表示读操作,R/W=0为写操作,A2,A1,A0为EEPROM的页选或片选地址;   
(0017) enumer为枚举变量,需为AT2401至AT24256中的一种,分别对应AT24C01至AT24C256;   
(0018) 函数返回值为一个位变量，若返回1表示此次操作失效，0表示操作成功;   
(0019) ERROR为允许最大次数，若出现ERRORCOUNT次操作失效后，则函数中止操作，并返回1   
(0020) SDA和SCL由用户自定义，这里暂定义为P3^0和P3^1; */   
(0021) /*对于1K位，2K位，4K位，8K位，16K位芯片采用一个8位长的字节地址码，对于32K位以上   
(0022) 的采用2个8位长的字节地址码直接寻址，而4K位，8K位，16K位配合页面地址来寻址*/   
(0023)    
(0024) /* －－－－－  AT24C01～AT24C256 的读写程序 －－－－－－ */
(0025) 
(0026) #define AT24C256DEVADDR 0xa0
(0027) 
(0028) char rw24c256(unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)
(0029) {
(0030)     return rwiic(AT24C256DEVADDR, data, len, addr, rwFlag);
    0470 840B      LDD	R0,Y+11
    0471 820C      STD	Y+4,R0
    0472 8409      LDD	R0,Y+9
    0473 841A      LDD	R1,Y+10
    0474 821B      STD	Y+3,R1
    0475 820A      STD	Y+2,R0
    0476 8368      STD	Y+0,R22
    0477 019A      MOVW	R18,R20
    0478 EA00      LDI	R16,0xA0
    0479 D271      RCALL	_rwiic
    047A 9625      ADIW	R28,5
    047B D303      RCALL	pop_gset2
    047C 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\uart.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "password.h"
(0005) #include "locker.h"
(0006) #include "timer.h"
(0007) #include "uart.h"
(0008) 
(0009) //uart0 init. for printf.
(0010) void uart0_init(void)
(0011) {
(0012) 	//port init pd0(rx) input pd1(tx) hi-z
(0013) 	DDRD &= 0xfc;
_uart0_init:
    047D 940E095C  CALL	0x95C
(0014) 	PORTD &= 0xfc;
(0015) 	//uart init
(0016)     UCSRB = 0x00;                //禁止UART发送和接收
    047F 2422      CLR	R2
    0480 B82A      OUT	0x0A,R2
(0017)     UCSRA = 0x02;               //倍速
    0481 E082      LDI	R24,2
    0482 B98B      OUT	0x0B,R24
(0018)     UCSRC = 0x06;                //8位数据
    0483 E086      LDI	R24,6
    0484 BD80      OUT	0x20,R24
(0019)     UBRRL = 0x67;                 //9600bps
    0485 E687      LDI	R24,0x67
    0486 B989      OUT	0x09,R24
(0020)     UBRRH = 0x00;
    0487 BC20      OUT	0x20,R2
(0021)     UCSRB = 0x98;
    0488 E988      LDI	R24,0x98
    0489 B98A      OUT	0x0A,R24
    048A 9508      RET
(0022) }
(0023) 
(0024) void uart0_port_hiz(void)
(0025) {
(0026) 	//port init pd0(rx) input pd1(tx) hi-z
(0027) 	DDRD &= 0xfc;
_uart0_port_hiz:
    048B 940E095C  CALL	0x95C
(0028) 	PORTD &= 0xfc;
    048D 9508      RET
(0029) }
(0030) 
(0031) //uart0 send char.
(0032) void uart0_send(unsigned char i)
(0033) {
(0034)     while(!(UCSRA&(1<<UDRE)));
_uart0_send:
  i                    --> R16
    048E 9B5D      SBIS	0x0B,5
    048F CFFE      RJMP	_uart0_send
(0035)     UDR = i;
    0490 B90C      OUT	0x0C,R16
    0491 9508      RET
(0036) }
(0037) 
(0038) //uart0 receive.
(0039) unsigned char uart0_receive(void)
(0040) {
(0041)     while(!(UCSRA&(1<<RXC)));
_uart0_receive:
    0492 9B5F      SBIS	0x0B,7
    0493 CFFE      RJMP	_uart0_receive
(0042)     return UDR;
    0494 B10C      IN	R16,0x0C
    0495 9508      RET
_uart0_send_buffer:
  i                    --> R20
  len                  --> R22
  buffer               --> R10
    0496 D2F4      RCALL	push_gset3
    0497 2F62      MOV	R22,R18
    0498 0158      MOVW	R10,R16
(0043) }
(0044) 
(0045) //uart0 send buffer
(0046) void uart0_send_buffer(unsigned char* buffer, unsigned char len)
(0047) {
(0048)     unsigned char i;
(0049)     for(i=0;i<len;++i)
    0499 2744      CLR	R20
    049A C005      RJMP	0x04A0
(0050)     {
(0051)         uart0_send(buffer[i]);
    049B 940E09A3  CALL	0x9A3
    049D 8100      LDD	R16,Z+0
    049E DFEF      RCALL	_uart0_send
    049F 9543      INC	R20
    04A0 1746      CP	R20,R22
    04A1 F3C8      BCS	0x049B
(0052)     }
(0053) 	uart0_port_hiz();
    04A2 DFE8      RCALL	_uart0_port_hiz
(0054)     return;
    04A3 D2DD      RCALL	pop_gset3
    04A4 9508      RET
_uart0_read_buffer:
  i                    --> R20
  len                  --> R22
  buffer               --> R10
    04A5 D2E5      RCALL	push_gset3
    04A6 2F62      MOV	R22,R18
    04A7 0158      MOVW	R10,R16
(0055) }
(0056) //uart0 send buffer
(0057) unsigned char uart0_read_buffer(unsigned char* buffer, unsigned char len)
(0058) {
(0059)     unsigned char i;
(0060)     for(i=0;i<len;++i)
    04A8 2744      CLR	R20
    04A9 C005      RJMP	0x04AF
(0061)     {
(0062)         buffer[i] = uart0_receive();
    04AA DFE7      RCALL	_uart0_receive
    04AB 940E09A3  CALL	0x9A3
    04AD 8300      STD	Z+0,R16
    04AE 9543      INC	R20
    04AF 1746      CP	R20,R22
    04B0 F3C8      BCS	0x04AA
(0063)     }
(0064)     return len;
    04B1 2F06      MOV	R16,R22
    04B2 D2CE      RCALL	pop_gset3
    04B3 9508      RET
_uart0_returnCommd:
  passwordL            --> Y+12
  passwordH            --> Y+8
  idCard               --> Y+4
  type                 --> R20
  commId               --> R22
    04B4 D2D8      RCALL	push_gset2
    04B5 2F42      MOV	R20,R18
    04B6 2F60      MOV	R22,R16
(0065) }
(0066) 
(0067) static void uart0_returnCommd(unsigned char commId, unsigned char type,
(0068)     unsigned long idCard, unsigned long passwordH, unsigned long passwordL)
(0069) {
(0070)     uart0_send(commId);
    04B7 2F06      MOV	R16,R22
    04B8 DFD5      RCALL	_uart0_send
(0071)     uart0_send(type);
    04B9 2F04      MOV	R16,R20
    04BA DFD3      RCALL	_uart0_send
    04BB 940E0968  CALL	0x968
(0072)     uart0_send_buffer((unsigned char*)(&idCard), 4);
    04BD DFD8      RCALL	_uart0_send_buffer
    04BE 940E0963  CALL	0x963
(0073)     uart0_send_buffer((unsigned char*)(&passwordH), 4);
    04C0 DFD5      RCALL	_uart0_send_buffer
    04C1 940E094B  CALL	0x94B
(0074)     uart0_send_buffer((unsigned char*)(&passwordL), 4);
    04C3 DFD2      RCALL	_uart0_send_buffer
(0075)     return;    
    04C4 D2BA      RCALL	pop_gset2
    04C5 9508      RET
_uart0_handle_timeout:
  timer                --> R20
    04C6 D2C8      RCALL	push_gset1
    04C7 2F40      MOV	R20,R16
(0076) }
(0077) 
(0078) #define COMMANDITEMLENGTH	14
(0079) static void uart0_handle_command(void);
(0080) static char commandBuffer[COMMANDITEMLENGTH];
(0081) static char commandRecCount = 0;
(0082) 
(0083) static void uart0_handle_timeout(char timer)
(0084) {
(0085) 	if((timer==UART0RECTIMEOUTTIMER)&&(commandRecCount==COMMANDITEMLENGTH))
    04C8 3043      CPI	R20,3
    04C9 F429      BNE	0x04CF
    04CA 91800077  LDS	R24,commandRecCount
    04CC 308E      CPI	R24,0xE
    04CD F409      BNE	0x04CF
(0086) 		uart0_handle_command();
    04CE D02B      RCALL	_uart0_handle_command
(0087) 	commandRecCount = 0;
    04CF 2422      CLR	R2
    04D0 92200077  STS	commandRecCount,R2
(0088) 	return;
    04D2 D2BF      RCALL	pop_gset1
    04D3 9508      RET
_uart0_handleCommand_isr:
    04D4 D2FF      RCALL	push_lset
    04D5 9722      SBIW	R28,2
(0089) }
(0090) 
(0091) #pragma interrupt_handler uart0_handleCommand_isr:12
(0092) void uart0_handleCommand_isr(void)
(0093) {
(0094) 	if(commandRecCount<14) commandBuffer[commandRecCount++] = uart0_receive();
    04D6 91800077  LDS	R24,commandRecCount
    04D8 308E      CPI	R24,0xE
    04D9 F490      BCC	0x04EC
    04DA 2E28      MOV	R2,R24
    04DB 2433      CLR	R3
    04DC 5F8F      SUBI	R24,0xFF
    04DD 93800077  STS	commandRecCount,R24
    04DF 922F      PUSH	R2
    04E0 923F      PUSH	R3
    04E1 DFB0      RCALL	_uart0_receive
    04E2 903F      POP	R3
    04E3 902F      POP	R2
    04E4 E888      LDI	R24,0x88
    04E5 E090      LDI	R25,0
    04E6 2DE2      MOV	R30,R2
    04E7 27FF      CLR	R31
    04E8 0FE8      ADD	R30,R24
    04E9 1FF9      ADC	R31,R25
    04EA 8300      STD	Z+0,R16
    04EB C006      RJMP	0x04F2
(0095) 	else
(0096) 	{
(0097) 		uart0_receive();
    04EC DFA5      RCALL	_uart0_receive
(0098) 		++commandRecCount;
    04ED 91800077  LDS	R24,commandRecCount
    04EF 5F8F      SUBI	R24,0xFF
    04F0 93800077  STS	commandRecCount,R24
(0099) 	}
(0100) 	//set time out. 
(0101) 	set_timer2(UART0RECTIMEOUTTIMER, 2, uart0_handle_timeout);
    04F2 E58C      LDI	R24,0x5C
    04F3 940E0972  CALL	0x972
    04F5 E003      LDI	R16,3
    04F6 DEA9      RCALL	_set_timer2
    04F7 9622      ADIW	R28,2
    04F8 D2EE      RCALL	pop_lset
    04F9 9518      RETI
_uart0_handle_command:
  item                 --> Y+24
  item                 --> Y+24
  itemNum              --> R12
  itemNum              --> R12
  item                 --> Y+24
  itemNum              --> R12
  passwordL            --> Y+20
  passwordH            --> Y+16
  idCard               --> Y+12
  type                 --> R10
  comId                --> R12
    04FA D28E      RCALL	push_gset4
    04FB 97E2      SBIW	R28,0x32
(0102) }
(0103) 
(0104) #define u32 unsigned long
(0105) #define u8 unsigned char
(0106) 
(0107) #define Read32(h2, h1, l2, l1) ((u32)(((((u32)h2)&0xff)<<24)|((((u32)h1)&0xff)<<16)|((((u32)l2)&0xff)<<8)|(l1)))
(0108) //#define Read32(h2, h1, l2, l1) ((u32)((24<<(((u32)(h2))&0xff))|(16<<((u32(h1))&0xff))|(16<<((u32(l2))&0xff))|(l1)))
(0109) static void uart0_handle_command(void)
(0110) {
(0111)     unsigned char comId = 0;
    04FC 24CC      CLR	R12
(0112)     unsigned char type = 0;
    04FD 24AA      CLR	R10
    04FE 940E083B  CALL	0x83B
(0113)     unsigned long idCard = 0;
    0500 01FE      MOVW	R30,R28
    0501 8744      STD	Z+12,R20
    0502 8755      STD	Z+13,R21
    0503 8766      STD	Z+14,R22
    0504 8777      STD	Z+15,R23
    0505 940E083B  CALL	0x83B
(0114)     unsigned long passwordH = 0;
    0507 01FE      MOVW	R30,R28
    0508 8B40      STD	Z+16,R20
    0509 8B51      STD	Z+17,R21
    050A 8B62      STD	Z+18,R22
    050B 8B73      STD	Z+19,R23
    050C 940E083B  CALL	0x83B
(0115)     unsigned long passwordL = 0;
    050E 01FE      MOVW	R30,R28
    050F 8B44      STD	Z+20,R20
    0510 8B55      STD	Z+21,R21
    0511 8B66      STD	Z+22,R22
    0512 8B77      STD	Z+23,R23
(0116) 
(0117) 	//for(comId=0;comId<commandRecCount;comId++)
(0118) 	//{
(0119) 	//	uart0_send(commandBuffer[comId]);
(0120) 	//}
(0121) 	//return;
(0122)     comId = commandBuffer[0];
    0513 90C00088  LDS	R12,commandBuffer
(0123)     type = commandBuffer[1];
    0515 90A00089  LDS	R10,commandBuffer+1
    0517 940E089D  CALL	0x89D
(0124) 	idCard = Read32(((u8)(commandBuffer[2])), ((u8)(commandBuffer[3])), ((u8)(commandBuffer[4])), ((u8)(commandBuffer[5])));
    0519 9020008A  LDS	R2,commandBuffer+2
    051B 940E08A2  CALL	0x8A2
    051D D2E0      RCALL	lsl32
    051E 0118      MOVW	R2,R16
    051F 0129      MOVW	R4,R18
    0520 940E089D  CALL	0x89D
    0522 9060008B  LDS	R6,commandBuffer+3
    0524 940E0869  CALL	0x869
    0526 0143      MOVW	R8,R6
    0527 2466      CLR	R6
    0528 2477      CLR	R7
    0529 940E08DC  CALL	0x8DC
    052B 940E089D  CALL	0x89D
    052D 9060008C  LDS	R6,0x8C
    052F 940E0869  CALL	0x869
    0531 940E0929  CALL	0x929
    0533 D2CA      RCALL	lsl32
    0534 2A20      OR	R2,R16
    0535 2A31      OR	R3,R17
    0536 2A42      OR	R4,R18
    0537 2A53      OR	R5,R19
    0538 9060008D  LDS	R6,0x8D
    053A 2477      CLR	R7
    053B 2488      CLR	R8
    053C 2499      CLR	R9
    053D 940E08DC  CALL	0x8DC
    053F 01FE      MOVW	R30,R28
    0540 8624      STD	Z+12,R2
    0541 8635      STD	Z+13,R3
    0542 8646      STD	Z+14,R4
    0543 8657      STD	Z+15,R5
    0544 940E089D  CALL	0x89D
(0125) 	passwordH = Read32(((u8)commandBuffer[6]), ((u8)commandBuffer[7]), ((u8)commandBuffer[8]), ((u8)commandBuffer[9]));
    0546 9020008E  LDS	R2,0x8E
    0548 940E08A2  CALL	0x8A2
    054A D2B3      RCALL	lsl32
    054B 0118      MOVW	R2,R16
    054C 0129      MOVW	R4,R18
    054D 940E089D  CALL	0x89D
    054F 9060008F  LDS	R6,0x8F
    0551 940E0869  CALL	0x869
    0553 0143      MOVW	R8,R6
    0554 2466      CLR	R6
    0555 2477      CLR	R7
    0556 940E08DC  CALL	0x8DC
    0558 940E089D  CALL	0x89D
    055A 90600090  LDS	R6,0x90
    055C 940E0869  CALL	0x869
    055E 940E0929  CALL	0x929
    0560 D29D      RCALL	lsl32
    0561 2A20      OR	R2,R16
    0562 2A31      OR	R3,R17
    0563 2A42      OR	R4,R18
    0564 2A53      OR	R5,R19
    0565 90600091  LDS	R6,0x91
    0567 2477      CLR	R7
    0568 2488      CLR	R8
    0569 2499      CLR	R9
    056A 940E08DC  CALL	0x8DC
    056C 01FE      MOVW	R30,R28
    056D 8A20      STD	Z+16,R2
    056E 8A31      STD	Z+17,R3
    056F 8A42      STD	Z+18,R4
    0570 8A53      STD	Z+19,R5
    0571 940E089D  CALL	0x89D
(0126) 	passwordL = Read32(((u8)commandBuffer[10]), ((u8)commandBuffer[11]), ((u8)commandBuffer[12]), ((u8)commandBuffer[13]));
    0573 90200092  LDS	R2,0x92
    0575 940E08A2  CALL	0x8A2
    0577 D286      RCALL	lsl32
    0578 0118      MOVW	R2,R16
    0579 0129      MOVW	R4,R18
    057A 940E089D  CALL	0x89D
    057C 90600093  LDS	R6,0x93
    057E 940E0869  CALL	0x869
    0580 0143      MOVW	R8,R6
    0581 2466      CLR	R6
    0582 2477      CLR	R7
    0583 940E08DC  CALL	0x8DC
    0585 940E089D  CALL	0x89D
    0587 90600094  LDS	R6,0x94
    0589 940E0869  CALL	0x869
    058B 940E0929  CALL	0x929
    058D D270      RCALL	lsl32
    058E 2A20      OR	R2,R16
    058F 2A31      OR	R3,R17
    0590 2A42      OR	R4,R18
    0591 2A53      OR	R5,R19
    0592 90600095  LDS	R6,0x95
    0594 2477      CLR	R7
    0595 2488      CLR	R8
    0596 2499      CLR	R9
    0597 940E08DC  CALL	0x8DC
    0599 01FE      MOVW	R30,R28
    059A 8A24      STD	Z+20,R2
    059B 8A35      STD	Z+21,R3
    059C 8A46      STD	Z+22,R4
    059D 8A57      STD	Z+23,R5
(0127) 
(0128)     switch(comId)
    059E 24DD      CLR	R13
    059F 01C6      MOVW	R24,R12
    05A0 3082      CPI	R24,2
    05A1 E0E0      LDI	R30,0
    05A2 079E      CPC	R25,R30
    05A3 F0A1      BEQ	0x05B8
    05A4 3084      CPI	R24,4
    05A5 E0E0      LDI	R30,0
    05A6 079E      CPC	R25,R30
    05A7 F0C1      BEQ	0x05C0
    05A8 3086      CPI	R24,6
    05A9 E0E0      LDI	R30,0
    05AA 079E      CPC	R25,R30
    05AB F409      BNE	0x05AD
    05AC C02E      RJMP	0x05DB
    05AD 3087      CPI	R24,7
    05AE E0E0      LDI	R30,0
    05AF 079E      CPC	R25,R30
    05B0 F409      BNE	0x05B2
    05B1 C036      RJMP	0x05E8
    05B2 3088      CPI	R24,0x8
    05B3 E0E0      LDI	R30,0
    05B4 079E      CPC	R25,R30
    05B5 F409      BNE	0x05B7
    05B6 C063      RJMP	0x061A
    05B7 C095      RJMP	0x064D
(0129)     {
(0130)         case COMMANDIDREADITEMNUM: //read item num
(0131)         {
(0132)             unsigned char itemNum = readPasswordItemNum();
    05B8 DBBB      RCALL	_readPasswordItemNum
    05B9 2EC0      MOV	R12,R16
    05BA 940E0822  CALL	<created procedures>
(0133)             uart0_returnCommd(COMMANDIDRETURNITEMNUM, itemNum, 0, 0, 0);
    05BC 2D2C      MOV	R18,R12
    05BD E003      LDI	R16,3
    05BE DEF5      RCALL	_uart0_returnCommd
(0134)             break;
    05BF C08D      RJMP	0x064D
(0135)         }
(0136)         case COMMANDIDREADITEM: //read item by index
(0137)         {
(0138)             passwordItem_t item = readPasswordItem(type);
    05C0 940E098A  CALL	0x98A
    05C2 DBBC      RCALL	_readPasswordItem
(0139)             uart0_returnCommd(COMMANDIDRETURNITEM, item.flags, item.idCard, item.passwordH, item.passwordL);
    05C3 01FE      MOVW	R30,R28
    05C4 A021      LDD	R2,Z+33
    05C5 A032      LDD	R3,Z+34
    05C6 A043      LDD	R4,Z+35
    05C7 A054      LDD	R5,Z+36
    05C8 940E08FF  CALL	0x8FF
    05CA 01FE      MOVW	R30,R28
    05CB 8C25      LDD	R2,Z+29
    05CC 8C36      LDD	R3,Z+30
    05CD 8C47      LDD	R4,Z+31
    05CE A050      LDD	R5,Z+32
    05CF 940E090A  CALL	0x90A
    05D1 8C21      LDD	R2,Z+25
    05D2 8C32      LDD	R3,Z+26
    05D3 8C43      LDD	R4,Z+27
    05D4 8C54      LDD	R5,Z+28
    05D5 940E0910  CALL	0x910
    05D7 8D28      LDD	R18,Y+24
    05D8 E005      LDI	R16,5
    05D9 DEDA      RCALL	_uart0_returnCommd
(0140)             break;
    05DA C072      RJMP	0x064D
(0141)         }
(0142)         case COMMANDIDDELETEITEMS: //delete all item
(0143)         {
(0144)             unsigned char itemNum = readPasswordItemNum();
    05DB DB98      RCALL	_readPasswordItemNum
    05DC 2EC0      MOV	R12,R16
(0145)             if(itemNum==type)
    05DD 150A      CP	R16,R10
    05DE F009      BEQ	0x05E0
    05DF C06D      RJMP	0x064D
(0146)             {
(0147)                 writePasswordItemNum(0);
    05E0 2700      CLR	R16
    05E1 DBFB      RCALL	_writePasswordItemNum
    05E2 940E0822  CALL	<created procedures>
(0148)                 uart0_returnCommd(COMMANDRETURNOK, 0, 0, 0, 0);
    05E4 2722      CLR	R18
    05E5 E009      LDI	R16,0x9
    05E6 DECD      RCALL	_uart0_returnCommd
(0149)             }
(0150)             break;
    05E7 C065      RJMP	0x064D
(0151)         }
(0152)         case COMMANDIDINSERTITEM: //insert a item
(0153)         {
(0154)             passwordItem_t item;
(0155)             unsigned char itemNum = readPasswordItemNum();
    05E8 DB8B      RCALL	_readPasswordItemNum
    05E9 2EC0      MOV	R12,R16
(0156)             item.flags = type;
    05EA 8EA8      STD	Y+24,R10
    05EB 940E092F  CALL	0x92F
(0157)             item.idCard = idCard;
    05ED 01FE      MOVW	R30,R28
    05EE 8E21      STD	Z+25,R2
    05EF 8E32      STD	Z+26,R3
    05F0 8E43      STD	Z+27,R4
    05F1 8E54      STD	Z+28,R5
    05F2 940E0935  CALL	0x935
(0158)             item.passwordH = passwordH;
    05F4 01FE      MOVW	R30,R28
    05F5 8E25      STD	Z+29,R2
    05F6 8E36      STD	Z+30,R3
    05F7 8E47      STD	Z+31,R4
    05F8 A250      STD	Z+32,R5
    05F9 940E0923  CALL	0x923
(0159)             item.passwordL = passwordL;
    05FB 01FE      MOVW	R30,R28
    05FC A221      STD	Z+33,R2
    05FD A232      STD	Z+34,R3
    05FE A243      STD	Z+35,R4
    05FF A254      STD	Z+36,R5
(0160)             insertPasswordItem(itemNum+1, item);
    0600 01CE      MOVW	R24,R28
    0601 9648      ADIW	R24,0x18
    0602 01FE      MOVW	R30,R28
    0603 96B5      ADIW	R30,0x25
    0604 E00D      LDI	R16,0xD
    0605 E010      LDI	R17,0
    0606 93FA      ST	R31,-Y
    0607 93EA      ST	R30,-Y
    0608 939A      ST	R25,-Y
    0609 938A      ST	R24,-Y
    060A D1FF      RCALL	asgnblk
    060B 019E      MOVW	R18,R28
    060C 5D2B      SUBI	R18,0xDB
    060D 4F3F      SBCI	R19,0xFF
    060E 2D0C      MOV	R16,R12
    060F 5F0F      SUBI	R16,0xFF
    0610 DBA5      RCALL	_insertPasswordItem
(0161)             writePasswordItemNum(itemNum+1);
    0611 2D0C      MOV	R16,R12
    0612 5F0F      SUBI	R16,0xFF
    0613 DBC9      RCALL	_writePasswordItemNum
    0614 940E0822  CALL	<created procedures>
(0162)             uart0_returnCommd(COMMANDRETURNOK, 0, 0, 0, 0);
    0616 2722      CLR	R18
    0617 E009      LDI	R16,0x9
    0618 DE9B      RCALL	_uart0_returnCommd
(0163)             break;
    0619 C033      RJMP	0x064D
(0164)         }
(0165)         case COMMANDIDUNLOCK: //unlock by id or password
(0166)         {
(0167)             passwordItem_t item = readPasswordItem(type);
    061A 940E098A  CALL	0x98A
    061C DB62      RCALL	_readPasswordItem
    061D 940E092F  CALL	0x92F
(0168)             if((item.idCard==idCard)&&(item.passwordH==passwordH)&&(item.passwordL==passwordL))
    061F 01FE      MOVW	R30,R28
    0620 8C61      LDD	R6,Z+25
    0621 8C72      LDD	R7,Z+26
    0622 8C83      LDD	R8,Z+27
    0623 8C94      LDD	R9,Z+28
    0624 940E0898  CALL	0x898
    0626 F4A9      BNE	0x063C
    0627 940E0935  CALL	0x935
    0629 01FE      MOVW	R30,R28
    062A 8C65      LDD	R6,Z+29
    062B 8C76      LDD	R7,Z+30
    062C 8C87      LDD	R8,Z+31
    062D A090      LDD	R9,Z+32
    062E 940E0898  CALL	0x898
    0630 F459      BNE	0x063C
    0631 940E0923  CALL	0x923
    0633 01FE      MOVW	R30,R28
    0634 A061      LDD	R6,Z+33
    0635 A072      LDD	R7,Z+34
    0636 A083      LDD	R8,Z+35
    0637 A094      LDD	R9,Z+36
    0638 940E0898  CALL	0x898
    063A F409      BNE	0x063C
(0169)             	locker_unlock();
    063B DE02      RCALL	_locker_unlock
(0170)             uart0_returnCommd(COMMANDRETURNOK, type, idCard, passwordH, passwordL);
    063C 940E0923  CALL	0x923
    063E 940E08FF  CALL	0x8FF
    0640 940E0935  CALL	0x935
    0642 940E090A  CALL	0x90A
    0644 8424      LDD	R2,Z+12
    0645 8435      LDD	R3,Z+13
    0646 8446      LDD	R4,Z+14
    0647 8457      LDD	R5,Z+15
    0648 940E0910  CALL	0x910
    064A 2D2A      MOV	R18,R10
    064B E009      LDI	R16,0x9
    064C DE67      RCALL	_uart0_returnCommd
(0171)             break;
(0172)         }
(0173)         default:
(0174)             break;        
(0175)     }
(0176)     return;
    064D 96E2      ADIW	R28,0x32
    064E D134      RCALL	pop_gset4
    064F 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\iic.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "iic.h"
(0006) 
(0007) #define SET_SCL (PORTC|=0x80)
(0008) #define CLR_SCL (PORTC&=0x7f)
(0009) #define SET_SDA (PORTC|=0x40)
(0010) #define CLR_SDA (PORTC&=0xbf)
(0011) #define TEST_SDA ((PINC&0x40)?1:0)
(0012) #define SDA_OUT (DDRC|=0x40)
(0013) #define SDA_IN (DDRC&=0xbf,PORTC|=0x40)
(0014) 
(0015) //pc7 scl
(0016) //pc6 sda
(0017) void iicport_init(void)
(0018) {
(0019)     //hi-z
(0020)     DDRC &= 0x3f;
_iicport_init:
    0650 B384      IN	R24,0x14
    0651 738F      ANDI	R24,0x3F
    0652 BB84      OUT	0x14,R24
(0021)     PORTC &= 0x3f;
    0653 B385      IN	R24,0x15
    0654 738F      ANDI	R24,0x3F
    0655 BB85      OUT	0x15,R24
(0022)     return;
    0656 9508      RET
(0023) }
(0024) 
(0025) /* * * * * 以下是对IIC总线的操作子程序 * * * * */   
(0026) /* * * * * * 启动总线 * * * * */   
(0027) void start(void)    
(0028) {
(0029)     //pc6 and pc7 output mode.
(0030)     DDRC |= 0xc0;
_start:
    0657 B384      IN	R24,0x14
    0658 6C80      ORI	R24,0xC0
    0659 BB84      OUT	0x14,R24
(0031)     PORTC |= 0xc0;
    065A B385      IN	R24,0x15
    065B 6C80      ORI	R24,0xC0
    065C BB85      OUT	0x15,R24
(0032)     NOP();
    065D 0000      NOP
(0033)     //SCL=0; /* SCL处于高电平时,SDA从高电平转向低电平表示 */   
(0034)     //CLR_SCL;
(0035)     //SDA=1; /* 一个"开始"状态,该状态必须在其他命令之前执行 */   
(0036)     SET_SDA;
    065E 9AAE      SBI	0x15,6
(0037)     NOP();
    065F 0000      NOP
    0660 940E08E9  CALL	0x8E9
(0038)     //SCL=1;
(0039)     SET_SCL;
(0040)     NOP(); NOP(); NOP();    
(0041)     //SDA=0;
(0042)     CLR_SDA;
    0662 B385      IN	R24,0x15
    0663 7B8F      ANDI	R24,0xBF
    0664 BB85      OUT	0x15,R24
    0665 940E08E1  CALL	0x8E1
(0043)     NOP(); NOP(); NOP(); NOP();    
(0044)     //SCL=0;
(0045)     CLR_SCL;
(0046)     //SDA=1;
(0047)     //SET_SDA;
(0048) 
(0049)     return;
    0667 9508      RET
(0050) }    
(0051)    
(0052) /* * * * * 停止IIC总线 * * * * */   
(0053) void stop(void)    
(0054) {     
(0055)     //SCL=0; /*SCL处于高电平时,SDA从低电平转向高电平 */
(0056)     //CLR_SCL;   
(0057)     //SDA=0; /*表示一个"停止"状态,该状态终止所有通讯 */
(0058)     CLR_SDA;
_stop:
    0668 B385      IN	R24,0x15
    0669 7B8F      ANDI	R24,0xBF
    066A BB85      OUT	0x15,R24
(0059)     NOP();
    066B 0000      NOP
    066C 940E08E9  CALL	0x8E9
(0060)     //SCL=1;
(0061)     SET_SCL;
(0062)     NOP(); NOP(); NOP(); /* 空操作 */
(0063)     //SDA=1;
(0064)     SET_SDA;
    066E 9AAE      SBI	0x15,6
(0065)     NOP(); NOP(); NOP();
    066F 0000      NOP
    0670 0000      NOP
    0671 0000      NOP
(0066)     //SCL=0;
(0067)     //CLR_SCL;
(0068) 
(0069)     //hi-z
(0070)     DDRC &= 0x3f;
    0672 B384      IN	R24,0x14
    0673 738F      ANDI	R24,0x3F
    0674 BB84      OUT	0x14,R24
(0071)     PORTC &= 0x3f;
    0675 B385      IN	R24,0x15
    0676 738F      ANDI	R24,0x3F
    0677 BB85      OUT	0x15,R24
(0072)     return;
    0678 9508      RET
(0073) }    
(0074)    
(0075) /* * * * * 检查应答位 * * * * */   
(0076) unsigned char recAck(void)    
(0077) {
(0078)     unsigned char result;
(0079)      unsigned char i=0;
_recAck:
  result               --> R16
  i                    --> R16
    0679 2700      CLR	R16
    067A 940E097E  CALL	0x97E
    067C 940E08E9  CALL	0x8E9
(0080)     
(0081)     //SCL=0;
(0082)     //CLR_SCL;   
(0083)     //SDA=1;
(0084)     SET_SDA;
(0085)     SDA_IN;
(0086)     //SCL=1;
(0087)     SET_SCL;
(0088)     //change sda input mode.
(0089)     NOP(); NOP(); NOP(); NOP();
    067E 0000      NOP
    067F C001      RJMP	0x0681
(0090)     //CY=SDA;     /* 因为返回值总是放在CY中的 */
(0091)     while(TEST_SDA&&(i>250)) i++;
    0680 9503      INC	R16
    0681 9B9E      SBIS	0x13,6
    0682 C003      RJMP	0x0686
    0683 E021      LDI	R18,1
    0684 E030      LDI	R19,0
    0685 C002      RJMP	0x0688
    0686 2722      CLR	R18
    0687 2733      CLR	R19
    0688 3020      CPI	R18,0
    0689 0723      CPC	R18,R19
    068A F019      BEQ	0x068E
    068B EF8A      LDI	R24,0xFA
    068C 1780      CP	R24,R16
    068D F390      BCS	0x0680
(0092)     result = TEST_SDA;
    068E 9B9E      SBIS	0x13,6
    068F C003      RJMP	0x0693
    0690 E001      LDI	R16,1
    0691 E010      LDI	R17,0
    0692 C002      RJMP	0x0695
    0693 2700      CLR	R16
    0694 2711      CLR	R17
(0093)     //SCL=0;
(0094)     CLR_SCL;
    0695 B385      IN	R24,0x15
    0696 778F      ANDI	R24,0x7F
    0697 BB85      OUT	0x15,R24
(0095)     //SDA_OUT;
(0096)     SDA_OUT;
    0698 9AA6      SBI	0x14,6
(0097)     return result;
    0699 9508      RET
(0098) }    
(0099)    
(0100) /* * * * *对IIC总线产生应答 * * * * */   
(0101) void ack(void)    
(0102) {     
(0103)     //SDA=0; /* EEPROM通过在收到每个地址或数据之后, */
(0104)     CLR_SDA;
_ack:
    069A B385      IN	R24,0x15
    069B 7B8F      ANDI	R24,0xBF
    069C BB85      OUT	0x15,R24
(0105)     //SCL=1; /* 置SDA低电平的方式确认表示收到读SDA口状态 */
(0106)     SET_SCL;
    069D 9AAF      SBI	0x15,7
    069E 940E08E1  CALL	0x8E1
(0107)     NOP(); NOP(); NOP(); NOP();
(0108)     //SCL=0;
(0109)     CLR_SCL;   
(0110)     NOP();
    06A0 0000      NOP
(0111)     //SDA=1;
(0112)     SET_SDA;
    06A1 9AAE      SBI	0x15,6
(0113) 
(0114)     return;
    06A2 9508      RET
(0115) }    
(0116)    
(0117) /* * * * * * * * * 不对IIC总线产生应答 * * * * */   
(0118) void noAck(void)    
(0119) {    
(0120)     //SDA=1;
(0121)     SET_SDA;
_noAck:
    06A3 9AAE      SBI	0x15,6
(0122)     //SCL=1;
(0123)     SET_SCL;
    06A4 9AAF      SBI	0x15,7
    06A5 940E08E1  CALL	0x8E1
(0124)     NOP(); NOP(); NOP(); NOP();    
(0125)     //SCL=0;
(0126)     CLR_SCL;
(0127)     
(0128)     return;
    06A7 9508      RET
_sendByte:
  mask                 --> R20
  byte                 --> R16
    06A8 D0E6      RCALL	push_gset1
(0129) }    
(0130)    
(0131) /* * * * * * * * * 向IIC总线写数据 * * * * */   
(0132) void sendByte(unsigned char byte)    
(0133) {
(0134)     unsigned char mask = 0x80;
    06A9 E840      LDI	R20,0x80
(0135)     for(;mask>0;)    
    06AA C011      RJMP	0x06BC
(0136)     {
(0137)         //SCL=0;
(0138)         CLR_SCL;
    06AB 940E0957  CALL	0x957
(0139)         NOP();NOP();
    06AD 0000      NOP
(0140)         if(mask&byte)
    06AE 2E24      MOV	R2,R20
    06AF 2220      AND	R2,R16
    06B0 F011      BEQ	0x06B3
(0141)         {
(0142)             //SDA=1;
(0143)             SET_SDA;
    06B1 9AAE      SBI	0x15,6
(0144)         }
    06B2 C003      RJMP	0x06B6
(0145)         else
(0146)         {
(0147)             //SDA=0;
(0148)             CLR_SDA;
    06B3 B385      IN	R24,0x15
    06B4 7B8F      ANDI	R24,0xBF
    06B5 BB85      OUT	0x15,R24
(0149)         }
(0150)         mask >>= 1;
    06B6 9546      LSR	R20
(0151)         NOP();NOP();
    06B7 0000      NOP
    06B8 0000      NOP
(0152)         //SCL=1;
(0153)         SET_SCL;
    06B9 9AAF      SBI	0x15,7
(0154)         NOP();NOP();
    06BA 0000      NOP
    06BB 0000      NOP
    06BC 2422      CLR	R2
    06BD 1624      CP	R2,R20
    06BE F360      BCS	0x06AB
(0155)     }
(0156)     //SCL=0;
(0157)     CLR_SCL;
    06BF B385      IN	R24,0x15
    06C0 778F      ANDI	R24,0x7F
    06C1 BB85      OUT	0x15,R24
(0158) 
(0159)     return;
    06C2 D0CF      RCALL	pop_gset1
    06C3 9508      RET
_receiveByte:
  i                    --> R16
  receivebyte          --> R18
    06C4 D0CA      RCALL	push_gset1
(0160) }
(0161)    
(0162) /* * * * * * * * * 从IIC总线上读数据子程序 * * * * */   
(0163) unsigned char receiveByte(void)    
(0164) {     
(0165)     unsigned char receivebyte = 0, i=8;     
    06C5 2722      CLR	R18
    06C6 E008      LDI	R16,0x8
(0166)     //SCL=0;
(0167)     CLR_SCL;
    06C7 B385      IN	R24,0x15
    06C8 778F      ANDI	R24,0x7F
    06C9 BB85      OUT	0x15,R24
    06CA 940E097E  CALL	0x97E
(0168)     //SDA = 1;
(0169)     SET_SDA;
(0170)     SDA_IN;
(0171)     NOP();NOP();
    06CC 0000      NOP
    06CD 0000      NOP
    06CE C013      RJMP	0x06E2
(0172)     while(i--)    
(0173)     {     
(0174)         //SCL=1;
(0175)         SET_SCL;
    06CF 9AAF      SBI	0x15,7
(0176)         NOP();NOP();
    06D0 0000      NOP
    06D1 0000      NOP
(0177)         receivebyte = (receivebyte <<1 ) | TEST_SDA;
    06D2 9B9E      SBIS	0x13,6
    06D3 C003      RJMP	0x06D7
    06D4 E041      LDI	R20,1
    06D5 E050      LDI	R21,0
    06D6 C002      RJMP	0x06D9
    06D7 2744      CLR	R20
    06D8 2755      CLR	R21
    06D9 2E22      MOV	R2,R18
    06DA 2433      CLR	R3
    06DB 0C22      LSL	R2
    06DC 1C33      ROL	R3
    06DD 2A24      OR	R2,R20
    06DE 2A35      OR	R3,R21
    06DF 2D22      MOV	R18,R2
    06E0 940E0957  CALL	0x957
    06E2 2E20      MOV	R2,R16
    06E3 2433      CLR	R3
    06E4 5001      SUBI	R16,1
    06E5 2022      TST	R2
    06E6 F741      BNE	0x06CF
(0178)         //SCL=0;
(0179)         CLR_SCL;
(0180)         NOP();
(0181)     }
(0182)     SDA_OUT;
    06E7 9AA6      SBI	0x14,6
(0183)     return receivebyte;    
    06E8 2F02      MOV	R16,R18
    06E9 D0A8      RCALL	pop_gset1
    06EA 9508      RET
_rwiic:
  i                    --> R10
  err                  --> R20
  rwFlag               --> R22
  addr                 --> R12
  len                  --> R14
  data                 --> Y+12
  comAddr              --> Y+10
    06EB D064      RCALL	push_arg4
    06EC D09A      RCALL	push_gset5
    06ED 84EE      LDD	R14,Y+14
    06EE 88C8      LDD	R12,Y+16
    06EF 88D9      LDD	R13,Y+17
    06F0 896A      LDD	R22,Y+18
(0184) }
(0185) 
(0186) 
(0187) #define MAXRETRY    10
(0188) 
(0189) char rwiic(unsigned char comAddr, unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)    
(0190) {
(0191)     unsigned char i = MAXRETRY;
    06F1 E08A      LDI	R24,0xA
    06F2 2EA8      MOV	R10,R24
(0192)     char err = 1;  /*   出错标志   */   
    06F3 E041      LDI	R20,1
    06F4 C048      RJMP	0x073D
(0193)     while(i--)    
(0194)     {    
(0195)         start();  /*   启动总线   */
    06F5 DF61      RCALL	_start
(0196)         sendByte(comAddr |0x00); /*   向IIC总线写数据，器件地址 */   
    06F6 850A      LDD	R16,Y+10
    06F7 DFB0      RCALL	_sendByte
(0197)         if(recAck()) continue; /*   如写不正确结束本次循环   */   
    06F8 DF80      RCALL	_recAck
    06F9 2300      TST	R16
    06FA F009      BEQ	0x06FC
    06FB C041      RJMP	0x073D
(0198)         sendByte((unsigned char)(addr >> 8));//把整型数据转换为字符型数据：弃高取低，只取低8位.如果容量大于32K位，使用16位地址寻址，写入高八位地址    
    06FC 0186      MOVW	R16,R12
    06FD 2F01      MOV	R16,R17
    06FE 2711      CLR	R17
    06FF DFA8      RCALL	_sendByte
(0199)         if(recAck())  continue;    
    0700 DF78      RCALL	_recAck
    0701 2300      TST	R16
    0702 F009      BEQ	0x0704
    0703 C039      RJMP	0x073D
(0200)         sendByte((unsigned char)addr); /*   向IIC总线写数据   */   
    0704 2D0C      MOV	R16,R12
    0705 DFA2      RCALL	_sendByte
(0201)         if(recAck())  continue; /*   如写正确结束本次循环   */
    0706 DF72      RCALL	_recAck
    0707 2300      TST	R16
    0708 F009      BEQ	0x070A
    0709 C033      RJMP	0x073D
(0202)         if(rwFlag == RWWRITE)   //判断是读器件还是写器件    
    070A 2366      TST	R22
    070B F4A1      BNE	0x0720
(0203)         {
(0204)             err=0;         /* 清错误特征位 */   
    070C 2744      CLR	R20
    070D C00C      RJMP	0x071A
(0205)             while(len--)    
(0206)             {
(0207)                 sendByte(*(data++)); /*   向IIC总线写数据   */   
    070E 85EC      LDD	R30,Y+12
    070F 85FD      LDD	R31,Y+13
    0710 9101      LD	R16,Z+
    0711 87FD      STD	Y+13,R31
    0712 87EC      STD	Y+12,R30
    0713 DF94      RCALL	_sendByte
(0208)                 if(!recAck()) continue; /*   如写正确结束本次循环   */   
    0714 DF64      RCALL	_recAck
    0715 2300      TST	R16
    0716 F409      BNE	0x0718
    0717 C002      RJMP	0x071A
(0209)                 err=1;    
    0718 E041      LDI	R20,1
(0210)                 break;    
    0719 C003      RJMP	0x071D
    071A 940E0950  CALL	0x950
    071C F789      BNE	0x070E
(0211)             }    
(0212)             if(err==1) continue;    
    071D 3041      CPI	R20,1
    071E F531      BNE	0x0745
    071F C01D      RJMP	0x073D
(0213)             break;    
(0214)         }    
(0215)         else   
(0216)         { 
(0217)             start();  /*   启动总线   */   
    0720 DF36      RCALL	_start
(0218)             sendByte(comAddr |0x01); /*   向IIC总线写数据   */   
    0721 850A      LDD	R16,Y+10
    0722 6001      ORI	R16,1
    0723 DF84      RCALL	_sendByte
(0219)             if(recAck()) continue;//器件没应答结束本次本层循环    
    0724 DF54      RCALL	_recAck
    0725 2300      TST	R16
    0726 F009      BEQ	0x0728
    0727 C015      RJMP	0x073D
(0220)             //循环数量要减一。
(0221)             len--;
    0728 94EA      DEC	R14
    0729 C008      RJMP	0x0732
(0222)             while(len--)  /*   字节长为0结束   */   
(0223)             {
(0224)                 *(data++)= receiveByte();    
    072A DF99      RCALL	_receiveByte
    072B 2E20      MOV	R2,R16
    072C 85EC      LDD	R30,Y+12
    072D 85FD      LDD	R31,Y+13
    072E 9221      ST	R2,Z+
    072F 87FD      STD	Y+13,R31
    0730 87EC      STD	Y+12,R30
(0225)                 ack();   /*   对IIC总线产生应答   */   
    0731 DF68      RCALL	_ack
    0732 940E0950  CALL	0x950
    0734 F7A9      BNE	0x072A
(0226)             }    
(0227)             *data=receiveByte(); /* 读最后一个字节 */   
    0735 DF8E      RCALL	_receiveByte
    0736 2E20      MOV	R2,R16
    0737 85EC      LDD	R30,Y+12
    0738 85FD      LDD	R31,Y+13
    0739 8220      STD	Z+0,R2
(0228)             noAck();  /*   不对IIC总线产生应答   */   
    073A DF68      RCALL	_noAck
(0229)             err=0;    
    073B 2744      CLR	R20
(0230)             break;    
    073C C008      RJMP	0x0745
    073D 2C2A      MOV	R2,R10
    073E 2433      CLR	R3
    073F 2D82      MOV	R24,R2
    0740 5081      SUBI	R24,1
    0741 2EA8      MOV	R10,R24
    0742 2022      TST	R2
    0743 F009      BEQ	0x0745
    0744 CFB0      RJMP	0x06F5
(0231)         }    
(0232)     }    
(0233)     stop();  /*   停止IIC总线   */   
    0745 DF22      RCALL	_stop
(0234)     if(rwFlag == RWWRITE)    
    0746 2366      TST	R22
    0747 F421      BNE	0x074C
(0235)     {     
(0236)         delay_ms(50);    
    0748 E302      LDI	R16,0x32
    0749 E010      LDI	R17,0
    074A 940E0132  CALL	_delay_ms
(0237)     }    
(0238)     return err;    
FILE: <library>
    074C 2F04      MOV	R16,R20
    074D D037      RCALL	pop_gset5
    074E 9624      ADIW	R28,4
    074F 9508      RET
push_arg4:
    0750 940E09A8  CALL	0x9A8
push_arg2:
    0752 9508      RET
empy32u:
empy32s:
    0753 D05B      RCALL	long_prolog
    0754 927F      PUSH	R7
    0755 D072      RCALL	tstzero1
    0756 F131      BEQ	0x077D
    0757 2477      CLR	R7
    0758 D075      RCALL	tstzero2
    0759 F419      BNE	0x075D
    075A 018C      MOVW	R16,R24
    075B 019D      MOVW	R18,R26
    075C C020      RJMP	0x077D
    075D 9F08      MUL	R16,R24
    075E 2CB0      MOV	R11,R0
    075F 2CA1      MOV	R10,R1
    0760 9F28      MUL	R18,R24
    0761 2C90      MOV	R9,R0
    0762 2C81      MOV	R8,R1
    0763 9F18      MUL	R17,R24
    0764 0CA0      ADD	R10,R0
    0765 1C91      ADC	R9,R1
    0766 1C87      ADC	R8,R7
    0767 9F09      MUL	R16,R25
    0768 0CA0      ADD	R10,R0
    0769 1C91      ADC	R9,R1
    076A 1C87      ADC	R8,R7
    076B 9F19      MUL	R17,R25
    076C 0C90      ADD	R9,R0
    076D 1C81      ADC	R8,R1
    076E 9F0A      MUL	R16,R26
    076F 0C90      ADD	R9,R0
    0770 1C81      ADC	R8,R1
    0771 9F38      MUL	R19,R24
    0772 0C80      ADD	R8,R0
    0773 9F29      MUL	R18,R25
    0774 0C80      ADD	R8,R0
    0775 9F1A      MUL	R17,R26
    0776 0C80      ADD	R8,R0
    0777 9F0B      MUL	R16,R27
    0778 0C80      ADD	R8,R0
    0779 2D0B      MOV	R16,R11
    077A 2D1A      MOV	R17,R10
    077B 2D29      MOV	R18,R9
    077C 2D38      MOV	R19,R8
    077D 907F      POP	R7
    077E C03E      RJMP	long_epilog
pop_gset2:
    077F E0E2      LDI	R30,2
    0780 C012      RJMP	pop
pop_gset3:
    0781 E0E4      LDI	R30,4
    0782 C010      RJMP	pop
pop_gset4:
    0783 E0E8      LDI	R30,0x8
    0784 C00E      RJMP	pop
pop_gset5:
    0785 27EE      CLR	R30
    0786 C00C      RJMP	pop
push_gset5:
    0787 92FA      ST	R15,-Y
    0788 92EA      ST	R14,-Y
push_gset4:
    0789 92DA      ST	R13,-Y
    078A 92CA      ST	R12,-Y
push_gset3:
    078B 92BA      ST	R11,-Y
    078C 92AA      ST	R10,-Y
push_gset2:
    078D 937A      ST	R23,-Y
    078E 936A      ST	R22,-Y
push_gset1:
    078F 935A      ST	R21,-Y
    0790 934A      ST	R20,-Y
    0791 9508      RET
pop_gset1:
    0792 E0E1      LDI	R30,1
pop:
    0793 9149      LD	R20,Y+
    0794 9159      LD	R21,Y+
    0795 FDE0      SBRC	R30,0
    0796 9508      RET
    0797 9169      LD	R22,Y+
    0798 9179      LD	R23,Y+
    0799 FDE1      SBRC	R30,1
    079A 9508      RET
    079B 90A9      LD	R10,Y+
    079C 90B9      LD	R11,Y+
    079D FDE2      SBRC	R30,2
    079E 9508      RET
    079F 90C9      LD	R12,Y+
    07A0 90D9      LD	R13,Y+
    07A1 FDE3      SBRC	R30,3
    07A2 9508      RET
    07A3 90E9      LD	R14,Y+
    07A4 90F9      LD	R15,Y+
    07A5 9508      RET
xicall:
    07A6 920A      ST	R0,-Y
    07A7 95C8      LPM
    07A8 920A      ST	R0,-Y
    07A9 9631      ADIW	R30,1
    07AA 95C8      LPM
    07AB 2DF0      MOV	R31,R0
    07AC 91E9      LD	R30,Y+
    07AD 9009      LD	R0,Y+
    07AE 9409      IJMP
long_prolog:
    07AF 928A      ST	R8,-Y
    07B0 929A      ST	R9,-Y
    07B1 92AA      ST	R10,-Y
    07B2 92BA      ST	R11,-Y
    07B3 93EA      ST	R30,-Y
    07B4 938A      ST	R24,-Y
    07B5 939A      ST	R25,-Y
    07B6 93AA      ST	R26,-Y
    07B7 93BA      ST	R27,-Y
    07B8 8589      LDD	R24,Y+9
    07B9 859A      LDD	R25,Y+10
    07BA 85AB      LDD	R26,Y+11
    07BB 85BC      LDD	R27,Y+12
    07BC 9508      RET
long_epilog:
    07BD 91B9      LD	R27,Y+
    07BE 91A9      LD	R26,Y+
    07BF 9199      LD	R25,Y+
    07C0 9189      LD	R24,Y+
    07C1 91E9      LD	R30,Y+
    07C2 90B9      LD	R11,Y+
    07C3 90A9      LD	R10,Y+
    07C4 9099      LD	R9,Y+
    07C5 9089      LD	R8,Y+
    07C6 9624      ADIW	R28,4
    07C7 9508      RET
tstzero1:
    07C8 27EE      CLR	R30
    07C9 2BE0      OR	R30,R16
    07CA 2BE1      OR	R30,R17
    07CB 2BE2      OR	R30,R18
    07CC 2BE3      OR	R30,R19
    07CD 9508      RET
tstzero2:
    07CE 27EE      CLR	R30
    07CF 2BE8      OR	R30,R24
    07D0 2BE9      OR	R30,R25
    07D1 2BEA      OR	R30,R26
    07D2 2BEB      OR	R30,R27
    07D3 9508      RET
push_lset:
    07D4 93FA      ST	R31,-Y
    07D5 93EA      ST	R30,-Y
    07D6 93BA      ST	R27,-Y
    07D7 93AA      ST	R26,-Y
    07D8 939A      ST	R25,-Y
    07D9 938A      ST	R24,-Y
    07DA 940E09A8  CALL	0x9A8
    07DC 929A      ST	R9,-Y
    07DD 928A      ST	R8,-Y
    07DE 927A      ST	R7,-Y
    07DF 926A      ST	R6,-Y
    07E0 940E098F  CALL	0x98F
    07E2 921A      ST	R1,-Y
    07E3 920A      ST	R0,-Y
    07E4 B60F      IN	R0,0x3F
    07E5 920A      ST	R0,-Y
    07E6 9508      RET
pop_lset:
    07E7 9009      LD	R0,Y+
    07E8 BE0F      OUT	0x3F,R0
    07E9 9009      LD	R0,Y+
    07EA 9019      LD	R1,Y+
    07EB 9029      LD	R2,Y+
    07EC 9039      LD	R3,Y+
    07ED 9049      LD	R4,Y+
    07EE 9059      LD	R5,Y+
    07EF 9069      LD	R6,Y+
    07F0 9079      LD	R7,Y+
    07F1 9089      LD	R8,Y+
    07F2 9099      LD	R9,Y+
    07F3 9109      LD	R16,Y+
    07F4 9119      LD	R17,Y+
    07F5 9129      LD	R18,Y+
    07F6 9139      LD	R19,Y+
    07F7 9189      LD	R24,Y+
    07F8 9199      LD	R25,Y+
    07F9 91A9      LD	R26,Y+
    07FA 91B9      LD	R27,Y+
    07FB 91E9      LD	R30,Y+
    07FC 91F9      LD	R31,Y+
    07FD 9508      RET
lsl32:
    07FE 920F      PUSH	R0
    07FF 9009      LD	R0,Y+
    0800 2000      TST	R0
    0801 F031      BEQ	0x0808
    0802 0F00      LSL	R16
    0803 1F11      ROL	R17
    0804 1F22      ROL	R18
    0805 1F33      ROL	R19
    0806 940A      DEC	R0
    0807 CFF8      RJMP	0x0800
    0808 900F      POP	R0
    0809 9508      RET
asgnblk:
    080A 93AA      ST	R26,-Y
    080B 93BA      ST	R27,-Y
    080C 93EA      ST	R30,-Y
    080D 93FA      ST	R31,-Y
    080E 920A      ST	R0,-Y
    080F 81AF      LDD	R26,Y+7
    0810 85B8      LDD	R27,Y+8
    0811 81ED      LDD	R30,Y+5
    0812 81FE      LDD	R31,Y+6
    0813 3000      CPI	R16,0
    0814 0701      CPC	R16,R17
    0815 F029      BEQ	0x081B
    0816 9001      LD	R0,Z+
    0817 920D      ST	R0,X+
    0818 5001      SUBI	R16,1
    0819 4010      SBCI	R17,0
    081A CFF8      RJMP	0x0813
    081B 9009      LD	R0,Y+
    081C 91F9      LD	R31,Y+
    081D 91E9      LD	R30,Y+
    081E 91B9      LD	R27,Y+
    081F 91A9      LD	R26,Y+
    0820 9624      ADIW	R28,4
    0821 9508      RET
<created procedures>:
    0822 E040      LDI	R20,0
    0823 E050      LDI	R21,0
    0824 E060      LDI	R22,0
    0825 E070      LDI	R23,0
    0826 8748      STD	Y+8,R20
    0827 8759      STD	Y+9,R21
    0828 876A      STD	Y+10,R22
    0829 877B      STD	Y+11,R23
    082A E040      LDI	R20,0
    082B E050      LDI	R21,0
    082C E060      LDI	R22,0
    082D E070      LDI	R23,0
    082E 834C      STD	Y+4,R20
    082F 835D      STD	Y+5,R21
    0830 836E      STD	Y+6,R22
    0831 837F      STD	Y+7,R23
    0832 E040      LDI	R20,0
    0833 E050      LDI	R21,0
    0834 E060      LDI	R22,0
    0835 E070      LDI	R23,0
    0836 8348      STD	Y+0,R20
    0837 8359      STD	Y+1,R21
    0838 836A      STD	Y+2,R22
    0839 837B      STD	Y+3,R23
    083A 9508      RET
    083B E040      LDI	R20,0
    083C E050      LDI	R21,0
    083D E060      LDI	R22,0
    083E E070      LDI	R23,0
    083F 9508      RET
    0840 E084      LDI	R24,4
    0841 9F84      MUL	R24,R20
    0842 01F0      MOVW	R30,R0
    0843 E788      LDI	R24,0x78
    0844 E090      LDI	R25,0
    0845 0FE8      ADD	R30,R24
    0846 1FF9      ADC	R31,R25
    0847 9508      RET
    0848 8628      STD	Y+8,R2
    0849 8639      STD	Y+9,R3
    084A 864A      STD	Y+10,R4
    084B 865B      STD	Y+11,R5
    084C 90400070  LDS	R4,passwordH+2
    084E 90500071  LDS	R5,passwordH+3
    0850 9020006E  LDS	R2,passwordH
    0852 9030006F  LDS	R3,passwordH+1
    0854 822C      STD	Y+4,R2
    0855 823D      STD	Y+5,R3
    0856 824E      STD	Y+6,R4
    0857 825F      STD	Y+7,R5
    0858 01FE      MOVW	R30,R28
    0859 8425      LDD	R2,Z+13
    085A 8436      LDD	R3,Z+14
    085B 8447      LDD	R4,Z+15
    085C 8850      LDD	R5,Z+16
    085D 8228      STD	Y+0,R2
    085E 8239      STD	Y+1,R3
    085F 824A      STD	Y+2,R4
    0860 825B      STD	Y+3,R5
    0861 E023      LDI	R18,3
    0862 9508      RET
    0863 01F0      MOVW	R30,R0
    0864 E788      LDI	R24,0x78
    0865 E090      LDI	R25,0
    0866 0FE8      ADD	R30,R24
    0867 1FF9      ADC	R31,R25
    0868 9508      RET
    0869 2477      CLR	R7
    086A 2488      CLR	R8
    086B 2499      CLR	R9
    086C 2264      AND	R6,R20
    086D 2275      AND	R7,R21
    086E 2286      AND	R8,R22
    086F 2297      AND	R9,R23
    0870 9508      RET
    0871 90400070  LDS	R4,passwordH+2
    0873 90500071  LDS	R5,passwordH+3
    0875 9020006E  LDS	R2,passwordH
    0877 9030006F  LDS	R3,passwordH+1
    0879 9508      RET
    087A 90400064  LDS	R4,id_code+2
    087C 90500065  LDS	R5,id_code+3
    087E 90200062  LDS	R2,id_code
    0880 90300063  LDS	R3,id_code+1
    0882 0C22      LSL	R2
    0883 1C33      ROL	R3
    0884 1C44      ROL	R4
    0885 1C55      ROL	R5
    0886 92300063  STS	id_code+1,R3
    0888 92200062  STS	id_code,R2
    088A 92500065  STS	id_code+3,R5
    088C 92400064  STS	id_code+2,R4
    088E 9508      RET
    088F 92300063  STS	id_code+1,R3
    0891 92200062  STS	id_code,R2
    0893 92500065  STS	id_code+3,R5
    0895 92400064  STS	id_code+2,R4
    0897 9508      RET
    0898 1462      CP	R6,R2
    0899 0473      CPC	R7,R3
    089A 0484      CPC	R8,R4
    089B 0495      CPC	R9,R5
    089C 9508      RET
    089D EF4F      LDI	R20,0xFF
    089E E050      LDI	R21,0
    089F E060      LDI	R22,0
    08A0 E070      LDI	R23,0
    08A1 9508      RET
    08A2 2433      CLR	R3
    08A3 2444      CLR	R4
    08A4 2455      CLR	R5
    08A5 2224      AND	R2,R20
    08A6 2235      AND	R3,R21
    08A7 2246      AND	R4,R22
    08A8 2257      AND	R5,R23
    08A9 E188      LDI	R24,0x18
    08AA E090      LDI	R25,0
    08AB 938A      ST	R24,-Y
    08AC 0181      MOVW	R16,R2
    08AD 0192      MOVW	R18,R4
    08AE 9508      RET
    08AF 01FE      MOVW	R30,R28
    08B0 A023      LDD	R2,Z+35
    08B1 A034      LDD	R3,Z+36
    08B2 A045      LDD	R4,Z+37
    08B3 A056      LDD	R5,Z+38
    08B4 9508      RET
    08B5 90400074  LDS	R4,passwordL+2
    08B7 90500075  LDS	R5,passwordL+3
    08B9 90200072  LDS	R2,passwordL
    08BB 90300073  LDS	R3,passwordL+1
    08BD 9508      RET
    08BE 90400064  LDS	R4,id_code+2
    08C0 90500065  LDS	R5,id_code+3
    08C2 90200062  LDS	R2,id_code
    08C4 90300063  LDS	R3,id_code+1
    08C6 9508      RET
    08C7 E084      LDI	R24,4
    08C8 9F84      MUL	R24,R20
    08C9 01F0      MOVW	R30,R0
    08CA E78A      LDI	R24,0x7A
    08CB E090      LDI	R25,0
    08CC 0FE8      ADD	R30,R24
    08CD 1FF9      ADC	R31,R25
    08CE 9508      RET
    08CF E041      LDI	R20,1
    08D0 E050      LDI	R21,0
    08D1 E060      LDI	R22,0
    08D2 E070      LDI	R23,0
    08D3 93500073  STS	passwordL+1,R21
    08D5 93400072  STS	passwordL,R20
    08D7 93700075  STS	passwordL+3,R23
    08D9 93600074  STS	passwordL+2,R22
    08DB 9508      RET
    08DC 2826      OR	R2,R6
    08DD 2837      OR	R3,R7
    08DE 2848      OR	R4,R8
    08DF 2859      OR	R5,R9
    08E0 9508      RET
    08E1 0000      NOP
    08E2 0000      NOP
    08E3 0000      NOP
    08E4 0000      NOP
    08E5 B385      IN	R24,0x15
    08E6 778F      ANDI	R24,0x7F
    08E7 BB85      OUT	0x15,R24
    08E8 9508      RET
    08E9 9AAF      SBI	0x15,7
    08EA 0000      NOP
    08EB 0000      NOP
    08EC 0000      NOP
    08ED 9508      RET
    08EE E041      LDI	R20,1
    08EF E050      LDI	R21,0
    08F0 E060      LDI	R22,0
    08F1 E070      LDI	R23,0
    08F2 9508      RET
    08F3 B388      IN	R24,0x18
    08F4 7D8F      ANDI	R24,0xDF
    08F5 BB88      OUT	0x18,R24
    08F6 E604      LDI	R16,0x64
    08F7 E010      LDI	R17,0
    08F8 9508      RET
    08F9 2422      CLR	R2
    08FA 822A      STD	Y+2,R2
    08FB E08D      LDI	R24,0xD
    08FC 9F86      MUL	R24,R22
    08FD 01C0      MOVW	R24,R0
    08FE 9508      RET
    08FF 8628      STD	Y+8,R2
    0900 8639      STD	Y+9,R3
    0901 864A      STD	Y+10,R4
    0902 865B      STD	Y+11,R5
    0903 9508      RET
    0904 E081      LDI	R24,1
    0905 838A      STD	Y+2,R24
    0906 E08D      LDI	R24,0xD
    0907 9F86      MUL	R24,R22
    0908 01C0      MOVW	R24,R0
    0909 9508      RET
    090A 822C      STD	Y+4,R2
    090B 823D      STD	Y+5,R3
    090C 824E      STD	Y+6,R4
    090D 825F      STD	Y+7,R5
    090E 01FE      MOVW	R30,R28
    090F 9508      RET
    0910 8228      STD	Y+0,R2
    0911 8239      STD	Y+1,R3
    0912 824A      STD	Y+2,R4
    0913 825B      STD	Y+3,R5
    0914 9508      RET
    0915 2224      AND	R2,R20
    0916 2235      AND	R3,R21
    0917 2246      AND	R4,R22
    0918 2257      AND	R5,R23
    0919 9508      RET
    091A 93500063  STS	id_code+1,R21
    091C 93400062  STS	id_code,R20
    091E 93700065  STS	id_code+3,R23
    0920 93600064  STS	id_code+2,R22
    0922 9508      RET
    0923 01FE      MOVW	R30,R28
    0924 8824      LDD	R2,Z+20
    0925 8835      LDD	R3,Z+21
    0926 8846      LDD	R4,Z+22
    0927 8857      LDD	R5,Z+23
    0928 9508      RET
    0929 E088      LDI	R24,0x8
    092A E090      LDI	R25,0
    092B 938A      ST	R24,-Y
    092C 0183      MOVW	R16,R6
    092D 0194      MOVW	R18,R8
    092E 9508      RET
    092F 01FE      MOVW	R30,R28
    0930 8424      LDD	R2,Z+12
    0931 8435      LDD	R3,Z+13
    0932 8446      LDD	R4,Z+14
    0933 8457      LDD	R5,Z+15
    0934 9508      RET
    0935 01FE      MOVW	R30,R28
    0936 8820      LDD	R2,Z+16
    0937 8831      LDD	R3,Z+17
    0938 8842      LDD	R4,Z+18
    0939 8853      LDD	R5,Z+19
    093A 9508      RET
    093B 2433      CLR	R3
    093C 8239      STD	Y+1,R3
    093D 8228      STD	Y+0,R2
    093E E021      LDI	R18,1
    093F 018E      MOVW	R16,R28
    0940 5F0D      SUBI	R16,0xFD
    0941 4F1F      SBCI	R17,0xFF
    0942 9508      RET
    0943 E586      LDI	R24,0x56
    0944 E090      LDI	R25,0
    0945 8399      STD	Y+1,R25
    0946 8388      STD	Y+0,R24
    0947 E22C      LDI	R18,0x2C
    0948 E031      LDI	R19,1
    0949 E001      LDI	R16,1
    094A 9508      RET
    094B E024      LDI	R18,4
    094C 018E      MOVW	R16,R28
    094D 5F04      SUBI	R16,0xF4
    094E 4F1F      SBCI	R17,0xFF
    094F 9508      RET
    0950 2C2E      MOV	R2,R14
    0951 2433      CLR	R3
    0952 2D82      MOV	R24,R2
    0953 5081      SUBI	R24,1
    0954 2EE8      MOV	R14,R24
    0955 2022      TST	R2
    0956 9508      RET
    0957 B385      IN	R24,0x15
    0958 778F      ANDI	R24,0x7F
    0959 BB85      OUT	0x15,R24
    095A 0000      NOP
    095B 9508      RET
    095C B381      IN	R24,0x11
    095D 7F8C      ANDI	R24,0xFC
    095E BB81      OUT	0x11,R24
    095F B382      IN	R24,0x12
    0960 7F8C      ANDI	R24,0xFC
    0961 BB82      OUT	0x12,R24
    0962 9508      RET
    0963 E024      LDI	R18,4
    0964 018E      MOVW	R16,R28
    0965 5F08      SUBI	R16,0xF8
    0966 4F1F      SBCI	R17,0xFF
    0967 9508      RET
    0968 E024      LDI	R18,4
    0969 018E      MOVW	R16,R28
    096A 5F0C      SUBI	R16,0xFC
    096B 4F1F      SBCI	R17,0xFF
    096C 9508      RET
    096D 8399      STD	Y+1,R25
    096E 8388      STD	Y+0,R24
    096F E024      LDI	R18,4
    0970 018A      MOVW	R16,R20
    0971 9508      RET
    0972 E090      LDI	R25,0
    0973 8399      STD	Y+1,R25
    0974 8388      STD	Y+0,R24
    0975 E022      LDI	R18,2
    0976 E030      LDI	R19,0
    0977 9508      RET
    0978 E090      LDI	R25,0
    0979 93900067  STS	id_reader_flags+1,R25
    097B 93800066  STS	id_reader_flags,R24
    097D 9508      RET
    097E 9AAE      SBI	0x15,6
    097F B384      IN	R24,0x14
    0980 7B8F      ANDI	R24,0xBF
    0981 BB84      OUT	0x14,R24
    0982 9AAE      SBI	0x15,6
    0983 9508      RET
    0984 2422      CLR	R2
    0985 2433      CLR	R3
    0986 8231      STD	Z+1,R3
    0987 8220      STD	Z+0,R2
    0988 E084      LDI	R24,4
    0989 9508      RET
    098A 2D2A      MOV	R18,R10
    098B 018E      MOVW	R16,R28
    098C 5E08      SUBI	R16,0xE8
    098D 4F1F      SBCI	R17,0xFF
    098E 9508      RET
    098F 925A      ST	R5,-Y
    0990 924A      ST	R4,-Y
    0991 923A      ST	R3,-Y
    0992 922A      ST	R2,-Y
    0993 9508      RET
    0994 E04A      LDI	R20,0xA
    0995 E050      LDI	R21,0
    0996 E060      LDI	R22,0
    0997 E070      LDI	R23,0
    0998 9508      RET
    0999 9601      ADIW	R24,1
    099A 8399      STD	Y+1,R25
    099B 8388      STD	Y+0,R24
    099C E021      LDI	R18,1
    099D 9508      RET
    099E 1624      CP	R2,R20
    099F 0635      CPC	R3,R21
    09A0 0646      CPC	R4,R22
    09A1 0657      CPC	R5,R23
    09A2 9508      RET
    09A3 2FE4      MOV	R30,R20
    09A4 27FF      CLR	R31
    09A5 0DEA      ADD	R30,R10
    09A6 1DFB      ADC	R31,R11
    09A7 9508      RET
    09A8 933A      ST	R19,-Y
    09A9 932A      ST	R18,-Y
    09AA 931A      ST	R17,-Y
    09AB 930A      ST	R16,-Y
    09AC 9508      RET
