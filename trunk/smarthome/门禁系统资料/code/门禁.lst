__text_start:
__start:
    003A E5CF      LDI	R28,0x5F
    003B E0D4      LDI	R29,4
    003C BFCD      OUT	0x3D,R28
    003D BFDE      OUT	0x3E,R29
    003E 51C0      SUBI	R28,0x10
    003F 40D0      SBCI	R29,0
    0040 EA0A      LDI	R16,0xAA
    0041 8308      STD	Y+0,R16
    0042 2400      CLR	R0
    0043 E7E3      LDI	R30,0x73
    0044 E0F0      LDI	R31,0
    0045 E010      LDI	R17,0
    0046 37EF      CPI	R30,0x7F
    0047 07F1      CPC	R31,R17
    0048 F011      BEQ	0x004B
    0049 9201      ST	R0,Z+
    004A CFFB      RJMP	0x0046
    004B 8300      STD	Z+0,R16
    004C E6E0      LDI	R30,0x60
    004D E0F0      LDI	R31,0
    004E E6A0      LDI	R26,0x60
    004F E0B0      LDI	R27,0
    0050 E010      LDI	R17,0
    0051 37E3      CPI	R30,0x73
    0052 07F1      CPC	R31,R17
    0053 F021      BEQ	0x0058
    0054 95C8      LPM
    0055 9631      ADIW	R30,1
    0056 920D      ST	R0,X+
    0057 CFF9      RJMP	0x0051
    0058 D001      RCALL	_main
_exit:
    0059 CFFF      RJMP	_exit
_main:
  ot                   --> Y+13
  t                    --> Y+0
    005A 97EF      SBIW	R28,0x3F
    005B 9722      SBIW	R28,2
FILE: D:\smarthome\smarthome\门禁系统资料\code\main.c
(0001) #include <stdio.h>
(0002) #include <stdlib.h>
(0003) #include <string.h>
(0004) 
(0005) #include<iom16v.h>
(0006) #include <macros.h>
(0007) //#include <sleep.h>
(0008) 
(0009) #include "uart.h"
(0010) #include "wg26.h"
(0011) #include "util.h"
(0012) #include "tips.h"
(0013) #include "timer.h"
(0014) #include "ringandscreen.h"
(0015) #include "iic.h"
(0016) #include "eeprom.h"
(0017) #include "password.h"
(0018) #include "locker.h"
(0019) 
(0020) int main(void)
(0021) {
(0022)     //unsigned int door_minitor_count = 0;
(0023)     passwordItem_t t, ot;
(0024) 	
(0025)     uart0_init();
    005C D445      RCALL	_uart0_init
(0026)     wg26_init_interrupt();
    005D D05F      RCALL	_wg26_init_interrupt
(0027)     tips_port_init();
    005E D126      RCALL	_tips_port_init
(0028)     timer_init();
    005F D349      RCALL	_timer_init
(0029)     iicport_init();
    0060 D44D      RCALL	_iicport_init
(0030) 	locker_init();
    0061 D3E5      RCALL	_locker_init
(0031) 	doorandscreen_init();
    0062 D412      RCALL	_doorandscreen_init
(0032) 
(0033)     t.flags = PASSWORDFLAGS_PASSWORD;
    0063 E082      LDI	R24,2
    0064 8388      STD	Y+0,R24
(0034)     t.idCard = 0;
    0065 E040      LDI	R20,0
    0066 940E075D  CALL	0x75D
    0068 8341      STD	Z+1,R20
    0069 8352      STD	Z+2,R21
    006A 8363      STD	Z+3,R22
    006B 8374      STD	Z+4,R23
(0035)     t.passwordH = 1135642406;
    006C E246      LDI	R20,0x26
    006D E857      LDI	R21,0x87
    006E EB60      LDI	R22,0xB0
    006F E473      LDI	R23,0x43
    0070 01FE      MOVW	R30,R28
    0071 8345      STD	Z+5,R20
    0072 8356      STD	Z+6,R21
    0073 8367      STD	Z+7,R22
    0074 8770      STD	Z+8,R23
(0036)     t.passwordL = 100;
    0075 E644      LDI	R20,0x64
    0076 940E075D  CALL	0x75D
    0078 940E0815  CALL	0x815
(0037)     insertPasswordItem(0, t);
    007A 967A      ADIW	R30,0x1A
    007B 940E07B6  CALL	0x7B6
    007D 5E26      SUBI	R18,0xE6
    007E 4F3F      SBCI	R19,0xFF
    007F 2700      CLR	R16
    0080 D1A1      RCALL	_insertPasswordItem
(0038) 
(0039)     t.flags = PASSWORDFLAGS_ID;
    0081 E081      LDI	R24,1
    0082 8388      STD	Y+0,R24
(0040)     t.idCard = 9512827;
    0083 E74B      LDI	R20,0x7B
    0084 E257      LDI	R21,0x27
    0085 E961      LDI	R22,0x91
    0086 940E081C  CALL	0x81C
(0041)     t.passwordH = 1;
    0088 E041      LDI	R20,1
    0089 940E075D  CALL	0x75D
    008B 940E0810  CALL	0x810
(0042)     t.passwordL = 1;
    008D E041      LDI	R20,1
    008E 940E075D  CALL	0x75D
    0090 940E0815  CALL	0x815
(0043)     insertPasswordItem(1, t);
    0092 96B7      ADIW	R30,0x27
    0093 940E07B6  CALL	0x7B6
    0095 5D29      SUBI	R18,0xD9
    0096 4F3F      SBCI	R19,0xFF
    0097 E001      LDI	R16,1
    0098 D189      RCALL	_insertPasswordItem
(0044) 
(0045)     t.flags = PASSWORDFLAGS_ID;
    0099 E081      LDI	R24,1
    009A 8388      STD	Y+0,R24
(0046)     t.idCard = 1392618;
    009B EE4A      LDI	R20,0xEA
    009C E35F      LDI	R21,0x3F
    009D E165      LDI	R22,0x15
    009E 940E081C  CALL	0x81C
(0047)     t.passwordH = 1;
    00A0 E041      LDI	R20,1
    00A1 940E075D  CALL	0x75D
    00A3 940E0810  CALL	0x810
(0048)     t.passwordL = 1;
    00A5 E041      LDI	R20,1
    00A6 940E075D  CALL	0x75D
    00A8 940E0815  CALL	0x815
(0049)     insertPasswordItem(2, t);
    00AA 96F4      ADIW	R30,0x34
    00AB 940E07B6  CALL	0x7B6
    00AD 5C2C      SUBI	R18,0xCC
    00AE 4F3F      SBCI	R19,0xFF
    00AF E002      LDI	R16,2
    00B0 D171      RCALL	_insertPasswordItem
(0050) 
(0051) 	writePasswordItemNum(3);
    00B1 E003      LDI	R16,3
    00B2 D194      RCALL	_writePasswordItemNum
    00B3 C003      RJMP	0x00B7
(0052) 
(0053)     while(1)
(0054)     {
(0055)         /*
(0056) 		//door_minitor_count++;
(0057) 		if(door_minitor_count>20)
(0058) 		{
(0059) 			//door open.
(0060) 			if(check_door())
(0061) 			{
(0062) 				tips_err();
(0063) 			}
(0064) 			door_minitor_count = 0;
(0065) 		}
(0066) 		delay_ms(500);
(0067) 		*/
(0068) 		//set_sleep_mode(SLEEP_MODE_IDLE);
(0069)         //sleep_mode();
(0070)         delay_ms(500);
    00B4 EF04      LDI	R16,0xF4
    00B5 E011      LDI	R17,1
    00B6 D0C0      RCALL	_delay_ms
    00B7 CFFC      RJMP	0x00B4
(0071)     }
(0072)     return 0;
    00B8 2700      CLR	R16
    00B9 2711      CLR	R17
    00BA 96EF      ADIW	R28,0x3F
    00BB 9622      ADIW	R28,2
    00BC 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\wg26.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "password.h"
(0004) #include "timer.h"
(0005) 
(0006) //pc0 input wg26 d0, pc1 input wg26 d1.
(0007) //wg26 d0 is 0, d1 is 1.
(0008) void wg26_init_interrupt(void)
(0009) {
(0010)     //pc0,pc1 input mode.
(0011)     DDRC &= 0xfc;
_wg26_init_interrupt:
    00BD B384      IN	R24,0x14
    00BE 7F8C      ANDI	R24,0xFC
    00BF BB84      OUT	0x14,R24
(0012)     //上拉。
(0013)     PORTC |= 0x03;
    00C0 B385      IN	R24,0x15
    00C1 6083      ORI	R24,3
    00C2 BB85      OUT	0x15,R24
(0014)     //enable interrupt.
(0015)     //pd2 input mode.
(0016)     DDRD &= 0xfb;
    00C3 B381      IN	R24,0x11
    00C4 7F8B      ANDI	R24,0xFB
    00C5 BB81      OUT	0x11,R24
(0017) 	//
(0018) 	PORTD |= 0x04;
    00C6 9A92      SBI	0x12,2
(0019) 	
(0020)     SREG |= 0x80;
    00C7 9478      BSET	7
(0021)     //int0 enable.
(0022)     GICR |= 0x40;
    00C8 B78B      IN	R24,0x3B
    00C9 6480      ORI	R24,0x40
    00CA BF8B      OUT	0x3B,R24
(0023)     //int0 fall edge.
(0024)     MCUCR |= 0x02;
    00CB B785      IN	R24,0x35
    00CC 6082      ORI	R24,2
    00CD BF85      OUT	0x35,R24
(0025)     return;
    00CE 9508      RET
(0026) }
(0027) //diable reader.
(0028) static void disable_reader(void)
(0029) {
(0030)     GICR &= 0xbf;
_disable_reader:
    00CF B78B      IN	R24,0x3B
    00D0 7B8F      ANDI	R24,0xBF
    00D1 BF8B      OUT	0x3B,R24
(0031)     return;
    00D2 9508      RET
(0032) }
(0033) //enable reader.
(0034) static void enable_reader(void)
(0035) {
(0036)     GICR |= 0x40;
_enable_reader:
    00D3 B78B      IN	R24,0x3B
    00D4 6480      ORI	R24,0x40
    00D5 BF8B      OUT	0x3B,R24
(0037)     return;
    00D6 9508      RET
_id_reader_check:
  id_code              --> Y+0
    00D7 940E063B  CALL	push_arg4
(0038) }
(0039) 
(0040) //id card id.
(0041) static unsigned long id_code = 0;
(0042) //read flags.
(0043) static unsigned int id_reader_flags = 0;
(0044) //read count.
(0045) static char read_count = 0;
(0046) //define reader flags.
(0047) #define IDREADERFLAG_WAITING 0x0000
(0048) #define IDREADERFLAG_READING 0x0001
(0049) #define IDREADERFLAG_READED 0x0002
(0050) //id code check.
(0051) static char id_reader_check(unsigned long id_code)
(0052) {
(0053)     return 0;
    00D9 2700      CLR	R16
    00DA 9624      ADIW	R28,4
    00DB 9508      RET
_read_time_out:
  timer                --> R10
    00DC 940E0674  CALL	push_gset3
    00DE 2EA0      MOV	R10,R16
    00DF 9722      SBIW	R28,2
(0054) }
(0055) 
(0056) //read timeout.
(0057) static void read_time_out(char timer)
(0058) {
(0059)     if(timer == IDREADERTIMEOUTTIMER)
    00E0 20AA      TST	R10
    00E1 F009      BEQ	0x00E3
    00E2 C03E      RJMP	0x0121
(0060)     {
(0061)         //disable reader.
(0062)         disable_reader();
    00E3 DFEB      RCALL	_disable_reader
(0063)         id_reader_flags = IDREADERFLAG_READED;
    00E4 E082      LDI	R24,2
    00E5 940E087B  CALL	0x87B
(0064)         //read ok.
(0065)         if(read_count==26) //id card.
    00E7 91800066  LDS	R24,read_count
    00E9 318A      CPI	R24,0x1A
    00EA F511      BNE	0x010D
(0066)         {
(0067)             if(!id_reader_check(id_code))
    00EB 91200062  LDS	R18,id_code+2
    00ED 91300063  LDS	R19,id_code+3
    00EF 91000060  LDS	R16,id_code
    00F1 91100061  LDS	R17,id_code+1
    00F3 DFE3      RCALL	_id_reader_check
    00F4 2300      TST	R16
    00F5 F009      BEQ	0x00F7
    00F6 C021      RJMP	0x0118
(0068)             {
(0069)                 id_code &= 0x01fffffe;
    00F7 EF4E      LDI	R20,0xFE
    00F8 EF5F      LDI	R21,0xFF
    00F9 EF6F      LDI	R22,0xFF
    00FA E071      LDI	R23,1
    00FB 940E07A7  CALL	0x7A7
    00FD 940E07CB  CALL	0x7CB
    00FF 940E0785  CALL	0x785
(0070)                 id_code >>= 1;
    0101 9456      LSR	R5
    0102 9447      ROR	R4
    0103 9437      ROR	R3
    0104 9427      ROR	R2
    0105 940E0785  CALL	0x785
(0071)                 password_handle(IDREADEDIDCARD, id_code);
    0107 8248      STD	Y+0,R4
    0108 8259      STD	Y+1,R5
    0109 0191      MOVW	R18,R2
    010A 2700      CLR	R16
    010B D16B      RCALL	_password_handle
(0072)             }
(0073)         }
    010C C00B      RJMP	0x0118
(0074)         else if(read_count==4)//keypad input.
    010D 91800066  LDS	R24,read_count
    010F 3084      CPI	R24,4
    0110 F439      BNE	0x0118
    0111 940E07A7  CALL	0x7A7
(0075)         {
(0076)             password_handle(IDREADEDKEYPAD, id_code);
    0113 8248      STD	Y+0,R4
    0114 8259      STD	Y+1,R5
    0115 0191      MOVW	R18,R2
    0116 E001      LDI	R16,1
    0117 D15F      RCALL	_password_handle
(0077)         }
(0078)         //enable reader.
(0079)         enable_reader();
    0118 DFBA      RCALL	_enable_reader
(0080)         id_reader_flags = IDREADERFLAG_WAITING;
    0119 2422      CLR	R2
    011A 2433      CLR	R3
    011B 92300065  STS	id_reader_flags+1,R3
    011D 92200064  STS	id_reader_flags,R2
(0081)         read_count = 0;
    011F 92200066  STS	read_count,R2
(0082)     }
(0083)     return;
    0121 9622      ADIW	R28,2
    0122 D549      RCALL	pop_gset3
    0123 9508      RET
_set_id_reading_status:
    0124 D551      RCALL	push_gset2
    0125 9722      SBIW	R28,2
(0084) }
(0085) //set status.
(0086) static void set_id_reading_status(void)
(0087) {
(0088)     if(id_reader_flags!=IDREADERFLAG_READING)
    0126 91800064  LDS	R24,id_reader_flags
    0128 91900065  LDS	R25,id_reader_flags+1
    012A 3081      CPI	R24,1
    012B E0E0      LDI	R30,0
    012C 079E      CPC	R25,R30
    012D F0A9      BEQ	0x0143
(0089)     {
(0090)         id_reader_flags = IDREADERFLAG_READING;
    012E E081      LDI	R24,1
    012F 940E087B  CALL	0x87B
    0131 940E078E  CALL	0x78E
(0091)         id_code = 0;
    0133 93500061  STS	id_code+1,R21
    0135 93400060  STS	id_code,R20
    0137 93700063  STS	id_code+3,R23
    0139 93600062  STS	id_code+2,R22
(0092)         //1*100ms.
(0093)         set_timer(IDREADERTIMEOUTTIMER, 1, read_time_out);
    013B E584      LDI	R24,0x54
    013C E090      LDI	R25,0
    013D 8399      STD	Y+1,R25
    013E 8388      STD	Y+0,R24
    013F E021      LDI	R18,1
    0140 E030      LDI	R19,0
    0141 2700      CLR	R16
    0142 D275      RCALL	_set_timer
(0094)     }
(0095)     return;
    0143 9622      ADIW	R28,2
    0144 D525      RCALL	pop_gset2
    0145 9508      RET
_int0_isr:
    0146 940E06BD  CALL	push_lset
    0148 D52D      RCALL	push_gset2
(0096) }
(0097) //pull id card id and keypad input.
(0098) #pragma interrupt_handler int0_isr:2
(0099) void int0_isr(void)
(0100) {
(0101)     set_id_reading_status();
    0149 DFDA      RCALL	_set_id_reading_status
(0102)     if(!(PINC&0x02))
    014A 9999      SBIC	0x13,1
    014B C013      RJMP	0x015F
    014C 940E07A7  CALL	0x7A7
(0103)     {
(0104)         id_code <<= 1;
    014E 0C22      LSL	R2
    014F 1C33      ROL	R3
    0150 1C44      ROL	R4
    0151 1C55      ROL	R5
    0152 940E0785  CALL	0x785
    0154 940E07A2  CALL	0x7A2
(0105)         id_code |= 1;
    0156 2A24      OR	R2,R20
    0157 2A35      OR	R3,R21
    0158 2A46      OR	R4,R22
    0159 2A57      OR	R5,R23
    015A 940E0785  CALL	0x785
    015C 940E086F  CALL	0x86F
(0106)         ++read_count;
(0107)     }
    015E C00C      RJMP	0x016B
(0108)     else if(!(PINC&0x01))
    015F 9998      SBIC	0x13,0
    0160 C00A      RJMP	0x016B
    0161 940E07A7  CALL	0x7A7
(0109)     {
(0110)         id_code <<= 1;
    0163 0C22      LSL	R2
    0164 1C33      ROL	R3
    0165 1C44      ROL	R4
    0166 1C55      ROL	R5
    0167 940E0785  CALL	0x785
    0169 940E086F  CALL	0x86F
(0111)         ++read_count;
(0112)     }
(0113)     return;
    016B D4FE      RCALL	pop_gset2
    016C D563      RCALL	pop_lset
    016D 9518      RETI
FILE: D:\smarthome\smarthome\门禁系统资料\code\util.c
(0001) #include "util.h"
(0002) 
(0003) #define XTAL    8
(0004) void delay_1ms(void)
(0005) {
(0006)     int i;
(0007)     //XTAL*143-2 = 1142
(0008)     for(i=1;i<1142;i++);
_delay_1ms:
  i                    --> R16
    016E E001      LDI	R16,1
    016F E010      LDI	R17,0
    0170 5F0F      SUBI	R16,0xFF
    0171 4F1F      SBCI	R17,0xFF
    0172 3706      CPI	R16,0x76
    0173 E0E4      LDI	R30,4
    0174 071E      CPC	R17,R30
    0175 F3D4      BLT	0x0170
    0176 9508      RET
_delay_ms:
  i                    --> R20
  ms                   --> R22
    0177 D4FE      RCALL	push_gset2
    0178 01B8      MOVW	R22,R16
(0009) }
(0010) //=========================================
(0011) void delay_ms(int ms)
(0012) {
(0013)     int i=0;
    0179 2744      CLR	R20
    017A 2755      CLR	R21
    017B C003      RJMP	0x017F
(0014)     while(i<ms)
(0015)     {
(0016)         delay_1ms();
    017C DFF1      RCALL	_delay_1ms
(0017)         i++;
    017D 5F4F      SUBI	R20,0xFF
    017E 4F5F      SBCI	R21,0xFF
    017F 1746      CP	R20,R22
    0180 0757      CPC	R21,R23
    0181 F3D4      BLT	0x017C
    0182 D4E7      RCALL	pop_gset2
    0183 9508      RET
(0018)     }
(0019) }
(0020) 
(0021) void gotoSleep(void)
(0022) {
_gotoSleep:
    0184 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\tips.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "tips.h"
(0005) #include "util.h"
(0006) 
(0007) #define BEEP_ON (PORTB&=0xdf)
(0008) #define BEEP_OFF (PORTB|=0x20)
(0009) #define LED_ON (PORTB&=0xbf)
(0010) #define LED_OFF (PORTB|=0x40)
(0011) #define BOARD_LED_ON (PORTB&=0x7f)
(0012) #define BOARD_LED_OFF (PORTB|=0x80)
(0013) 
(0014) //pb5 beep,pb6 led, pb7 board led.
(0015) void tips_port_init(void)
(0016) {
(0017)     //PINB5 & PINB6 PINB0 tips led. OUTPUT AND pull-up resistors.
(0018)     PORTB |= 0xe0;
_tips_port_init:
    0185 B388      IN	R24,0x18
    0186 6E80      ORI	R24,0xE0
    0187 BB88      OUT	0x18,R24
(0019)     DDRB |= 0xe0;
    0188 B387      IN	R24,0x17
    0189 6E80      ORI	R24,0xE0
    018A BB87      OUT	0x17,R24
(0020)     return;
    018B 9508      RET
(0021) }
(0022) //led on.
(0023) void tips_led_on(void)
(0024) {
(0025)     LED_ON;
_tips_led_on:
    018C B388      IN	R24,0x18
    018D 7B8F      ANDI	R24,0xBF
    018E BB88      OUT	0x18,R24
(0026)     return;
    018F 9508      RET
(0027) }
(0028) //led off.
(0029) void tips_led_off(void)
(0030) {
(0031)     LED_OFF;
_tips_led_off:
    0190 9AC6      SBI	0x18,6
(0032)     return;
    0191 9508      RET
(0033) }
(0034) //beep on.
(0035) void tips_beep_on(void)
(0036) {
(0037)     BEEP_ON;
_tips_beep_on:
    0192 B388      IN	R24,0x18
    0193 7D8F      ANDI	R24,0xDF
    0194 BB88      OUT	0x18,R24
(0038)     return;
    0195 9508      RET
(0039) }
(0040) //beep off.
(0041) void tips_beep_off(void)
(0042) {
(0043)     BEEP_OFF;
_tips_beep_off:
    0196 9AC5      SBI	0x18,5
(0044)     return;
    0197 9508      RET
(0045) }
(0046) //__------__ 6 pices.pice per 0.4 seconds.
(0047) void tips_ok(void)
(0048) {
(0049)     LED_ON;
_tips_ok:
    0198 B388      IN	R24,0x18
    0199 7B8F      ANDI	R24,0xBF
    019A BB88      OUT	0x18,R24
    019B 940E0837  CALL	0x837
(0050)     BEEP_ON;
(0051)     //2.4 seconds.
(0052)     delay_ms(400);
    019D DFD9      RCALL	_delay_ms
(0053)     LED_OFF;
    019E 9AC6      SBI	0x18,6
(0054)     BEEP_OFF;
    019F 9AC5      SBI	0x18,5
(0055)     return;
    01A0 9508      RET
(0056) }
(0057) //_-_-___-_-_
(0058) void tips_err(void)
(0059) {
(0060)     BEEP_ON;
_tips_err:
    01A1 940E07B0  CALL	0x7B0
(0061)     delay_ms(100);
    01A3 DFD3      RCALL	_delay_ms
(0062)     BEEP_OFF;
    01A4 9AC5      SBI	0x18,5
(0063)     delay_ms(100);
    01A5 E604      LDI	R16,0x64
    01A6 E010      LDI	R17,0
    01A7 DFCF      RCALL	_delay_ms
    01A8 940E07B0  CALL	0x7B0
(0064)     BEEP_ON;
(0065)     delay_ms(100);
    01AA DFCC      RCALL	_delay_ms
(0066)     BEEP_OFF;
    01AB 9AC5      SBI	0x18,5
(0067)  
(0068)     delay_ms(200);
    01AC EC08      LDI	R16,0xC8
    01AD E010      LDI	R17,0
    01AE DFC8      RCALL	_delay_ms
    01AF 940E07B0  CALL	0x7B0
(0069)  
(0070)     BEEP_ON;
(0071)     delay_ms(100);
    01B1 DFC5      RCALL	_delay_ms
(0072)     BEEP_OFF;
    01B2 9AC5      SBI	0x18,5
(0073)     delay_ms(100);
    01B3 E604      LDI	R16,0x64
    01B4 E010      LDI	R17,0
    01B5 DFC1      RCALL	_delay_ms
    01B6 940E07B0  CALL	0x7B0
(0074)     BEEP_ON;
(0075)     delay_ms(100);
    01B8 DFBE      RCALL	_delay_ms
(0076)     BEEP_OFF;
    01B9 9AC5      SBI	0x18,5
(0077)     return;
    01BA 9508      RET
(0078) }
(0079) //_----_-_-_
(0080) void tips_id_ok(void)
(0081) {
(0082)     BEEP_ON;
_tips_id_ok:
    01BB B388      IN	R24,0x18
    01BC 7D8F      ANDI	R24,0xDF
    01BD BB88      OUT	0x18,R24
(0083)     delay_ms(200);
    01BE EC08      LDI	R16,0xC8
    01BF E010      LDI	R17,0
    01C0 DFB6      RCALL	_delay_ms
(0084)     BEEP_OFF;
    01C1 9AC5      SBI	0x18,5
(0085)     delay_ms(200);
    01C2 EC08      LDI	R16,0xC8
    01C3 E010      LDI	R17,0
    01C4 DFB2      RCALL	_delay_ms
    01C5 940E07B0  CALL	0x7B0
(0086) 
(0087)     BEEP_ON;
(0088)     delay_ms(100);
    01C7 DFAF      RCALL	_delay_ms
(0089)     BEEP_OFF;
    01C8 9AC5      SBI	0x18,5
(0090)     delay_ms(100);
    01C9 E604      LDI	R16,0x64
    01CA E010      LDI	R17,0
    01CB DFAB      RCALL	_delay_ms
    01CC 940E07B0  CALL	0x7B0
(0091)     BEEP_ON;
(0092)     delay_ms(100);
    01CE DFA8      RCALL	_delay_ms
(0093)     BEEP_OFF;
    01CF 9AC5      SBI	0x18,5
(0094)     return;
    01D0 9508      RET
    01D1 940E0837  CALL	0x837
(0095) }
(0096) //__------__-----__
(0097) void tips_ring_on(void)
(0098) {
(0099)     BEEP_ON;
(0100)     //2.4 seconds.
(0101)     delay_ms(400);
_tips_ring_on:
    01D3 DFA3      RCALL	_delay_ms
(0102)     BEEP_OFF;
    01D4 9AC5      SBI	0x18,5
(0103)     delay_ms(400);
    01D5 E900      LDI	R16,0x90
    01D6 E011      LDI	R17,1
    01D7 DF9F      RCALL	_delay_ms
    01D8 940E0837  CALL	0x837
(0104)     BEEP_ON;
(0105)     //2.4 seconds.
(0106)     delay_ms(400);
    01DA DF9C      RCALL	_delay_ms
(0107)     BEEP_OFF;
    01DB 9AC5      SBI	0x18,5
(0108)     return;
    01DC 9508      RET
(0109) }
(0110) void tips_board_led_on(void)
(0111) {
(0112) 	BOARD_LED_ON;
_tips_board_led_on:
    01DD B388      IN	R24,0x18
    01DE 778F      ANDI	R24,0x7F
    01DF BB88      OUT	0x18,R24
    01E0 9508      RET
(0113) }
(0114) 
(0115) void tips_board_led_off(void)
(0116) {
(0117) 	BOARD_LED_OFF;
_tips_board_led_off:
    01E1 9AC7      SBI	0x18,7
    01E2 9508      RET
_readPasswordItemNum:
  num                  --> Y+3
    01E3 9724      SBIW	R28,4
FILE: D:\smarthome\smarthome\门禁系统资料\code\password.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "log.h"
(0005) #include "locker.h"
(0006) #include "tips.h"
(0007) #include "timer.h"
(0008) #include "iic.h"
(0009) #include "eeprom.h"
(0010) #include "password.h"
(0011) #include "ringandscreen.h"
(0012) 
(0013) //eeprom 
(0014) //addr: 0 number.
(0015) 
(0016) // 1: flags
(0017) // 2,3,4,5: id Card.
(0018) // 6,7,8,9: password H
(0019) // 10,11,12,13 :password L
(0020) 
(0021) // 14: flags
(0022) // 15,16,17,18: id Card.
(0023) // 19,20,21,22: password H
(0024) // 23,24,25,26 :password L
(0025) 
(0026) unsigned char readPasswordItemNum(void)
(0027) {
(0028)     unsigned char num = 0;
    01E4 2422      CLR	R2
    01E5 822B      STD	Y+3,R2
(0029) 
(0030)     rw24c256(&num, 1, 0, RWREAD);
    01E6 E081      LDI	R24,1
    01E7 838A      STD	Y+2,R24
    01E8 940E0843  CALL	0x843
    01EA D2A6      RCALL	_rw24c256
(0031)     return num;
    01EB 810B      LDD	R16,Y+3
    01EC 9624      ADIW	R28,4
    01ED 9508      RET
_readPasswordItem:
  t                    --> Y+16
  item                 --> Y+3
  index                --> R22
    01EE D487      RCALL	push_gset2
    01EF 2F62      MOV	R22,R18
    01F0 01A8      MOVW	R20,R16
    01F1 9761      SBIW	R28,0x11
(0032) }
(0033) 
(0034) passwordItem_t readPasswordItem(unsigned char index)
(0035) {
(0036)     passwordItem_t item;
(0037)     unsigned char t = 0;
    01F2 2422      CLR	R2
    01F3 8A28      STD	Y+16,R2
    01F4 940E080A  CALL	0x80A
    01F6 940E0895  CALL	0x895
(0038) 
(0039)     rw24c256(&t, 1, index*13+1, RWREAD);
    01F8 018E      MOVW	R16,R28
    01F9 5F00      SUBI	R16,0xF0
    01FA 4F1F      SBCI	R17,0xFF
    01FB D295      RCALL	_rw24c256
(0040)     item.flags = t;
    01FC 8828      LDD	R2,Y+16
    01FD 822B      STD	Y+3,R2
    01FE 940E080A  CALL	0x80A
(0041) 
(0042)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWREAD);
    0200 9602      ADIW	R24,2
    0201 940E0853  CALL	0x853
    0203 5F0C      SUBI	R16,0xFC
    0204 4F1F      SBCI	R17,0xFF
    0205 D28B      RCALL	_rw24c256
    0206 940E080A  CALL	0x80A
(0043)     
(0044)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWREAD);
    0208 9606      ADIW	R24,6
    0209 940E0853  CALL	0x853
    020B 5F08      SUBI	R16,0xF8
    020C 4F1F      SBCI	R17,0xFF
    020D D283      RCALL	_rw24c256
    020E 940E080A  CALL	0x80A
(0045) 	
(0046)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWREAD);
    0210 960A      ADIW	R24,0xA
    0211 940E0853  CALL	0x853
    0213 5F04      SUBI	R16,0xF4
    0214 4F1F      SBCI	R17,0xFF
    0215 D27B      RCALL	_rw24c256
(0047)     
(0048)     return item;
    0216 01CE      MOVW	R24,R28
    0217 9603      ADIW	R24,3
    0218 E00D      LDI	R16,0xD
    0219 E010      LDI	R17,0
    021A 935A      ST	R21,-Y
    021B 934A      ST	R20,-Y
    021C 939A      ST	R25,-Y
    021D 938A      ST	R24,-Y
    021E D4F9      RCALL	asgnblk
    021F 9661      ADIW	R28,0x11
    0220 D449      RCALL	pop_gset2
    0221 9508      RET
_insertPasswordItem:
  item                 --> R20
  index                --> R22
    0222 D453      RCALL	push_gset2
    0223 01A9      MOVW	R20,R18
    0224 2F60      MOV	R22,R16
    0225 9723      SBIW	R28,3
    0226 940E0804  CALL	0x804
    0228 940E0895  CALL	0x895
(0049) }
(0050) 
(0051) void insertPasswordItem(unsigned char index, passwordItem_t item)
(0052) {
(0053)     rw24c256(&(item.flags), 1, index*13+1, RWWRITE);
    022A 018A      MOVW	R16,R20
    022B D265      RCALL	_rw24c256
    022C 940E0804  CALL	0x804
(0054) 	
(0055)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RWWRITE);
    022E 9602      ADIW	R24,2
    022F 940E0858  CALL	0x858
    0231 5F0F      SUBI	R16,0xFF
    0232 4F1F      SBCI	R17,0xFF
    0233 D25D      RCALL	_rw24c256
    0234 940E0804  CALL	0x804
(0056) 	
(0057)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RWWRITE);
    0236 9606      ADIW	R24,6
    0237 940E0858  CALL	0x858
    0239 5F0B      SUBI	R16,0xFB
    023A 4F1F      SBCI	R17,0xFF
    023B D255      RCALL	_rw24c256
    023C 940E0804  CALL	0x804
(0058) 	
(0059)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RWWRITE);
    023E 960A      ADIW	R24,0xA
    023F 940E0858  CALL	0x858
    0241 5F07      SUBI	R16,0xF7
    0242 4F1F      SBCI	R17,0xFF
    0243 D24D      RCALL	_rw24c256
(0060) 	
(0061)     return;
    0244 9623      ADIW	R28,3
    0245 D424      RCALL	pop_gset2
    0246 9508      RET
_writePasswordItemNum:
  num                  --> Y+3
    0247 931A      ST	R17,-Y
    0248 930A      ST	R16,-Y
    0249 9723      SBIW	R28,3
(0062) }
(0063) 
(0064) void writePasswordItemNum(unsigned char num)
(0065) {
(0066)     rw24c256(&num, 1, 0, RWWRITE);
    024A 2422      CLR	R2
    024B 822A      STD	Y+2,R2
    024C 940E0843  CALL	0x843
    024E D242      RCALL	_rw24c256
(0067)     return;
    024F 9625      ADIW	R28,5
    0250 9508      RET
_clear_pswd_status:
    0251 D424      RCALL	push_gset2
    0252 940E07A2  CALL	0x7A2
(0068) }
(0069) 
(0070) #define PASSWORDREADIDCARDUNKOWN    0
(0071) #define PASSWORDREADIDCARDOK                1
(0072) #define PASSWORDREADIDANDPSWDOK         2
(0073) 
(0074) static unsigned char password_read_flags = 0;
(0075) static unsigned char current_index = 0;
(0076) static unsigned char input_err_count = 0;
(0077) 
(0078) //You input xxx then password is 1xxx.
(0079) static unsigned long passwordH = 1;
(0080) static unsigned long passwordL = 1;
(0081) 
(0082) static void clear_pswd_status(void)
(0083) {
(0084)     //clear last password input.
(0085)     passwordH = 1;
    0254 9350006B  STS	passwordH+1,R21
    0256 9340006A  STS	passwordH,R20
    0258 9370006D  STS	passwordH+3,R23
    025A 9360006C  STS	passwordH+2,R22
    025C 940E07A2  CALL	0x7A2
    025E 940E0828  CALL	0x828
(0086)     passwordL = 1;
(0087)     tips_led_off();
    0260 DF2F      RCALL	_tips_led_off
(0088)     password_read_flags = PASSWORDREADIDCARDUNKOWN;
    0261 2422      CLR	R2
    0262 92200067  STS	password_read_flags,R2
(0089)     current_index = 0;
    0264 92200068  STS	current_index,R2
(0090)     stop_timer(PASSWORDTIMEOUTTIMER);
    0266 E001      LDI	R16,1
    0267 D170      RCALL	_stop_timer
(0091)     return;
    0268 D401      RCALL	pop_gset2
    0269 9508      RET
(0092) }
(0093) 
(0094) //cannot input timeout.
(0095) static void cannot_input_time_out(char timer)
(0096) {
(0097)     if(timer==PASSWORDTIMEOUTTIMER)
_cannot_input_time_out:
  timer                --> R16
    026A 3001      CPI	R16,1
    026B F419      BNE	0x026F
(0098)         input_err_count = 0;
    026C 2422      CLR	R2
    026D 92200069  STS	input_err_count,R2
(0099)     return;
    026F 9508      RET
_input_time_out:
  timer                --> R20
    0270 D407      RCALL	push_gset1
    0271 2F40      MOV	R20,R16
(0100) }
(0101) 
(0102) //input timeout.
(0103) static void input_time_out(char timer)
(0104) {
(0105)     if(timer==PASSWORDTIMEOUTTIMER)
    0272 3041      CPI	R20,1
    0273 F409      BNE	0x0275
(0106)         clear_pswd_status();
    0274 DFDC      RCALL	_clear_pswd_status
(0107)     return;
    0275 D405      RCALL	pop_gset1
    0276 9508      RET
_password_handle:
  current_item         --> Y+25
  pswd_item_num        --> R10
  i                    --> R12
  item                 --> Y+12
  code                 --> Y+48
  type                 --> R14
    0277 933A      ST	R19,-Y
    0278 932A      ST	R18,-Y
    0279 D3F6      RCALL	push_gset5
    027A 2EE0      MOV	R14,R16
    027B 97A6      SBIW	R28,0x26
(0108) }
(0109) 
(0110) void password_handle(char type, unsigned long code)
(0111) {
(0112)     unsigned char pswd_item_num = 0;
    027C 24AA      CLR	R10
(0113)     unsigned char i;
(0114)     passwordItem_t item;
(0115) 
(0116) 	//on screen
(0117) 	screen_on();
    027D D202      RCALL	_screen_on
(0118)     //if input error count is too large.
(0119)     if(input_err_count>5)
    027E E085      LDI	R24,5
    027F 90200069  LDS	R2,input_err_count
    0281 1582      CP	R24,R2
    0282 F458      BCC	0x028E
(0120)     {
(0121)         clear_pswd_status();
    0283 DFCD      RCALL	_clear_pswd_status
(0122)         tips_err();
    0284 DF1C      RCALL	_tips_err
(0123)         //set time out. 100ms*10*60
(0124)         set_timer(PASSWORDTIMEOUTTIMER, 600, cannot_input_time_out);
    0285 E588      LDI	R24,0x58
    0286 E090      LDI	R25,0
    0287 8399      STD	Y+1,R25
    0288 8388      STD	Y+0,R24
    0289 E528      LDI	R18,0x58
    028A E032      LDI	R19,2
    028B E001      LDI	R16,1
    028C D12B      RCALL	_set_timer
(0125)         return;
    028D C117      RJMP	0x03A5
(0126)     }
(0127)  
(0128)     //read a card.
(0129)     if(type==IDREADEDIDCARD)
    028E 20EE      TST	R14
    028F F009      BEQ	0x0291
    0290 C03F      RJMP	0x02D0
(0130)     {
(0131)         clear_pswd_status();
    0291 DFBF      RCALL	_clear_pswd_status
(0132)         //read paswd item num.
(0133)         pswd_item_num = readPasswordItemNum();
    0292 DF50      RCALL	_readPasswordItemNum
    0293 2EA0      MOV	R10,R16
(0134)         //loop find it.
(0135)         for(i=0;i<pswd_item_num;++i)
    0294 24CC      CLR	R12
    0295 C02D      RJMP	0x02C3
(0136)         {
(0137)             //read a item.
(0138)             item = readPasswordItem(i);
    0296 940E0881  CALL	0x881
    0298 DF55      RCALL	_readPasswordItem
(0139)             //if item need id card, and is this id card.
(0140)             if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
    0299 842C      LDD	R2,Y+12
    029A FE20      SBRS	R2,0
    029B C026      RJMP	0x02C2
    029C 01FE      MOVW	R30,R28
    029D A820      LDD	R2,Z+48
    029E A831      LDD	R3,Z+49
    029F A842      LDD	R4,Z+50
    02A0 A853      LDD	R5,Z+51
    02A1 01FE      MOVW	R30,R28
    02A2 8465      LDD	R6,Z+13
    02A3 8476      LDD	R7,Z+14
    02A4 8487      LDD	R8,Z+15
    02A5 8890      LDD	R9,Z+16
    02A6 940E07FF  CALL	0x7FF
    02A8 F009      BEQ	0x02AA
    02A9 C018      RJMP	0x02C2
(0141)             {
(0142)                 //need paswd.
(0143)                 if(item.flags&PASSWORDFLAGS_PASSWORD)
    02AA 842C      LDD	R2,Y+12
    02AB FE21      SBRS	R2,1
    02AC C00A      RJMP	0x02B7
(0144)                 {
(0145)                     //id card ok, but need password.
(0146)                     //tips_id_ok();
(0147)                     //id card ok, but not input password, led on.
(0148)                     tips_led_on();
    02AD DEDE      RCALL	_tips_led_on
(0149)                     current_index = i;
    02AE 92C00068  STS	current_index,R12
(0150)                     password_read_flags = PASSWORDREADIDCARDOK;
    02B0 E081      LDI	R24,1
    02B1 93800067  STS	password_read_flags,R24
    02B3 940E084B  CALL	0x84B
(0151)                     //set time out. 100ms*10*30
(0152)                     set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    02B5 D102      RCALL	_set_timer
(0153)                 }
    02B6 C0EE      RJMP	0x03A5
(0154)                 else //only id card.
(0155)                 {
(0156)                     //record log
(0157)                     log(LOGTYPEIDOK, i, code, 0, 0);
    02B7 940E0762  CALL	0x762
    02B9 2D2C      MOV	R18,R12
    02BA E001      LDI	R16,1
    02BB D18A      RCALL	_log
(0158)                     //clear pswd statuc.
(0159)                     clear_pswd_status();
    02BC DF94      RCALL	_clear_pswd_status
(0160)                     //tips_ok();
(0161)                     locker_unlock();
    02BD D1A1      RCALL	_locker_unlock
(0162)                     //error count clear.
(0163)                     input_err_count = 0;
    02BE 2422      CLR	R2
    02BF 92200069  STS	input_err_count,R2
(0164)                 } //else
(0165)                 return;
    02C1 C0E3      RJMP	0x03A5
    02C2 94C3      INC	R12
    02C3 14CA      CP	R12,R10
    02C4 F408      BCC	0x02C6
    02C5 CFD0      RJMP	0x0296
(0166)             }  //if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
(0167)         }	  //for(i=0;i<pswd_item_num;++i)
(0168)         //unkown id card.
(0169)         log(LOGTYPEIDERR, 0, code, 0, 0);
    02C6 940E0762  CALL	0x762
    02C8 2722      CLR	R18
    02C9 E002      LDI	R16,2
    02CA D17B      RCALL	_log
(0170)         //clear password.
(0171)         clear_pswd_status();
    02CB DF85      RCALL	_clear_pswd_status
(0172)         //error password and log.
(0173)         tips_err();
    02CC DED4      RCALL	_tips_err
    02CD 940E0831  CALL	0x831
(0174)         //error count ++
(0175)         ++input_err_count;
(0176)         return;
    02CF C0D5      RJMP	0x03A5
(0177)     }	  //if(type==IDREADEDIDCARD)
(0178)     else if(type==IDREADEDKEYPAD) // read a keypad input.
    02D0 2D8E      MOV	R24,R14
    02D1 3081      CPI	R24,1
    02D2 F009      BEQ	0x02D4
    02D3 C0D1      RJMP	0x03A5
(0179)     {
(0180)         code &= 0x0000000f;
    02D4 E04F      LDI	R20,0xF
    02D5 940E075D  CALL	0x75D
    02D7 940E07C6  CALL	0x7C6
    02D9 940E07CB  CALL	0x7CB
    02DB 01FE      MOVW	R30,R28
    02DC AA20      STD	Z+48,R2
    02DD AA31      STD	Z+49,R3
    02DE AA42      STD	Z+50,R4
    02DF AA53      STD	Z+51,R5
(0181)         if(code == 0x0000000a)  //*
    02E0 E04A      LDI	R20,0xA
    02E1 940E075D  CALL	0x75D
    02E3 940E07C6  CALL	0x7C6
    02E5 940E0890  CALL	0x890
    02E7 F411      BNE	0x02EA
(0182)         {
(0183)             //clear password.
(0184)             clear_pswd_status();
    02E8 DF68      RCALL	_clear_pswd_status
(0185)         }
    02E9 C0BB      RJMP	0x03A5
(0186)         else if(code == 0x0000000b) //#
    02EA E04B      LDI	R20,0xB
    02EB 940E075D  CALL	0x75D
    02ED 940E07C6  CALL	0x7C6
    02EF 940E0890  CALL	0x890
    02F1 F009      BEQ	0x02F3
    02F2 C07B      RJMP	0x036E
(0187)         {
(0188)             //need id card password.
(0189)             if(password_read_flags==PASSWORDREADIDCARDOK)
    02F3 91800067  LDS	R24,password_read_flags
    02F5 3081      CPI	R24,1
    02F6 F009      BEQ	0x02F8
    02F7 C034      RJMP	0x032C
(0190)             {
(0191)                 passwordItem_t current_item = readPasswordItem(current_index);
    02F8 91200068  LDS	R18,current_index
    02FA 018E      MOVW	R16,R28
    02FB 5E07      SUBI	R16,0xE7
    02FC 4F1F      SBCI	R17,0xFF
    02FD DEF0      RCALL	_readPasswordItem
    02FE 940E077C  CALL	0x77C
(0192)                 //password is ok.
(0193)                 if((current_item.passwordH==passwordH)&&(current_item.passwordL==passwordL))
    0300 01FE      MOVW	R30,R28
    0301 8C66      LDD	R6,Z+30
    0302 8C77      LDD	R7,Z+31
    0303 A080      LDD	R8,Z+32
    0304 A091      LDD	R9,Z+33
    0305 940E07FF  CALL	0x7FF
    0307 F009      BEQ	0x0309
    0308 C016      RJMP	0x031F
    0309 940E0793  CALL	0x793
    030B 01FE      MOVW	R30,R28
    030C A062      LDD	R6,Z+34
    030D A073      LDD	R7,Z+35
    030E A084      LDD	R8,Z+36
    030F A095      LDD	R9,Z+37
    0310 940E07FF  CALL	0x7FF
    0312 F461      BNE	0x031F
    0313 940E074C  CALL	0x74C
    0315 940E07D0  CALL	0x7D0
(0194)                 {
(0195)                     log(LOGTYPEIDANDPSWDOK, current_index, current_item.idCard, passwordH, passwordL);
    0317 E003      LDI	R16,3
    0318 D12D      RCALL	_log
(0196)                     //clear password status.
(0197)                     clear_pswd_status();
    0319 DF37      RCALL	_clear_pswd_status
(0198)                     //unlock and write log.
(0199)                     //tips_ok();
(0200)                     locker_unlock();
    031A D144      RCALL	_locker_unlock
(0201)                     //error count clear.
(0202)                     input_err_count = 0;
    031B 2422      CLR	R2
    031C 92200069  STS	input_err_count,R2
(0203)                 }
    031E C086      RJMP	0x03A5
(0204)                 else //password is error.
(0205)                 {
(0206)                     log(LOGTYPEIDANDPSWDERR, current_index, current_item.idCard, passwordH, passwordL);
    031F 940E0793  CALL	0x793
    0321 940E074C  CALL	0x74C
    0323 940E07D0  CALL	0x7D0
    0325 E004      LDI	R16,4
    0326 D11F      RCALL	_log
(0207)                     //clear password.
(0208)                     clear_pswd_status();
    0327 DF29      RCALL	_clear_pswd_status
(0209)                     //error password and log.
(0210)                     tips_err();
    0328 DE78      RCALL	_tips_err
    0329 940E0831  CALL	0x831
(0211)                     //error count ++.
(0212)                     ++input_err_count;
(0213)                 }
(0214)             }
    032B C079      RJMP	0x03A5
(0215)             else //only password.
(0216)             {
(0217)                 //read paswd item num.
(0218)                 pswd_item_num = readPasswordItemNum();
    032C DEB6      RCALL	_readPasswordItemNum
    032D 2EA0      MOV	R10,R16
(0219)                 //loop find it.
(0220)                 for(i=0;i<pswd_item_num;++i)
    032E 24CC      CLR	R12
    032F C02B      RJMP	0x035B
(0221)                 {
(0222)                     //read a item.
(0223)                     item = readPasswordItem(i);
    0330 940E0881  CALL	0x881
    0332 DEBB      RCALL	_readPasswordItem
(0224)                     //if item need id card, and is this id card.
(0225)                     if((item.flags==PASSWORDFLAGS_PASSWORD)&&(item.passwordH==passwordH)
    0333 858C      LDD	R24,Y+12
    0334 3082      CPI	R24,2
    0335 F009      BEQ	0x0337
    0336 C023      RJMP	0x035A
    0337 940E077C  CALL	0x77C
    0339 01FE      MOVW	R30,R28
    033A 8861      LDD	R6,Z+17
    033B 8872      LDD	R7,Z+18
    033C 8883      LDD	R8,Z+19
    033D 8894      LDD	R9,Z+20
    033E 940E07FF  CALL	0x7FF
    0340 F4C9      BNE	0x035A
    0341 940E0793  CALL	0x793
    0343 01FE      MOVW	R30,R28
    0344 8865      LDD	R6,Z+21
    0345 8876      LDD	R7,Z+22
    0346 8887      LDD	R8,Z+23
    0347 8C90      LDD	R9,Z+24
    0348 940E07FF  CALL	0x7FF
    034A F479      BNE	0x035A
    034B 940E074C  CALL	0x74C
    034D 940E078E  CALL	0x78E
    034F 940E089A  CALL	0x89A
(0226)                         &&(item.passwordL==passwordL))
(0227)                     {
(0228)                         log(LOGTYPEPSWDOK, i, 0, passwordH, passwordL);
    0351 2D2C      MOV	R18,R12
    0352 E005      LDI	R16,5
    0353 D0F2      RCALL	_log
(0229)                         //clear password.
(0230)                         clear_pswd_status();
    0354 DEFC      RCALL	_clear_pswd_status
(0231)                         //password is right. unlock and log.
(0232)                         //tips_ok();
(0233)                         locker_unlock();
    0355 D109      RCALL	_locker_unlock
(0234)                         //error count clear.
(0235)                         input_err_count = 0;
    0356 2422      CLR	R2
    0357 92200069  STS	input_err_count,R2
(0236)                         return;
    0359 C04B      RJMP	0x03A5
    035A 94C3      INC	R12
    035B 14CA      CP	R12,R10
    035C F408      BCC	0x035E
    035D CFD2      RJMP	0x0330
(0237)                     }
(0238)                 }
(0239)                 //password is error.
(0240)                 log(LOGTYPEPSWDERR, 0, 0, passwordH, passwordL);
    035E 940E0793  CALL	0x793
    0360 940E074C  CALL	0x74C
    0362 940E078E  CALL	0x78E
    0364 940E089A  CALL	0x89A
    0366 2722      CLR	R18
    0367 E006      LDI	R16,6
    0368 D0DD      RCALL	_log
(0241)                 //clear password.
(0242)                 clear_pswd_status();
    0369 DEE7      RCALL	_clear_pswd_status
(0243)                 //password is error, and log.
(0244)                 tips_err();
    036A DE36      RCALL	_tips_err
    036B 940E0831  CALL	0x831
(0245)                 //error count++.
(0246)                 ++input_err_count;
(0247)                 return;
    036D C037      RJMP	0x03A5
(0248)             }
(0249)         }
(0250)         else
(0251)         {
(0252)             tips_led_on();
    036E DE1D      RCALL	_tips_led_on
    036F 940E084B  CALL	0x84B
(0253)             //set time out. 100ms*10*30
(0254)             set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    0371 D046      RCALL	_set_timer
    0372 940E0793  CALL	0x793
(0255)             passwordL = passwordL*10 + code;
    0374 E04A      LDI	R20,0xA
    0375 E050      LDI	R21,0
    0376 E060      LDI	R22,0
    0377 E070      LDI	R23,0
    0378 940E088B  CALL	0x88B
    037A 018A      MOVW	R16,R20
    037B 019B      MOVW	R18,R22
    037C D2C1      RCALL	empy32u
    037D 0118      MOVW	R2,R16
    037E 0129      MOVW	R4,R18
    037F 01FE      MOVW	R30,R28
    0380 A860      LDD	R6,Z+48
    0381 A871      LDD	R7,Z+49
    0382 A882      LDD	R8,Z+50
    0383 A893      LDD	R9,Z+51
    0384 0C26      ADD	R2,R6
    0385 1C37      ADC	R3,R7
    0386 1C48      ADC	R4,R8
    0387 1C59      ADC	R5,R9
    0388 9230006F  STS	passwordL+1,R3
    038A 9220006E  STS	passwordL,R2
    038C 92500071  STS	passwordL+3,R5
    038E 92400070  STS	passwordL+2,R4
(0256)             //passwordH save password hight 9 num.
(0257)             if(passwordL>999999999)
    0390 EF4F      LDI	R20,0xFF
    0391 EC59      LDI	R21,0xC9
    0392 E96A      LDI	R22,0x9A
    0393 E37B      LDI	R23,0x3B
    0394 1542      CP	R20,R2
    0395 0553      CPC	R21,R3
    0396 0564      CPC	R22,R4
    0397 0575      CPC	R23,R5
    0398 F460      BCC	0x03A5
(0258)             {
(0259)                 passwordH = passwordL;
    0399 9230006B  STS	passwordH+1,R3
    039B 9220006A  STS	passwordH,R2
    039D 9250006D  STS	passwordH+3,R5
    039F 9240006C  STS	passwordH+2,R4
    03A1 940E07A2  CALL	0x7A2
    03A3 940E0828  CALL	0x828
(0260)                 passwordL = 1;
(0261)             }
(0262)         }
(0263)     }
(0264)     return;
    03A5 96A6      ADIW	R28,0x26
    03A6 D2C7      RCALL	pop_gset5
    03A7 9622      ADIW	R28,2
    03A8 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\timer.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "timer.h"
(0005) 
(0006) void timer_init(void)
(0007) {
(0008)     //enable interrupt.
(0009)     SREG |= 0x80;
_timer_init:
    03A9 9478      BSET	7
(0010)     //timer0 normal mode.ck/1024.
(0011)     TCCR0 |= 0x05;
    03AA B783      IN	R24,0x33
    03AB 6085      ORI	R24,5
    03AC BF83      OUT	0x33,R24
(0012)     //init TCNT0.
(0013)     TCNT0 = 0;
    03AD 2422      CLR	R2
    03AE BE22      OUT	0x32,R2
(0014)     //TIMSK
(0015)     //TIMSK |= 0x01;
(0016)     return; 
    03AF 9508      RET
(0017) }
(0018) //cpu timer0 start
(0019) static void t0_start(void)
(0020) {
(0021)     TIMSK |= 0x01;
_t0_start:
    03B0 B789      IN	R24,0x39
    03B1 6081      ORI	R24,1
    03B2 BF89      OUT	0x39,R24
(0022)     return;
    03B3 9508      RET
(0023) }
(0024) //cpu timer0 stop
(0025) static void t0_stop(void)
(0026) {
(0027)     TIMSK &= 0xfe;
_t0_stop:
    03B4 B789      IN	R24,0x39
    03B5 7F8E      ANDI	R24,0xFE
    03B6 BF89      OUT	0x39,R24
(0028)     return;
    03B7 9508      RET
_set_timer:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    03B8 D2BD      RCALL	push_gset2
    03B9 01B9      MOVW	R22,R18
    03BA 2F40      MOV	R20,R16
(0029) }
(0030) //
(0031) static timer_t g_timer[MAXTIMER];
(0032) //set timer and start timer. set value 0, need wait a cpu timer pice.
(0033) void set_timer(char timer, int value, timerCB cb)
(0034) {
(0035)     //value=0, stoped timer.
(0036)     g_timer[timer].value = value+1;
    03BB E084      LDI	R24,4
    03BC 9F84      MUL	R24,R20
    03BD 940E079C  CALL	0x79C
    03BF 01CB      MOVW	R24,R22
    03C0 9601      ADIW	R24,1
    03C1 8391      STD	Z+1,R25
    03C2 8380      STD	Z+0,R24
(0037)     g_timer[timer].cb = cb;
    03C3 E084      LDI	R24,4
    03C4 9F84      MUL	R24,R20
    03C5 940E07F9  CALL	0x7F9
    03C7 800C      LDD	R0,Y+4
    03C8 801D      LDD	R1,Y+5
    03C9 8211      STD	Z+1,R1
    03CA 8200      STD	Z+0,R0
(0038)     if(g_timer[timer].value)
    03CB E084      LDI	R24,4
    03CC 9F84      MUL	R24,R20
    03CD 940E079C  CALL	0x79C
    03CF 8020      LDD	R2,Z+0
    03D0 8031      LDD	R3,Z+1
    03D1 2022      TST	R2
    03D2 F411      BNE	0x03D5
    03D3 2033      TST	R3
    03D4 F009      BEQ	0x03D6
(0039)         t0_start();
    03D5 DFDA      RCALL	_t0_start
(0040)     return;
    03D6 D293      RCALL	pop_gset2
    03D7 9508      RET
(0041) }
(0042) //stop timer and clean timer.
(0043) void stop_timer(char timer)
(0044) {
(0045)     if(g_timer[timer].value)
_stop_timer:
  timer                --> R16
    03D8 E084      LDI	R24,4
    03D9 9F80      MUL	R24,R16
    03DA 940E079C  CALL	0x79C
    03DC 8020      LDD	R2,Z+0
    03DD 8031      LDD	R3,Z+1
    03DE 2022      TST	R2
    03DF F411      BNE	0x03E2
    03E0 2033      TST	R3
    03E1 F059      BEQ	0x03ED
(0046)     {
(0047)         //stop this timer.
(0048)         g_timer[timer].value = 0;
    03E2 E084      LDI	R24,4
    03E3 9F80      MUL	R24,R16
    03E4 940E079C  CALL	0x79C
    03E6 940E0875  CALL	0x875
(0049)         g_timer[timer].cb = 0;
    03E8 9F80      MUL	R24,R16
    03E9 940E07F9  CALL	0x7F9
    03EB 8231      STD	Z+1,R3
    03EC 8220      STD	Z+0,R2
(0050)     }
(0051)     return;
    03ED 9508      RET
_timer0_isr:
  running_timer_count  --> R20
  i                    --> R22
    03EE D2CE      RCALL	push_lset
    03EF D286      RCALL	push_gset2
(0052) }
(0053) //timer spank.
(0054) #pragma interrupt_handler timer0_isr:10
(0055) void timer0_isr(void)
(0056) {
(0057)     static char time_pices = 0;
(0058)     ++time_pices;
    03F0 91800072  LDS	R24,time_pices
    03F2 5F8F      SUBI	R24,0xFF
    03F3 93800072  STS	time_pices,R24
(0059)     //200ms.
(0060)     if(time_pices == 2)
    03F5 3082      CPI	R24,2
    03F6 F009      BEQ	0x03F8
    03F7 C04B      RJMP	0x0443
(0061)     {
(0062)         char running_timer_count = 0;
    03F8 2744      CLR	R20
(0063)         char i;
(0064)         for(i=0;i<MAXTIMER;i++)
    03F9 2766      CLR	R22
    03FA C03F      RJMP	0x043A
(0065)         {
(0066)             if(g_timer[i].value>1)
    03FB E084      LDI	R24,4
    03FC 9F86      MUL	R24,R22
    03FD 940E079C  CALL	0x79C
    03FF 8020      LDD	R2,Z+0
    0400 8031      LDD	R3,Z+1
    0401 E081      LDI	R24,1
    0402 E090      LDI	R25,0
    0403 1582      CP	R24,R2
    0404 0593      CPC	R25,R3
    0405 F478      BCC	0x0415
(0067)             {
(0068)                 --g_timer[i].value;
    0406 E084      LDI	R24,4
    0407 9F86      MUL	R24,R22
    0408 0110      MOVW	R2,R0
    0409 E783      LDI	R24,0x73
    040A E090      LDI	R25,0
    040B 0E28      ADD	R2,R24
    040C 1E39      ADC	R3,R25
    040D 01F1      MOVW	R30,R2
    040E 8180      LDD	R24,Z+0
    040F 8191      LDD	R25,Z+1
    0410 9701      SBIW	R24,1
    0411 8391      STD	Z+1,R25
    0412 8380      STD	Z+0,R24
(0069)                 ++running_timer_count;
    0413 9543      INC	R20
(0070)             }
    0414 C024      RJMP	0x0439
(0071)             //timer call back.
(0072)             else if(g_timer[i].value==1)
    0415 E084      LDI	R24,4
    0416 9F86      MUL	R24,R22
    0417 940E079C  CALL	0x79C
    0419 8180      LDD	R24,Z+0
    041A 8191      LDD	R25,Z+1
    041B 3081      CPI	R24,1
    041C E0E0      LDI	R30,0
    041D 079E      CPC	R25,R30
    041E F4D1      BNE	0x0439
(0073)             {
(0074)                 g_timer[i].value = 0;
    041F E084      LDI	R24,4
    0420 9F86      MUL	R24,R22
    0421 940E079C  CALL	0x79C
    0423 940E0875  CALL	0x875
(0075)                 if(g_timer[i].cb)
    0425 9F86      MUL	R24,R22
    0426 940E07F9  CALL	0x7F9
    0428 8020      LDD	R2,Z+0
    0429 8031      LDD	R3,Z+1
    042A 2022      TST	R2
    042B F411      BNE	0x042E
    042C 2033      TST	R3
    042D F059      BEQ	0x0439
(0076)                 {
(0077)                     //disable cpu timer.
(0078)                     t0_stop();
    042E DF85      RCALL	_t0_stop
(0079)                     (g_timer[i].cb)(i);
    042F 2F06      MOV	R16,R22
    0430 E084      LDI	R24,4
    0431 9F86      MUL	R24,R22
    0432 940E07F9  CALL	0x7F9
    0434 81A0      LDD	R26,Z+0
    0435 81B1      LDD	R27,Z+1
    0436 01FD      MOVW	R30,R26
    0437 D257      RCALL	xicall
(0080)                     //enable cpu timer.
(0081)                     t0_start();
    0438 DF77      RCALL	_t0_start
    0439 9563      INC	R22
    043A 3063      CPI	R22,3
    043B F408      BCC	0x043D
    043C CFBE      RJMP	0x03FB
(0082)                 }
(0083)             }
(0084)         }
(0085)         time_pices = 0;
    043D 2422      CLR	R2
    043E 92200072  STS	time_pices,R2
(0086)         //if no timer running, stop cpu timer.
(0087)         if(!running_timer_count) t0_stop();
    0440 2344      TST	R20
    0441 F409      BNE	0x0443
    0442 DF71      RCALL	_t0_stop
(0088)     }
(0089)     return;
    0443 D226      RCALL	pop_gset2
    0444 D28B      RCALL	pop_lset
    0445 9518      RETI
FILE: D:\smarthome\smarthome\门禁系统资料\code\log.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "log.h"
(0004) 
(0005) void log(char type, unsigned char index, unsigned long id_code, unsigned long pswdH, unsigned long pswdL)
(0006) {
_log:
  pswdL                --> Y+12
  pswdH                --> Y+8
  id_code              --> Y+4
  index                --> Y+2
  type                 --> Y+0
    0446 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\locker.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "timer.h"
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "locker.h"
(0007) 
(0008) #define LOCKERINIT (PORTB&=0xe7)
(0009) #define LOCKERUNLOCK (PORTB&=0xf7,PORTB|=0x10)
(0010) #define LOCKERLOCK (PORTB&=0xef,PORTB|=0x08)
(0011) 
(0012) void locker_init(void)
(0013) {
(0014)     //pb3 pb4 OUTPUT.
(0015)     DDRB |= 0x18;
_locker_init:
    0447 B387      IN	R24,0x17
    0448 6188      ORI	R24,0x18
    0449 BB87      OUT	0x17,R24
(0016)     //output low
(0017)     PORTB &= 0xe7;
    044A B388      IN	R24,0x18
    044B 7E87      ANDI	R24,0xE7
    044C BB88      OUT	0x18,R24
(0018)     return;
    044D 9508      RET
_unlock_time_out:
  timer                --> R20
    044E D229      RCALL	push_gset1
    044F 2F40      MOV	R20,R16
(0019) }
(0020) 
(0021) //unlock timeout.
(0022) static void unlock_time_out(char timer)
(0023) {
(0024)     if(timer==UNLOCKTIMEOUTTIMER)
    0450 3042      CPI	R20,2
    0451 F459      BNE	0x045D
(0025)     {
(0026) 		LOCKERLOCK;
    0452 B388      IN	R24,0x18
    0453 7E8F      ANDI	R24,0xEF
    0454 BB88      OUT	0x18,R24
    0455 9AC3      SBI	0x18,3
(0027) 		delay_ms(800);
    0456 E200      LDI	R16,0x20
    0457 E013      LDI	R17,3
    0458 DD1E      RCALL	_delay_ms
(0028) 		LOCKERINIT;
    0459 B388      IN	R24,0x18
    045A 7E87      ANDI	R24,0xE7
    045B BB88      OUT	0x18,R24
(0029) 		tips_board_led_off();
    045C DD84      RCALL	_tips_board_led_off
(0030) 	}
(0031)     return;
    045D D21D      RCALL	pop_gset1
    045E 9508      RET
_locker_unlock:
    045F 9722      SBIW	R28,2
(0032) }
(0033) 
(0034) void locker_unlock(void)
(0035) {
(0036) 	LOCKERUNLOCK;	
    0460 B388      IN	R24,0x18
    0461 7F87      ANDI	R24,0xF7
    0462 BB88      OUT	0x18,R24
    0463 9AC4      SBI	0x18,4
(0037)     delay_ms(800);
    0464 E200      LDI	R16,0x20
    0465 E013      LDI	R17,3
    0466 DD10      RCALL	_delay_ms
(0038) 	LOCKERINIT;
    0467 B388      IN	R24,0x18
    0468 7E87      ANDI	R24,0xE7
    0469 BB88      OUT	0x18,R24
(0039) 	//set time out. 
(0040) 	set_timer(UNLOCKTIMEOUTTIMER, 100, unlock_time_out);
    046A E58A      LDI	R24,0x5A
    046B E090      LDI	R25,0
    046C 8399      STD	Y+1,R25
    046D 8388      STD	Y+0,R24
    046E E624      LDI	R18,0x64
    046F E030      LDI	R19,0
    0470 E002      LDI	R16,2
    0471 DF46      RCALL	_set_timer
(0041) 	tips_board_led_on();
    0472 DD6A      RCALL	_tips_board_led_on
(0042) 	return;
    0473 9622      ADIW	R28,2
    0474 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\ringandscreen.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "timer.h"
(0007) #include "ringandscreen.h"
(0008) 
(0009) //door monitor input is pa0.
(0010) //screen power output pb2.
(0011) 
(0012) #define SCREEN_ON (PORTB &= 0xfb)
(0013) #define SCREEN_OFF (PORTB |= 0x04)
(0014) 
(0015) void doorandscreen_init(void)
(0016) {
(0017)     //PA0 INPUT.
(0018)     DDRA &= 0xfe;
_doorandscreen_init:
    0475 B38A      IN	R24,0x1A
    0476 7F8E      ANDI	R24,0xFE
    0477 BB8A      OUT	0x1A,R24
(0019) 	PORTA |= 0x01;
    0478 9AD8      SBI	0x1B,0
(0020)     //pb2 hi-z
(0021)     DDRB &= 0xfb;
    0479 B387      IN	R24,0x17
    047A 7F8B      ANDI	R24,0xFB
    047B BB87      OUT	0x17,R24
(0022)     PORTB &= 0xfb;
    047C B388      IN	R24,0x18
    047D 7F8B      ANDI	R24,0xFB
    047E BB88      OUT	0x18,R24
(0023)     //init interrput.
(0024)     return;
    047F 9508      RET
(0025) }
(0026) 
(0027) /**
(0028) #define SCREEN_RESET_START (PORTC&=0xef)
(0029) #define SCREEN_RESET_STOP (PORTC|=0x10)
(0030) #define RING_ON (PORTC&=0xdf)
(0031) #define RING_OFF (PORTC&=0x20)
(0032) 
(0033) void ringandscreen_init(void)
(0034) {
(0035)     //PC0,PC1,PC2 INPUT.
(0036)     DDRC &= 0xf8;
(0037)     //PC3,PC4,PC5 OUTPUT.
(0038)     DDRC |= 0x38;
(0039)     //
(0040)     PORTC = 0xff;
(0041)     //init interrput.
(0042)     return;
(0043) }
(0044) 
(0045) static void disable_input(void)
(0046) {
(0047) 
(0048) }
(0049) 
(0050) static void enable_input(void)
(0051) {
(0052) 
(0053) }
(0054) 
(0055) void screen_on(void)
(0056) {
(0057)     if((PORTC&=0x04))
(0058)     {
(0059)         SCREEN_ON;
(0060)         delay_ms(500);
(0061)         SCREEN_RESET_START;
(0062)         delay_ms(100);
(0063)         SCREEN_RESET_STOP;
(0064)     }
(0065)     return;
(0066) }
(0067) 
(0068) void screen_off(void)
(0069) {
(0070)     SCREEN_OFF;
(0071)     return;
(0072) }
(0073) 
(0074) void ring_on(void)
(0075) {
(0076)     RING_ON;
(0077)     delay_ms(20);
(0078)     RING_OFF;
(0079)     return;
(0080) }
(0081) 
(0082) void ring_screen_timeout(char timer)
(0083) {
(0084)     if(timer==RINGANDSCREENINPUTTIMER)
(0085)     {
(0086)         screen_off();
(0087)     }
(0088) }
(0089) 
(0090) void door_minitor_timeout(char timer)
(0091) {
(0092)     if(timer==RINGANDSCREENINPUTTIMER)
(0093)     {
(0094)         tips_err();
(0095)         //start timer. 10s.
(0096)         set_timer(RINGANDSCREENINPUTTIMER, 140, door_minitor_timeout); 
(0097)     }
(0098) }
(0099) 
(0100) void input_isr(void)
(0101) {
(0102)     disable_input();
(0103)     //
(0104)     delay_ms(100);
(0105)     if(!(PINC&0x01)) //ring input.
(0106)     {
(0107)         screen_on();
(0108)         ring_on();
(0109)         tips_ring_on();
(0110)         //start timer. 50s.
(0111)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0112)     }
(0113)     else if(!(PIND&0x02)) //screen key input.
(0114)     {
(0115)         screen_on();
(0116)         delay_ms(800);
(0117)         //start timer. 50s.
(0118)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0119)     }
(0120)     enable_input();
(0121)     return;
(0122) }
(0123) **/
(0124) 
(0125) void screen_on(void)
(0126) {
(0127)     //pb2 OUTPUT.
(0128)     DDRB |= 0x04;
_screen_on:
    0480 9ABA      SBI	0x17,2
(0129)     
(0130)     SCREEN_ON;
    0481 B388      IN	R24,0x18
    0482 7F8B      ANDI	R24,0xFB
    0483 BB88      OUT	0x18,R24
(0131) 	delay_ms(25);
    0484 E109      LDI	R16,0x19
    0485 E010      LDI	R17,0
    0486 DCF0      RCALL	_delay_ms
(0132) 	SCREEN_OFF;
    0487 9AC2      SBI	0x18,2
(0133) 
(0134)     //pb2 hi-z
(0135)     DDRB &= 0xfb;
    0488 B387      IN	R24,0x17
    0489 7F8B      ANDI	R24,0xFB
    048A BB87      OUT	0x17,R24
(0136)     PORTB &= 0xfb;
    048B B388      IN	R24,0x18
    048C 7F8B      ANDI	R24,0xFB
    048D BB88      OUT	0x18,R24
(0137)     return;
    048E 9508      RET
(0138) }
(0139) 
(0140) //when door open, return 1.
(0141) char check_door(void)
(0142) {
(0143)     return 0;//(PINA&0x01);
_check_door:
    048F 2700      CLR	R16
    0490 9508      RET
_rw24c256:
  rwFlag               --> Y+11
  addr                 --> Y+9
  len                  --> R22
  data                 --> R20
    0491 D1E4      RCALL	push_gset2
    0492 2F62      MOV	R22,R18
    0493 01A8      MOVW	R20,R16
    0494 9725      SBIW	R28,5
FILE: D:\smarthome\smarthome\门禁系统资料\code\eeprom.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "iic.h"
(0006) #include "eeprom.h"
(0007) 
(0008) /* 一个通用的24C01－24C256共9种EEPROM的字节读写操作程序，   
(0009) 此程序有五个入口条件，分别为读写数据缓冲区指针,   
(0010) 进行读写的字节数，EEPROM首址，EEPROM控制字节，   
(0011) 以及EEPROM类型。此程序结构性良好，具有极好的容错性，程序机器码也不多:   
(0012) DataBuff为读写数据输入／输出缓冲区的首址   
(0013) Length 为要读写数据的字节数量   
(0014) Addr 为EEPROM的片内地址 AT24256为0～32767   
(0015) Control 为EEPROM的控制字节，具体形式为(1)(0)(1)(0)(A2)(A1)(A0)(R/W),其中R/W=1,   
(0016) 表示读操作,R/W=0为写操作,A2,A1,A0为EEPROM的页选或片选地址;   
(0017) enumer为枚举变量,需为AT2401至AT24256中的一种,分别对应AT24C01至AT24C256;   
(0018) 函数返回值为一个位变量，若返回1表示此次操作失效，0表示操作成功;   
(0019) ERROR为允许最大次数，若出现ERRORCOUNT次操作失效后，则函数中止操作，并返回1   
(0020) SDA和SCL由用户自定义，这里暂定义为P3^0和P3^1; */   
(0021) /*对于1K位，2K位，4K位，8K位，16K位芯片采用一个8位长的字节地址码，对于32K位以上   
(0022) 的采用2个8位长的字节地址码直接寻址，而4K位，8K位，16K位配合页面地址来寻址*/   
(0023)    
(0024) /* －－－－－  AT24C01～AT24C256 的读写程序 －－－－－－ */
(0025) 
(0026) #define AT24C256DEVADDR 0xa0
(0027) 
(0028) char rw24c256(unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)
(0029) {
(0030)     return rwiic(AT24C256DEVADDR, data, len, addr, rwFlag);
    0495 840B      LDD	R0,Y+11
    0496 820C      STD	Y+4,R0
    0497 8409      LDD	R0,Y+9
    0498 841A      LDD	R1,Y+10
    0499 821B      STD	Y+3,R1
    049A 820A      STD	Y+2,R0
    049B 8368      STD	Y+0,R22
    049C 019A      MOVW	R18,R20
    049D EA00      LDI	R16,0xA0
    049E D0AA      RCALL	_rwiic
    049F 9625      ADIW	R28,5
    04A0 D1C9      RCALL	pop_gset2
    04A1 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\uart.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "uart.h"
(0005) 
(0006) //uart0 init. for printf.
(0007) void uart0_init(void)
(0008) {
(0009)     UCSRB = 0x00;                //禁止UART发送和接收
_uart0_init:
    04A2 2422      CLR	R2
    04A3 B82A      OUT	0x0A,R2
(0010)     UCSRA = 0x02;               //倍速
    04A4 E082      LDI	R24,2
    04A5 B98B      OUT	0x0B,R24
(0011)     UCSRC = 0x06;                //8位数据
    04A6 E086      LDI	R24,6
    04A7 BD80      OUT	0x20,R24
(0012)     UBRRL = 0x67;                 //9600bps
    04A8 E687      LDI	R24,0x67
    04A9 B989      OUT	0x09,R24
(0013)     UBRRH = 0x00;
    04AA BC20      OUT	0x20,R2
(0014)     UCSRB = 0x18;
    04AB E188      LDI	R24,0x18
    04AC B98A      OUT	0x0A,R24
    04AD 9508      RET
FILE: D:\smarthome\smarthome\门禁系统资料\code\iic.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "iic.h"
(0006) 
(0007) #define SET_SCL (PORTC|=0x80)
(0008) #define CLR_SCL (PORTC&=0x7f)
(0009) #define SET_SDA (PORTC|=0x40)
(0010) #define CLR_SDA (PORTC&=0xbf)
(0011) #define TEST_SDA ((PINC&0x40)?1:0)
(0012) #define SDA_OUT (DDRC|=0x40)
(0013) #define SDA_IN (DDRC&=0xbf,PORTC|=0x40)
(0014) 
(0015) //pc7 scl
(0016) //pc6 sda
(0017) void iicport_init(void)
(0018) {
(0019)     //hi-z
(0020)     DDRC &= 0x3f;
_iicport_init:
    04AE B384      IN	R24,0x14
    04AF 738F      ANDI	R24,0x3F
    04B0 BB84      OUT	0x14,R24
(0021)     PORTC &= 0x3f;
    04B1 B385      IN	R24,0x15
    04B2 738F      ANDI	R24,0x3F
    04B3 BB85      OUT	0x15,R24
(0022)     return;
    04B4 9508      RET
(0023) }
(0024) 
(0025) /* * * * * 以下是对IIC总线的操作子程序 * * * * */   
(0026) /* * * * * * 启动总线 * * * * */   
(0027) void start(void)    
(0028) {
(0029)     //pc6 and pc7 output mode.
(0030)     DDRC |= 0xc0;
_start:
    04B5 B384      IN	R24,0x14
    04B6 6C80      ORI	R24,0xC0
    04B7 BB84      OUT	0x14,R24
(0031)     PORTC |= 0xc0;
    04B8 B385      IN	R24,0x15
    04B9 6C80      ORI	R24,0xC0
    04BA BB85      OUT	0x15,R24
(0032)     NOP();
    04BB 0000      NOP
(0033)     //SCL=0; /* SCL处于高电平时,SDA从高电平转向低电平表示 */   
(0034)     //CLR_SCL;
(0035)     //SDA=1; /* 一个"开始"状态,该状态必须在其他命令之前执行 */   
(0036)     SET_SDA;
    04BC 9AAE      SBI	0x15,6
(0037)     NOP();
    04BD 0000      NOP
    04BE 940E07F4  CALL	0x7F4
(0038)     //SCL=1;
(0039)     SET_SCL;
(0040)     NOP(); NOP(); NOP();    
(0041)     //SDA=0;
(0042)     CLR_SDA;
    04C0 B385      IN	R24,0x15
    04C1 7B8F      ANDI	R24,0xBF
    04C2 BB85      OUT	0x15,R24
    04C3 940E07DC  CALL	0x7DC
(0043)     NOP(); NOP(); NOP(); NOP();    
(0044)     //SCL=0;
(0045)     CLR_SCL;
(0046)     //SDA=1;
(0047)     //SET_SDA;
(0048) 
(0049)     return;
    04C5 9508      RET
(0050) }    
(0051)    
(0052) /* * * * * 停止IIC总线 * * * * */   
(0053) void stop(void)    
(0054) {     
(0055)     //SCL=0; /*SCL处于高电平时,SDA从低电平转向高电平 */
(0056)     //CLR_SCL;   
(0057)     //SDA=0; /*表示一个"停止"状态,该状态终止所有通讯 */
(0058)     CLR_SDA;
_stop:
    04C6 B385      IN	R24,0x15
    04C7 7B8F      ANDI	R24,0xBF
    04C8 BB85      OUT	0x15,R24
(0059)     NOP();
    04C9 0000      NOP
    04CA 940E07F4  CALL	0x7F4
(0060)     //SCL=1;
(0061)     SET_SCL;
(0062)     NOP(); NOP(); NOP(); /* 空操作 */
(0063)     //SDA=1;
(0064)     SET_SDA;
    04CC 9AAE      SBI	0x15,6
(0065)     NOP(); NOP(); NOP();
    04CD 0000      NOP
    04CE 0000      NOP
    04CF 0000      NOP
(0066)     //SCL=0;
(0067)     //CLR_SCL;
(0068) 
(0069)     //hi-z
(0070)     DDRC &= 0x3f;
    04D0 B384      IN	R24,0x14
    04D1 738F      ANDI	R24,0x3F
    04D2 BB84      OUT	0x14,R24
(0071)     PORTC &= 0x3f;
    04D3 B385      IN	R24,0x15
    04D4 738F      ANDI	R24,0x3F
    04D5 BB85      OUT	0x15,R24
(0072)     return;
    04D6 9508      RET
(0073) }    
(0074)    
(0075) /* * * * * 检查应答位 * * * * */   
(0076) unsigned char recAck(void)    
(0077) {
(0078)     unsigned char result;
(0079)      unsigned char i=0;
_recAck:
  result               --> R16
  i                    --> R16
    04D7 2700      CLR	R16
    04D8 940E0869  CALL	0x869
    04DA 940E07F4  CALL	0x7F4
(0080)     
(0081)     //SCL=0;
(0082)     //CLR_SCL;   
(0083)     //SDA=1;
(0084)     SET_SDA;
(0085)     SDA_IN;
(0086)     //SCL=1;
(0087)     SET_SCL;
(0088)     //change sda input mode.
(0089)     NOP(); NOP(); NOP(); NOP();
    04DC 0000      NOP
    04DD C001      RJMP	0x04DF
(0090)     //CY=SDA;     /* 因为返回值总是放在CY中的 */
(0091)     while(TEST_SDA&&(i>250)) i++;
    04DE 9503      INC	R16
    04DF 9B9E      SBIS	0x13,6
    04E0 C003      RJMP	0x04E4
    04E1 E021      LDI	R18,1
    04E2 E030      LDI	R19,0
    04E3 C002      RJMP	0x04E6
    04E4 2722      CLR	R18
    04E5 2733      CLR	R19
    04E6 3020      CPI	R18,0
    04E7 0723      CPC	R18,R19
    04E8 F019      BEQ	0x04EC
    04E9 EF8A      LDI	R24,0xFA
    04EA 1780      CP	R24,R16
    04EB F390      BCS	0x04DE
(0092)     result = TEST_SDA;
    04EC 9B9E      SBIS	0x13,6
    04ED C003      RJMP	0x04F1
    04EE E001      LDI	R16,1
    04EF E010      LDI	R17,0
    04F0 C002      RJMP	0x04F3
    04F1 2700      CLR	R16
    04F2 2711      CLR	R17
(0093)     //SCL=0;
(0094)     CLR_SCL;
    04F3 B385      IN	R24,0x15
    04F4 778F      ANDI	R24,0x7F
    04F5 BB85      OUT	0x15,R24
(0095)     //SDA_OUT;
(0096)     SDA_OUT;
    04F6 9AA6      SBI	0x14,6
(0097)     return result;
    04F7 9508      RET
(0098) }    
(0099)    
(0100) /* * * * *对IIC总线产生应答 * * * * */   
(0101) void ack(void)    
(0102) {     
(0103)     //SDA=0; /* EEPROM通过在收到每个地址或数据之后, */
(0104)     CLR_SDA;
_ack:
    04F8 B385      IN	R24,0x15
    04F9 7B8F      ANDI	R24,0xBF
    04FA BB85      OUT	0x15,R24
(0105)     //SCL=1; /* 置SDA低电平的方式确认表示收到读SDA口状态 */
(0106)     SET_SCL;
    04FB 9AAF      SBI	0x15,7
    04FC 940E07DC  CALL	0x7DC
(0107)     NOP(); NOP(); NOP(); NOP();
(0108)     //SCL=0;
(0109)     CLR_SCL;   
(0110)     NOP();
    04FE 0000      NOP
(0111)     //SDA=1;
(0112)     SET_SDA;
    04FF 9AAE      SBI	0x15,6
(0113) 
(0114)     return;
    0500 9508      RET
(0115) }    
(0116)    
(0117) /* * * * * * * * * 不对IIC总线产生应答 * * * * */   
(0118) void noAck(void)    
(0119) {    
(0120)     //SDA=1;
(0121)     SET_SDA;
_noAck:
    0501 9AAE      SBI	0x15,6
(0122)     //SCL=1;
(0123)     SET_SCL;
    0502 9AAF      SBI	0x15,7
    0503 940E07DC  CALL	0x7DC
(0124)     NOP(); NOP(); NOP(); NOP();    
(0125)     //SCL=0;
(0126)     CLR_SCL;
(0127)     
(0128)     return;
    0505 9508      RET
_sendByte:
  mask                 --> R20
  byte                 --> R16
    0506 D171      RCALL	push_gset1
(0129) }    
(0130)    
(0131) /* * * * * * * * * 向IIC总线写数据 * * * * */   
(0132) void sendByte(unsigned char byte)    
(0133) {
(0134)     unsigned char mask = 0x80;
    0507 E840      LDI	R20,0x80
(0135)     for(;mask>0;)    
    0508 C011      RJMP	0x051A
(0136)     {
(0137)         //SCL=0;
(0138)         CLR_SCL;
    0509 940E085D  CALL	0x85D
(0139)         NOP();NOP();
    050B 0000      NOP
(0140)         if(mask&byte)
    050C 2E24      MOV	R2,R20
    050D 2220      AND	R2,R16
    050E F011      BEQ	0x0511
(0141)         {
(0142)             //SDA=1;
(0143)             SET_SDA;
    050F 9AAE      SBI	0x15,6
(0144)         }
    0510 C003      RJMP	0x0514
(0145)         else
(0146)         {
(0147)             //SDA=0;
(0148)             CLR_SDA;
    0511 B385      IN	R24,0x15
    0512 7B8F      ANDI	R24,0xBF
    0513 BB85      OUT	0x15,R24
(0149)         }
(0150)         mask >>= 1;
    0514 9546      LSR	R20
(0151)         NOP();NOP();
    0515 0000      NOP
    0516 0000      NOP
(0152)         //SCL=1;
(0153)         SET_SCL;
    0517 9AAF      SBI	0x15,7
(0154)         NOP();NOP();
    0518 0000      NOP
    0519 0000      NOP
    051A 2422      CLR	R2
    051B 1624      CP	R2,R20
    051C F360      BCS	0x0509
(0155)     }
(0156)     //SCL=0;
(0157)     CLR_SCL;
    051D B385      IN	R24,0x15
    051E 778F      ANDI	R24,0x7F
    051F BB85      OUT	0x15,R24
(0158) 
(0159)     return;
    0520 D15A      RCALL	pop_gset1
    0521 9508      RET
_receiveByte:
  i                    --> R16
  receivebyte          --> R18
    0522 D155      RCALL	push_gset1
(0160) }
(0161)    
(0162) /* * * * * * * * * 从IIC总线上读数据子程序 * * * * */   
(0163) unsigned char receiveByte(void)    
(0164) {     
(0165)     unsigned char receivebyte = 0, i=8;     
    0523 2722      CLR	R18
    0524 E008      LDI	R16,0x8
(0166)     //SCL=0;
(0167)     CLR_SCL;
    0525 B385      IN	R24,0x15
    0526 778F      ANDI	R24,0x7F
    0527 BB85      OUT	0x15,R24
    0528 940E0869  CALL	0x869
(0168)     //SDA = 1;
(0169)     SET_SDA;
(0170)     SDA_IN;
(0171)     NOP();NOP();
    052A 0000      NOP
    052B 0000      NOP
    052C C013      RJMP	0x0540
(0172)     while(i--)    
(0173)     {     
(0174)         //SCL=1;
(0175)         SET_SCL;
    052D 9AAF      SBI	0x15,7
(0176)         NOP();NOP();
    052E 0000      NOP
    052F 0000      NOP
(0177)         receivebyte = (receivebyte <<1 ) | TEST_SDA;
    0530 9B9E      SBIS	0x13,6
    0531 C003      RJMP	0x0535
    0532 E041      LDI	R20,1
    0533 E050      LDI	R21,0
    0534 C002      RJMP	0x0537
    0535 2744      CLR	R20
    0536 2755      CLR	R21
    0537 2E22      MOV	R2,R18
    0538 2433      CLR	R3
    0539 0C22      LSL	R2
    053A 1C33      ROL	R3
    053B 2A24      OR	R2,R20
    053C 2A35      OR	R3,R21
    053D 2D22      MOV	R18,R2
    053E 940E085D  CALL	0x85D
    0540 2E20      MOV	R2,R16
    0541 2433      CLR	R3
    0542 5001      SUBI	R16,1
    0543 2022      TST	R2
    0544 F741      BNE	0x052D
(0178)         //SCL=0;
(0179)         CLR_SCL;
(0180)         NOP();
(0181)     }
(0182)     SDA_OUT;
    0545 9AA6      SBI	0x14,6
(0183)     return receivebyte;    
    0546 2F02      MOV	R16,R18
    0547 D133      RCALL	pop_gset1
    0548 9508      RET
_rwiic:
  i                    --> R10
  err                  --> R20
  rwFlag               --> R22
  addr                 --> R12
  len                  --> R14
  data                 --> Y+12
  comAddr              --> Y+10
    0549 D0F1      RCALL	push_arg4
    054A D125      RCALL	push_gset5
    054B 84EE      LDD	R14,Y+14
    054C 88C8      LDD	R12,Y+16
    054D 88D9      LDD	R13,Y+17
    054E 896A      LDD	R22,Y+18
(0184) }
(0185) 
(0186) 
(0187) #define MAXRETRY    10
(0188) 
(0189) char rwiic(unsigned char comAddr, unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)    
(0190) {
(0191)     unsigned char i = MAXRETRY;
    054F E08A      LDI	R24,0xA
    0550 2EA8      MOV	R10,R24
(0192)     char err = 1;  /*   出错标志   */   
    0551 E041      LDI	R20,1
    0552 C048      RJMP	0x059B
(0193)     while(i--)    
(0194)     {    
(0195)         start();  /*   启动总线   */
    0553 DF61      RCALL	_start
(0196)         sendByte(comAddr |0x00); /*   向IIC总线写数据，器件地址 */   
    0554 850A      LDD	R16,Y+10
    0555 DFB0      RCALL	_sendByte
(0197)         if(recAck()) continue; /*   如写不正确结束本次循环   */   
    0556 DF80      RCALL	_recAck
    0557 2300      TST	R16
    0558 F009      BEQ	0x055A
    0559 C041      RJMP	0x059B
(0198)         sendByte((unsigned char)(addr >> 8));//把整型数据转换为字符型数据：弃高取低，只取低8位.如果容量大于32K位，使用16位地址寻址，写入高八位地址    
    055A 0186      MOVW	R16,R12
    055B 2F01      MOV	R16,R17
    055C 2711      CLR	R17
    055D DFA8      RCALL	_sendByte
(0199)         if(recAck())  continue;    
    055E DF78      RCALL	_recAck
    055F 2300      TST	R16
    0560 F009      BEQ	0x0562
    0561 C039      RJMP	0x059B
(0200)         sendByte((unsigned char)addr); /*   向IIC总线写数据   */   
    0562 2D0C      MOV	R16,R12
    0563 DFA2      RCALL	_sendByte
(0201)         if(recAck())  continue; /*   如写正确结束本次循环   */
    0564 DF72      RCALL	_recAck
    0565 2300      TST	R16
    0566 F009      BEQ	0x0568
    0567 C033      RJMP	0x059B
(0202)         if(rwFlag == RWWRITE)   //判断是读器件还是写器件    
    0568 2366      TST	R22
    0569 F4A1      BNE	0x057E
(0203)         {
(0204)             err=0;         /* 清错误特征位 */   
    056A 2744      CLR	R20
    056B C00C      RJMP	0x0578
(0205)             while(len--)    
(0206)             {
(0207)                 sendByte(*(data++)); /*   向IIC总线写数据   */   
    056C 85EC      LDD	R30,Y+12
    056D 85FD      LDD	R31,Y+13
    056E 9101      LD	R16,Z+
    056F 87FD      STD	Y+13,R31
    0570 87EC      STD	Y+12,R30
    0571 DF94      RCALL	_sendByte
(0208)                 if(!recAck()) continue; /*   如写正确结束本次循环   */   
    0572 DF64      RCALL	_recAck
    0573 2300      TST	R16
    0574 F409      BNE	0x0576
    0575 C002      RJMP	0x0578
(0209)                 err=1;    
    0576 E041      LDI	R20,1
(0210)                 break;    
    0577 C003      RJMP	0x057B
    0578 940E0862  CALL	0x862
    057A F789      BNE	0x056C
(0211)             }    
(0212)             if(err==1) continue;    
    057B 3041      CPI	R20,1
    057C F531      BNE	0x05A3
    057D C01D      RJMP	0x059B
(0213)             break;    
(0214)         }    
(0215)         else   
(0216)         { 
(0217)             start();  /*   启动总线   */   
    057E DF36      RCALL	_start
(0218)             sendByte(comAddr |0x01); /*   向IIC总线写数据   */   
    057F 850A      LDD	R16,Y+10
    0580 6001      ORI	R16,1
    0581 DF84      RCALL	_sendByte
(0219)             if(recAck()) continue;//器件没应答结束本次本层循环    
    0582 DF54      RCALL	_recAck
    0583 2300      TST	R16
    0584 F009      BEQ	0x0586
    0585 C015      RJMP	0x059B
(0220)             //循环数量要减一。
(0221)             len--;
    0586 94EA      DEC	R14
    0587 C008      RJMP	0x0590
(0222)             while(len--)  /*   字节长为0结束   */   
(0223)             {
(0224)                 *(data++)= receiveByte();    
    0588 DF99      RCALL	_receiveByte
    0589 2E20      MOV	R2,R16
    058A 85EC      LDD	R30,Y+12
    058B 85FD      LDD	R31,Y+13
    058C 9221      ST	R2,Z+
    058D 87FD      STD	Y+13,R31
    058E 87EC      STD	Y+12,R30
(0225)                 ack();   /*   对IIC总线产生应答   */   
    058F DF68      RCALL	_ack
    0590 940E0862  CALL	0x862
    0592 F7A9      BNE	0x0588
(0226)             }    
(0227)             *data=receiveByte(); /* 读最后一个字节 */   
    0593 DF8E      RCALL	_receiveByte
    0594 2E20      MOV	R2,R16
    0595 85EC      LDD	R30,Y+12
    0596 85FD      LDD	R31,Y+13
    0597 8220      STD	Z+0,R2
(0228)             noAck();  /*   不对IIC总线产生应答   */   
    0598 DF68      RCALL	_noAck
(0229)             err=0;    
    0599 2744      CLR	R20
(0230)             break;    
    059A C008      RJMP	0x05A3
    059B 2C2A      MOV	R2,R10
    059C 2433      CLR	R3
    059D 2D82      MOV	R24,R2
    059E 5081      SUBI	R24,1
    059F 2EA8      MOV	R10,R24
    05A0 2022      TST	R2
    05A1 F009      BEQ	0x05A3
    05A2 CFB0      RJMP	0x0553
(0231)         }    
(0232)     }    
(0233)     stop();  /*   停止IIC总线   */   
    05A3 DF22      RCALL	_stop
(0234)     if(rwFlag == RWWRITE)    
    05A4 2366      TST	R22
    05A5 F419      BNE	0x05A9
(0235)     {     
(0236)         delay_ms(50);    
    05A6 E302      LDI	R16,0x32
    05A7 E010      LDI	R17,0
    05A8 DBCE      RCALL	_delay_ms
(0237)     }    
(0238)     return err;    
    05A9 2F04      MOV	R16,R20
    05AA D0C3      RCALL	pop_gset5
    05AB 9624      ADIW	R28,4
    05AC 9508      RET
_rwiicInt:
  tmp                  --> Y+9
  out                  --> Y+5
  rwFlag               --> Y+25
  addr                 --> Y+23
  data                 --> Y+19
  comAddr              --> R10
    05AD 933A      ST	R19,-Y
    05AE 932A      ST	R18,-Y
    05AF D0C4      RCALL	push_gset3
    05B0 2EA0      MOV	R10,R16
    05B1 972D      SBIW	R28,0xD
(0239) }    
(0240) 
(0241) unsigned long rwiicInt(unsigned char comAddr, unsigned long data, unsigned int addr, unsigned char rwFlag)
(0242) {
(0243)     unsigned char tmp[4] = {0, 0, 0, 0};
    05B2 E58C      LDI	R24,0x5C
    05B3 E090      LDI	R25,0
    05B4 01FE      MOVW	R30,R28
    05B5 9639      ADIW	R30,0x9
    05B6 E004      LDI	R16,4
    05B7 E010      LDI	R17,0
    05B8 93FA      ST	R31,-Y
    05B9 93EA      ST	R30,-Y
    05BA 939A      ST	R25,-Y
    05BB 938A      ST	R24,-Y
    05BC D142      RCALL	asgncblk
(0244) 	unsigned long out = 0;
    05BD E040      LDI	R20,0
    05BE 940E075D  CALL	0x75D
    05C0 940E0810  CALL	0x810
(0245) 
(0246)     if(rwFlag==RWWRITE)
    05C2 8C09      LDD	R0,Y+25
    05C3 2000      TST	R0
    05C4 F009      BEQ	0x05C6
    05C5 C03E      RJMP	0x0604
(0247)     {
(0248)         tmp[0] = (unsigned char)(data&0x000000ff);
    05C6 EF4F      LDI	R20,0xFF
    05C7 940E075D  CALL	0x75D
    05C9 940E07EF  CALL	0x7EF
    05CB 940E07CB  CALL	0x7CB
    05CD 8629      STD	Y+9,R2
(0249)         tmp[1] = (unsigned char)((data>>8)&0x000000ff);
    05CE E088      LDI	R24,0x8
    05CF E090      LDI	R25,0
    05D0 940E07C0  CALL	0x7C0
    05D2 938A      ST	R24,-Y
    05D3 0181      MOVW	R16,R2
    05D4 0192      MOVW	R18,R4
    05D5 D11D      RCALL	lsr32
    05D6 0118      MOVW	R2,R16
    05D7 0129      MOVW	R4,R18
    05D8 940E0823  CALL	0x823
    05DA 940E07CB  CALL	0x7CB
    05DC 862A      STD	Y+10,R2
(0250)         tmp[2] = (unsigned char)((data>>16)&0x000000ff);
    05DD EF4F      LDI	R20,0xFF
    05DE 940E075D  CALL	0x75D
    05E0 940E07EF  CALL	0x7EF
    05E2 0112      MOVW	R2,R4
    05E3 2444      CLR	R4
    05E4 2455      CLR	R5
    05E5 940E07CB  CALL	0x7CB
    05E7 862B      STD	Y+11,R2
(0251)         tmp[3] = (unsigned char)((data>>24)&0x000000ff);
    05E8 E188      LDI	R24,0x18
    05E9 E090      LDI	R25,0
    05EA 940E07C0  CALL	0x7C0
    05EC 938A      ST	R24,-Y
    05ED 0181      MOVW	R16,R2
    05EE 0192      MOVW	R18,R4
    05EF D103      RCALL	lsr32
    05F0 0118      MOVW	R2,R16
    05F1 0129      MOVW	R4,R18
    05F2 940E0823  CALL	0x823
    05F4 940E07CB  CALL	0x7CB
    05F6 862C      STD	Y+12,R2
(0252)         rwiic(comAddr, (unsigned char*)&tmp, 4, addr, RWWRITE);
    05F7 2422      CLR	R2
    05F8 822C      STD	Y+4,R2
    05F9 940E07E4  CALL	0x7E4
    05FB DF4D      RCALL	_rwiic
    05FC 940E07C0  CALL	0x7C0
(0253) 		out = data;
    05FE 01FE      MOVW	R30,R28
    05FF 8225      STD	Z+5,R2
    0600 8236      STD	Z+6,R3
    0601 8247      STD	Z+7,R4
    0602 8650      STD	Z+8,R5
(0254)     }
    0603 C02E      RJMP	0x0632
(0255)     else
(0256)     {
(0257)         rwiic(comAddr, (unsigned char*)&tmp, 4, addr, RWREAD);
    0604 E081      LDI	R24,1
    0605 838C      STD	Y+4,R24
    0606 940E07E4  CALL	0x7E4
    0608 DF40      RCALL	_rwiic
(0258) 
(0259)         out= 0;
    0609 E040      LDI	R20,0
    060A 940E075D  CALL	0x75D
    060C 940E0810  CALL	0x810
(0260)         out |= tmp[0];
    060E 8429      LDD	R2,Y+9
    060F 940E0730  CALL	<created procedures>
(0261)         out <<= 8;
    0611 D0D5      RCALL	lsl32
    0612 940E083D  CALL	0x83D
(0262)         out |= tmp[1];
    0614 842A      LDD	R2,Y+10
    0615 940E0730  CALL	<created procedures>
(0263)         out <<= 8;
    0617 D0CF      RCALL	lsl32
    0618 940E083D  CALL	0x83D
(0264)         out |= tmp[2];
    061A 842B      LDD	R2,Y+11
    061B 940E0730  CALL	<created procedures>
(0265)         out <<= 8;
    061D D0C9      RCALL	lsl32
    061E 940E083D  CALL	0x83D
(0266)         out |= tmp[3];
    0620 842C      LDD	R2,Y+12
    0621 2433      CLR	R3
    0622 2444      CLR	R4
    0623 2455      CLR	R5
    0624 01FE      MOVW	R30,R28
    0625 8065      LDD	R6,Z+5
    0626 8076      LDD	R7,Z+6
    0627 8087      LDD	R8,Z+7
    0628 8490      LDD	R9,Z+8
    0629 2862      OR	R6,R2
    062A 2873      OR	R7,R3
    062B 2884      OR	R8,R4
    062C 2895      OR	R9,R5
    062D 01FE      MOVW	R30,R28
    062E 8265      STD	Z+5,R6
    062F 8276      STD	Z+6,R7
    0630 8287      STD	Z+7,R8
    0631 8690      STD	Z+8,R9
(0267)     }
(0268)     return out;
FILE: <library>
    0632 01FE      MOVW	R30,R28
    0633 8105      LDD	R16,Z+5
    0634 8116      LDD	R17,Z+6
    0635 8127      LDD	R18,Z+7
    0636 8530      LDD	R19,Z+8
    0637 962D      ADIW	R28,0xD
    0638 D033      RCALL	pop_gset3
    0639 9622      ADIW	R28,2
    063A 9508      RET
push_arg4:
    063B 940E0886  CALL	0x886
push_arg2:
    063D 9508      RET
empy32u:
empy32s:
    063E D059      RCALL	long_prolog
    063F 927F      PUSH	R7
    0640 D070      RCALL	tstzero1
    0641 F131      BEQ	0x0668
    0642 2477      CLR	R7
    0643 D073      RCALL	tstzero2
    0644 F419      BNE	0x0648
    0645 018C      MOVW	R16,R24
    0646 019D      MOVW	R18,R26
    0647 C020      RJMP	0x0668
    0648 9F08      MUL	R16,R24
    0649 2CB0      MOV	R11,R0
    064A 2CA1      MOV	R10,R1
    064B 9F28      MUL	R18,R24
    064C 2C90      MOV	R9,R0
    064D 2C81      MOV	R8,R1
    064E 9F18      MUL	R17,R24
    064F 0CA0      ADD	R10,R0
    0650 1C91      ADC	R9,R1
    0651 1C87      ADC	R8,R7
    0652 9F09      MUL	R16,R25
    0653 0CA0      ADD	R10,R0
    0654 1C91      ADC	R9,R1
    0655 1C87      ADC	R8,R7
    0656 9F19      MUL	R17,R25
    0657 0C90      ADD	R9,R0
    0658 1C81      ADC	R8,R1
    0659 9F0A      MUL	R16,R26
    065A 0C90      ADD	R9,R0
    065B 1C81      ADC	R8,R1
    065C 9F38      MUL	R19,R24
    065D 0C80      ADD	R8,R0
    065E 9F29      MUL	R18,R25
    065F 0C80      ADD	R8,R0
    0660 9F1A      MUL	R17,R26
    0661 0C80      ADD	R8,R0
    0662 9F0B      MUL	R16,R27
    0663 0C80      ADD	R8,R0
    0664 2D0B      MOV	R16,R11
    0665 2D1A      MOV	R17,R10
    0666 2D29      MOV	R18,R9
    0667 2D38      MOV	R19,R8
    0668 907F      POP	R7
    0669 C03C      RJMP	long_epilog
pop_gset2:
    066A E0E2      LDI	R30,2
    066B C010      RJMP	pop
pop_gset3:
    066C E0E4      LDI	R30,4
    066D C00E      RJMP	pop
pop_gset5:
    066E 27EE      CLR	R30
    066F C00C      RJMP	pop
push_gset5:
    0670 92FA      ST	R15,-Y
    0671 92EA      ST	R14,-Y
push_gset4:
    0672 92DA      ST	R13,-Y
    0673 92CA      ST	R12,-Y
push_gset3:
    0674 92BA      ST	R11,-Y
    0675 92AA      ST	R10,-Y
push_gset2:
    0676 937A      ST	R23,-Y
    0677 936A      ST	R22,-Y
push_gset1:
    0678 935A      ST	R21,-Y
    0679 934A      ST	R20,-Y
    067A 9508      RET
pop_gset1:
    067B E0E1      LDI	R30,1
pop:
    067C 9149      LD	R20,Y+
    067D 9159      LD	R21,Y+
    067E FDE0      SBRC	R30,0
    067F 9508      RET
    0680 9169      LD	R22,Y+
    0681 9179      LD	R23,Y+
    0682 FDE1      SBRC	R30,1
    0683 9508      RET
    0684 90A9      LD	R10,Y+
    0685 90B9      LD	R11,Y+
    0686 FDE2      SBRC	R30,2
    0687 9508      RET
    0688 90C9      LD	R12,Y+
    0689 90D9      LD	R13,Y+
    068A FDE3      SBRC	R30,3
    068B 9508      RET
    068C 90E9      LD	R14,Y+
    068D 90F9      LD	R15,Y+
    068E 9508      RET
xicall:
    068F 920A      ST	R0,-Y
    0690 95C8      LPM
    0691 920A      ST	R0,-Y
    0692 9631      ADIW	R30,1
    0693 95C8      LPM
    0694 2DF0      MOV	R31,R0
    0695 91E9      LD	R30,Y+
    0696 9009      LD	R0,Y+
    0697 9409      IJMP
long_prolog:
    0698 928A      ST	R8,-Y
    0699 929A      ST	R9,-Y
    069A 92AA      ST	R10,-Y
    069B 92BA      ST	R11,-Y
    069C 93EA      ST	R30,-Y
    069D 938A      ST	R24,-Y
    069E 939A      ST	R25,-Y
    069F 93AA      ST	R26,-Y
    06A0 93BA      ST	R27,-Y
    06A1 8589      LDD	R24,Y+9
    06A2 859A      LDD	R25,Y+10
    06A3 85AB      LDD	R26,Y+11
    06A4 85BC      LDD	R27,Y+12
    06A5 9508      RET
long_epilog:
    06A6 91B9      LD	R27,Y+
    06A7 91A9      LD	R26,Y+
    06A8 9199      LD	R25,Y+
    06A9 9189      LD	R24,Y+
    06AA 91E9      LD	R30,Y+
    06AB 90B9      LD	R11,Y+
    06AC 90A9      LD	R10,Y+
    06AD 9099      LD	R9,Y+
    06AE 9089      LD	R8,Y+
    06AF 9624      ADIW	R28,4
    06B0 9508      RET
tstzero1:
    06B1 27EE      CLR	R30
    06B2 2BE0      OR	R30,R16
    06B3 2BE1      OR	R30,R17
    06B4 2BE2      OR	R30,R18
    06B5 2BE3      OR	R30,R19
    06B6 9508      RET
tstzero2:
    06B7 27EE      CLR	R30
    06B8 2BE8      OR	R30,R24
    06B9 2BE9      OR	R30,R25
    06BA 2BEA      OR	R30,R26
    06BB 2BEB      OR	R30,R27
    06BC 9508      RET
push_lset:
    06BD 93FA      ST	R31,-Y
    06BE 93EA      ST	R30,-Y
    06BF 93BA      ST	R27,-Y
    06C0 93AA      ST	R26,-Y
    06C1 939A      ST	R25,-Y
    06C2 938A      ST	R24,-Y
    06C3 940E0886  CALL	0x886
    06C5 929A      ST	R9,-Y
    06C6 928A      ST	R8,-Y
    06C7 927A      ST	R7,-Y
    06C8 926A      ST	R6,-Y
    06C9 940E088B  CALL	0x88B
    06CB 921A      ST	R1,-Y
    06CC 920A      ST	R0,-Y
    06CD B60F      IN	R0,0x3F
    06CE 920A      ST	R0,-Y
    06CF 9508      RET
pop_lset:
    06D0 9009      LD	R0,Y+
    06D1 BE0F      OUT	0x3F,R0
    06D2 9009      LD	R0,Y+
    06D3 9019      LD	R1,Y+
    06D4 9029      LD	R2,Y+
    06D5 9039      LD	R3,Y+
    06D6 9049      LD	R4,Y+
    06D7 9059      LD	R5,Y+
    06D8 9069      LD	R6,Y+
    06D9 9079      LD	R7,Y+
    06DA 9089      LD	R8,Y+
    06DB 9099      LD	R9,Y+
    06DC 9109      LD	R16,Y+
    06DD 9119      LD	R17,Y+
    06DE 9129      LD	R18,Y+
    06DF 9139      LD	R19,Y+
    06E0 9189      LD	R24,Y+
    06E1 9199      LD	R25,Y+
    06E2 91A9      LD	R26,Y+
    06E3 91B9      LD	R27,Y+
    06E4 91E9      LD	R30,Y+
    06E5 91F9      LD	R31,Y+
    06E6 9508      RET
lsl32:
    06E7 920F      PUSH	R0
    06E8 9009      LD	R0,Y+
    06E9 2000      TST	R0
    06EA F031      BEQ	0x06F1
    06EB 0F00      LSL	R16
    06EC 1F11      ROL	R17
    06ED 1F22      ROL	R18
    06EE 1F33      ROL	R19
    06EF 940A      DEC	R0
    06F0 CFF8      RJMP	0x06E9
    06F1 900F      POP	R0
    06F2 9508      RET
lsr32:
    06F3 920F      PUSH	R0
    06F4 9009      LD	R0,Y+
    06F5 2000      TST	R0
    06F6 F031      BEQ	0x06FD
    06F7 9536      LSR	R19
    06F8 9527      ROR	R18
    06F9 9517      ROR	R17
    06FA 9507      ROR	R16
    06FB 940A      DEC	R0
    06FC CFF8      RJMP	0x06F5
    06FD 900F      POP	R0
    06FE 9508      RET
asgncblk:
    06FF 93AA      ST	R26,-Y
    0700 93BA      ST	R27,-Y
    0701 93EA      ST	R30,-Y
    0702 93FA      ST	R31,-Y
    0703 920A      ST	R0,-Y
    0704 81AF      LDD	R26,Y+7
    0705 85B8      LDD	R27,Y+8
    0706 81ED      LDD	R30,Y+5
    0707 81FE      LDD	R31,Y+6
    0708 3000      CPI	R16,0
    0709 0701      CPC	R16,R17
    070A F031      BEQ	0x0711
    070B 95C8      LPM
    070C 920D      ST	R0,X+
    070D 9631      ADIW	R30,1
    070E 5001      SUBI	R16,1
    070F 4010      SBCI	R17,0
    0710 CFF7      RJMP	0x0708
    0711 9009      LD	R0,Y+
    0712 91F9      LD	R31,Y+
    0713 91E9      LD	R30,Y+
    0714 91B9      LD	R27,Y+
    0715 91A9      LD	R26,Y+
    0716 9624      ADIW	R28,4
    0717 9508      RET
asgnblk:
    0718 93AA      ST	R26,-Y
    0719 93BA      ST	R27,-Y
    071A 93EA      ST	R30,-Y
    071B 93FA      ST	R31,-Y
    071C 920A      ST	R0,-Y
    071D 81AF      LDD	R26,Y+7
    071E 85B8      LDD	R27,Y+8
    071F 81ED      LDD	R30,Y+5
    0720 81FE      LDD	R31,Y+6
    0721 3000      CPI	R16,0
    0722 0701      CPC	R16,R17
    0723 F029      BEQ	0x0729
    0724 9001      LD	R0,Z+
    0725 920D      ST	R0,X+
    0726 5001      SUBI	R16,1
    0727 4010      SBCI	R17,0
    0728 CFF8      RJMP	0x0721
    0729 9009      LD	R0,Y+
    072A 91F9      LD	R31,Y+
    072B 91E9      LD	R30,Y+
    072C 91B9      LD	R27,Y+
    072D 91A9      LD	R26,Y+
    072E 9624      ADIW	R28,4
    072F 9508      RET
<created procedures>:
    0730 2433      CLR	R3
    0731 2444      CLR	R4
    0732 2455      CLR	R5
    0733 01FE      MOVW	R30,R28
    0734 8065      LDD	R6,Z+5
    0735 8076      LDD	R7,Z+6
    0736 8087      LDD	R8,Z+7
    0737 8490      LDD	R9,Z+8
    0738 2862      OR	R6,R2
    0739 2873      OR	R7,R3
    073A 2884      OR	R8,R4
    073B 2895      OR	R9,R5
    073C 01FE      MOVW	R30,R28
    073D 8265      STD	Z+5,R6
    073E 8276      STD	Z+6,R7
    073F 8287      STD	Z+7,R8
    0740 8690      STD	Z+8,R9
    0741 E088      LDI	R24,0x8
    0742 E090      LDI	R25,0
    0743 01FE      MOVW	R30,R28
    0744 8025      LDD	R2,Z+5
    0745 8036      LDD	R3,Z+6
    0746 8047      LDD	R4,Z+7
    0747 8450      LDD	R5,Z+8
    0748 938A      ST	R24,-Y
    0749 0181      MOVW	R16,R2
    074A 0192      MOVW	R18,R4
    074B 9508      RET
    074C 8628      STD	Y+8,R2
    074D 8639      STD	Y+9,R3
    074E 864A      STD	Y+10,R4
    074F 865B      STD	Y+11,R5
    0750 9040006C  LDS	R4,passwordH+2
    0752 9050006D  LDS	R5,passwordH+3
    0754 9020006A  LDS	R2,passwordH
    0756 9030006B  LDS	R3,passwordH+1
    0758 822C      STD	Y+4,R2
    0759 823D      STD	Y+5,R3
    075A 824E      STD	Y+6,R4
    075B 825F      STD	Y+7,R5
    075C 9508      RET
    075D E050      LDI	R21,0
    075E E060      LDI	R22,0
    075F E070      LDI	R23,0
    0760 01FE      MOVW	R30,R28
    0761 9508      RET
    0762 E040      LDI	R20,0
    0763 E050      LDI	R21,0
    0764 E060      LDI	R22,0
    0765 E070      LDI	R23,0
    0766 8748      STD	Y+8,R20
    0767 8759      STD	Y+9,R21
    0768 876A      STD	Y+10,R22
    0769 877B      STD	Y+11,R23
    076A E040      LDI	R20,0
    076B E050      LDI	R21,0
    076C E060      LDI	R22,0
    076D E070      LDI	R23,0
    076E 834C      STD	Y+4,R20
    076F 835D      STD	Y+5,R21
    0770 836E      STD	Y+6,R22
    0771 837F      STD	Y+7,R23
    0772 01FE      MOVW	R30,R28
    0773 A820      LDD	R2,Z+48
    0774 A831      LDD	R3,Z+49
    0775 A842      LDD	R4,Z+50
    0776 A853      LDD	R5,Z+51
    0777 8228      STD	Y+0,R2
    0778 8239      STD	Y+1,R3
    0779 824A      STD	Y+2,R4
    077A 825B      STD	Y+3,R5
    077B 9508      RET
    077C 9040006C  LDS	R4,passwordH+2
    077E 9050006D  LDS	R5,passwordH+3
    0780 9020006A  LDS	R2,passwordH
    0782 9030006B  LDS	R3,passwordH+1
    0784 9508      RET
    0785 92300061  STS	id_code+1,R3
    0787 92200060  STS	id_code,R2
    0789 92500063  STS	id_code+3,R5
    078B 92400062  STS	id_code+2,R4
    078D 9508      RET
    078E E040      LDI	R20,0
    078F E050      LDI	R21,0
    0790 E060      LDI	R22,0
    0791 E070      LDI	R23,0
    0792 9508      RET
    0793 90400070  LDS	R4,passwordL+2
    0795 90500071  LDS	R5,passwordL+3
    0797 9020006E  LDS	R2,passwordL
    0799 9030006F  LDS	R3,passwordL+1
    079B 9508      RET
    079C 01F0      MOVW	R30,R0
    079D E783      LDI	R24,0x73
    079E E090      LDI	R25,0
    079F 0FE8      ADD	R30,R24
    07A0 1FF9      ADC	R31,R25
    07A1 9508      RET
    07A2 E041      LDI	R20,1
    07A3 E050      LDI	R21,0
    07A4 E060      LDI	R22,0
    07A5 E070      LDI	R23,0
    07A6 9508      RET
    07A7 90400062  LDS	R4,id_code+2
    07A9 90500063  LDS	R5,id_code+3
    07AB 90200060  LDS	R2,id_code
    07AD 90300061  LDS	R3,id_code+1
    07AF 9508      RET
    07B0 B388      IN	R24,0x18
    07B1 7D8F      ANDI	R24,0xDF
    07B2 BB88      OUT	0x18,R24
    07B3 E604      LDI	R16,0x64
    07B4 E010      LDI	R17,0
    07B5 9508      RET
    07B6 E00D      LDI	R16,0xD
    07B7 E010      LDI	R17,0
    07B8 93FA      ST	R31,-Y
    07B9 93EA      ST	R30,-Y
    07BA 939A      ST	R25,-Y
    07BB 938A      ST	R24,-Y
    07BC 940E0718  CALL	asgnblk
    07BE 019E      MOVW	R18,R28
    07BF 9508      RET
    07C0 01FE      MOVW	R30,R28
    07C1 8823      LDD	R2,Z+19
    07C2 8834      LDD	R3,Z+20
    07C3 8845      LDD	R4,Z+21
    07C4 8856      LDD	R5,Z+22
    07C5 9508      RET
    07C6 A820      LDD	R2,Z+48
    07C7 A831      LDD	R3,Z+49
    07C8 A842      LDD	R4,Z+50
    07C9 A853      LDD	R5,Z+51
    07CA 9508      RET
    07CB 2224      AND	R2,R20
    07CC 2235      AND	R3,R21
    07CD 2246      AND	R4,R22
    07CE 2257      AND	R5,R23
    07CF 9508      RET
    07D0 01FE      MOVW	R30,R28
    07D1 8C22      LDD	R2,Z+26
    07D2 8C33      LDD	R3,Z+27
    07D3 8C44      LDD	R4,Z+28
    07D4 8C55      LDD	R5,Z+29
    07D5 8228      STD	Y+0,R2
    07D6 8239      STD	Y+1,R3
    07D7 824A      STD	Y+2,R4
    07D8 825B      STD	Y+3,R5
    07D9 91200068  LDS	R18,current_index
    07DB 9508      RET
    07DC 0000      NOP
    07DD 0000      NOP
    07DE 0000      NOP
    07DF 0000      NOP
    07E0 B385      IN	R24,0x15
    07E1 778F      ANDI	R24,0x7F
    07E2 BB85      OUT	0x15,R24
    07E3 9508      RET
    07E4 880F      LDD	R0,Y+23
    07E5 8C18      LDD	R1,Y+24
    07E6 821B      STD	Y+3,R1
    07E7 820A      STD	Y+2,R0
    07E8 E084      LDI	R24,4
    07E9 8388      STD	Y+0,R24
    07EA 019E      MOVW	R18,R28
    07EB 5F27      SUBI	R18,0xF7
    07EC 4F3F      SBCI	R19,0xFF
    07ED 2D0A      MOV	R16,R10
    07EE 9508      RET
    07EF 8823      LDD	R2,Z+19
    07F0 8834      LDD	R3,Z+20
    07F1 8845      LDD	R4,Z+21
    07F2 8856      LDD	R5,Z+22
    07F3 9508      RET
    07F4 9AAF      SBI	0x15,7
    07F5 0000      NOP
    07F6 0000      NOP
    07F7 0000      NOP
    07F8 9508      RET
    07F9 01F0      MOVW	R30,R0
    07FA E785      LDI	R24,0x75
    07FB E090      LDI	R25,0
    07FC 0FE8      ADD	R30,R24
    07FD 1FF9      ADC	R31,R25
    07FE 9508      RET
    07FF 1462      CP	R6,R2
    0800 0473      CPC	R7,R3
    0801 0484      CPC	R8,R4
    0802 0495      CPC	R9,R5
    0803 9508      RET
    0804 2422      CLR	R2
    0805 822A      STD	Y+2,R2
    0806 E08D      LDI	R24,0xD
    0807 9F86      MUL	R24,R22
    0808 01C0      MOVW	R24,R0
    0809 9508      RET
    080A E081      LDI	R24,1
    080B 838A      STD	Y+2,R24
    080C E08D      LDI	R24,0xD
    080D 9F86      MUL	R24,R22
    080E 01C0      MOVW	R24,R0
    080F 9508      RET
    0810 8345      STD	Z+5,R20
    0811 8356      STD	Z+6,R21
    0812 8367      STD	Z+7,R22
    0813 8770      STD	Z+8,R23
    0814 9508      RET
    0815 8741      STD	Z+9,R20
    0816 8752      STD	Z+10,R21
    0817 8763      STD	Z+11,R22
    0818 8774      STD	Z+12,R23
    0819 01CE      MOVW	R24,R28
    081A 01FE      MOVW	R30,R28
    081B 9508      RET
    081C E070      LDI	R23,0
    081D 01FE      MOVW	R30,R28
    081E 8341      STD	Z+1,R20
    081F 8352      STD	Z+2,R21
    0820 8363      STD	Z+3,R22
    0821 8374      STD	Z+4,R23
    0822 9508      RET
    0823 EF4F      LDI	R20,0xFF
    0824 E050      LDI	R21,0
    0825 E060      LDI	R22,0
    0826 E070      LDI	R23,0
    0827 9508      RET
    0828 9350006F  STS	passwordL+1,R21
    082A 9340006E  STS	passwordL,R20
    082C 93700071  STS	passwordL+3,R23
    082E 93600070  STS	passwordL+2,R22
    0830 9508      RET
    0831 91800069  LDS	R24,input_err_count
    0833 5F8F      SUBI	R24,0xFF
    0834 93800069  STS	input_err_count,R24
    0836 9508      RET
    0837 B388      IN	R24,0x18
    0838 7D8F      ANDI	R24,0xDF
    0839 BB88      OUT	0x18,R24
    083A E900      LDI	R16,0x90
    083B E011      LDI	R17,1
    083C 9508      RET
    083D 01FE      MOVW	R30,R28
    083E 8305      STD	Z+5,R16
    083F 8316      STD	Z+6,R17
    0840 8327      STD	Z+7,R18
    0841 8730      STD	Z+8,R19
    0842 9508      RET
    0843 2433      CLR	R3
    0844 8239      STD	Y+1,R3
    0845 8228      STD	Y+0,R2
    0846 E021      LDI	R18,1
    0847 018E      MOVW	R16,R28
    0848 5F0D      SUBI	R16,0xFD
    0849 4F1F      SBCI	R17,0xFF
    084A 9508      RET
    084B E586      LDI	R24,0x56
    084C E090      LDI	R25,0
    084D 8399      STD	Y+1,R25
    084E 8388      STD	Y+0,R24
    084F E22C      LDI	R18,0x2C
    0850 E031      LDI	R19,1
    0851 E001      LDI	R16,1
    0852 9508      RET
    0853 8399      STD	Y+1,R25
    0854 8388      STD	Y+0,R24
    0855 E024      LDI	R18,4
    0856 018E      MOVW	R16,R28
    0857 9508      RET
    0858 8399      STD	Y+1,R25
    0859 8388      STD	Y+0,R24
    085A E024      LDI	R18,4
    085B 018A      MOVW	R16,R20
    085C 9508      RET
    085D B385      IN	R24,0x15
    085E 778F      ANDI	R24,0x7F
    085F BB85      OUT	0x15,R24
    0860 0000      NOP
    0861 9508      RET
    0862 2C2E      MOV	R2,R14
    0863 2433      CLR	R3
    0864 2D82      MOV	R24,R2
    0865 5081      SUBI	R24,1
    0866 2EE8      MOV	R14,R24
    0867 2022      TST	R2
    0868 9508      RET
    0869 9AAE      SBI	0x15,6
    086A B384      IN	R24,0x14
    086B 7B8F      ANDI	R24,0xBF
    086C BB84      OUT	0x14,R24
    086D 9AAE      SBI	0x15,6
    086E 9508      RET
    086F 91800066  LDS	R24,read_count
    0871 5F8F      SUBI	R24,0xFF
    0872 93800066  STS	read_count,R24
    0874 9508      RET
    0875 2422      CLR	R2
    0876 2433      CLR	R3
    0877 8231      STD	Z+1,R3
    0878 8220      STD	Z+0,R2
    0879 E084      LDI	R24,4
    087A 9508      RET
    087B E090      LDI	R25,0
    087C 93900065  STS	id_reader_flags+1,R25
    087E 93800064  STS	id_reader_flags,R24
    0880 9508      RET
    0881 2D2C      MOV	R18,R12
    0882 018E      MOVW	R16,R28
    0883 5F04      SUBI	R16,0xF4
    0884 4F1F      SBCI	R17,0xFF
    0885 9508      RET
    0886 933A      ST	R19,-Y
    0887 932A      ST	R18,-Y
    0888 931A      ST	R17,-Y
    0889 930A      ST	R16,-Y
    088A 9508      RET
    088B 925A      ST	R5,-Y
    088C 924A      ST	R4,-Y
    088D 923A      ST	R3,-Y
    088E 922A      ST	R2,-Y
    088F 9508      RET
    0890 1624      CP	R2,R20
    0891 0635      CPC	R3,R21
    0892 0646      CPC	R4,R22
    0893 0657      CPC	R5,R23
    0894 9508      RET
    0895 9601      ADIW	R24,1
    0896 8399      STD	Y+1,R25
    0897 8388      STD	Y+0,R24
    0898 E021      LDI	R18,1
    0899 9508      RET
    089A 8348      STD	Y+0,R20
    089B 8359      STD	Y+1,R21
    089C 836A      STD	Y+2,R22
    089D 837B      STD	Y+3,R23
    089E 9508      RET
