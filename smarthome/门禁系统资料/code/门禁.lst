__text_start:
__start:
    0039 E5CF      LDI	R28,0x5F
    003A E0D4      LDI	R29,4
    003B BFCD      OUT	0x3D,R28
    003C BFDE      OUT	0x3E,R29
    003D 51C0      SUBI	R28,0x10
    003E 40D0      SBCI	R29,0
    003F EA0A      LDI	R16,0xAA
    0040 8308      STD	Y+0,R16
    0041 2400      CLR	R0
    0042 E7E3      LDI	R30,0x73
    0043 E0F0      LDI	R31,0
    0044 E010      LDI	R17,0
    0045 38E3      CPI	R30,0x83
    0046 07F1      CPC	R31,R17
    0047 F011      BEQ	0x004A
    0048 9201      ST	R0,Z+
    0049 CFFB      RJMP	0x0045
    004A 8300      STD	Z+0,R16
    004B E5EE      LDI	R30,0x5E
    004C E0F0      LDI	R31,0
    004D E6A0      LDI	R26,0x60
    004E E0B0      LDI	R27,0
    004F E010      LDI	R17,0
    0050 37E1      CPI	R30,0x71
    0051 07F1      CPC	R31,R17
    0052 F021      BEQ	0x0057
    0053 95C8      LPM
    0054 9631      ADIW	R30,1
    0055 920D      ST	R0,X+
    0056 CFF9      RJMP	0x0050
    0057 D001      RCALL	_main
_exit:
    0058 CFFF      RJMP	_exit
_main:
  ot                   --> Y+13
  t                    --> Y+0
  door_minitor_count   --> R10
    0059 97EF      SBIW	R28,0x3F
    005A 972F      SBIW	R28,0xF
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\main.c
(0001) #include <stdio.h>
(0002) #include <stdlib.h>
(0003) #include <string.h>
(0004) 
(0005) #include<iom16v.h>
(0006) #include <macros.h>
(0007) 
(0008) #include "uart.h"
(0009) #include "wg26.h"
(0010) #include "util.h"
(0011) #include "tips.h"
(0012) #include "timer.h"
(0013) #include "ringandscreen.h"
(0014) #include "eeprom.h"
(0015) #include "password.h"
(0016) 
(0017) int main(void)
(0018) {
(0019)     unsigned int door_minitor_count = 0;
    005B 24AA      CLR	R10
    005C 24BB      CLR	R11
(0020)     passwordItem_t t, ot;
(0021) 	
(0022)     uart0_init();
    005D 940E05F8  CALL	_uart0_init
(0023)     wg26_init_interrupt();
    005F D08A      RCALL	_wg26_init_interrupt
(0024)     tips_port_init();
    0060 D142      RCALL	_tips_port_init
(0025)     timer_init();
    0061 D362      RCALL	_timer_init
(0026)     at24c256_init();
    0062 D418      RCALL	_at24c256_init
(0027) 
(0028)     t.flags = PASSWORDFLAGS_PASSWORD;
    0063 E082      LDI	R24,2
    0064 8388      STD	Y+0,R24
(0029)     t.idCard = 0;
    0065 E040      LDI	R20,0
    0066 940E0726  CALL	0x726
    0068 940E0803  CALL	0x803
(0030)     t.passwordH = 1;
    006A E041      LDI	R20,1
    006B 940E0726  CALL	0x726
    006D 940E0808  CALL	0x808
(0031)     t.passwordL = 1007;
    006F EE4F      LDI	R20,0xEF
    0070 E053      LDI	R21,3
    0071 E060      LDI	R22,0
    0072 E070      LDI	R23,0
    0073 01FE      MOVW	R30,R28
    0074 8741      STD	Z+9,R20
    0075 8752      STD	Z+10,R21
    0076 8763      STD	Z+11,R22
    0077 8774      STD	Z+12,R23
(0032)     insertPasswordItem(0, t);
    0078 01CE      MOVW	R24,R28
    0079 01FE      MOVW	R30,R28
    007A 967A      ADIW	R30,0x1A
    007B 940E077A  CALL	0x77A
    007D 5E26      SUBI	R18,0xE6
    007E 4F3F      SBCI	R19,0xFF
    007F 2700      CLR	R16
    0080 D1B9      RCALL	_insertPasswordItem
(0033) 
(0034)     t.flags = PASSWORDFLAGS_PASSWORD;
    0081 E082      LDI	R24,2
    0082 8388      STD	Y+0,R24
(0035)     t.idCard = 0;
    0083 E040      LDI	R20,0
    0084 940E0726  CALL	0x726
    0086 940E0803  CALL	0x803
(0036)     t.passwordH = 1135642406;
    0088 E246      LDI	R20,0x26
    0089 E857      LDI	R21,0x87
    008A EB60      LDI	R22,0xB0
    008B E473      LDI	R23,0x43
    008C 940E07EF  CALL	0x7EF
(0037)     t.passwordL = 100;
    008E E644      LDI	R20,0x64
    008F 940E0726  CALL	0x726
    0091 940E07AE  CALL	0x7AE
(0038)     insertPasswordItem(1, t);
    0093 96B7      ADIW	R30,0x27
    0094 940E077A  CALL	0x77A
    0096 5D29      SUBI	R18,0xD9
    0097 4F3F      SBCI	R19,0xFF
    0098 E001      LDI	R16,1
    0099 D1A0      RCALL	_insertPasswordItem
(0039) 
(0040)     t.flags = PASSWORDFLAGS_PASSWORD;
    009A E082      LDI	R24,2
    009B 8388      STD	Y+0,R24
(0041)     t.idCard = 0;
    009C E040      LDI	R20,0
    009D 940E0726  CALL	0x726
    009F 940E0803  CALL	0x803
(0042)     t.passwordH = 1314159265;
    00A1 EA41      LDI	R20,0xA1
    00A2 E75A      LDI	R21,0x7A
    00A3 E564      LDI	R22,0x54
    00A4 E47E      LDI	R23,0x4E
    00A5 940E07EF  CALL	0x7EF
(0043)     t.passwordL = 1;
    00A7 E041      LDI	R20,1
    00A8 940E0726  CALL	0x726
    00AA 940E07AE  CALL	0x7AE
(0044)     insertPasswordItem(2, t);
    00AC 96F4      ADIW	R30,0x34
    00AD 940E077A  CALL	0x77A
    00AF 5C2C      SUBI	R18,0xCC
    00B0 4F3F      SBCI	R19,0xFF
    00B1 E002      LDI	R16,2
    00B2 D187      RCALL	_insertPasswordItem
(0045) 
(0046)     t.flags = PASSWORDFLAGS_ID;
    00B3 E081      LDI	R24,1
    00B4 8388      STD	Y+0,R24
(0047)     t.idCard = 1392618;
    00B5 EE4A      LDI	R20,0xEA
    00B6 E35F      LDI	R21,0x3F
    00B7 E165      LDI	R22,0x15
    00B8 E070      LDI	R23,0
    00B9 01FE      MOVW	R30,R28
    00BA 8341      STD	Z+1,R20
    00BB 8352      STD	Z+2,R21
    00BC 8363      STD	Z+3,R22
    00BD 8374      STD	Z+4,R23
(0048)     t.passwordH = 1;
    00BE E041      LDI	R20,1
    00BF 940E0726  CALL	0x726
    00C1 940E0808  CALL	0x808
(0049)     t.passwordL = 1;
    00C3 E041      LDI	R20,1
    00C4 940E0726  CALL	0x726
    00C6 940E07AE  CALL	0x7AE
(0050)     insertPasswordItem(3, t);
    00C8 5BEF      SUBI	R30,0xBF
    00C9 4FFF      SBCI	R31,0xFF
    00CA 940E077A  CALL	0x77A
    00CC 5B2F      SUBI	R18,0xBF
    00CD 4F3F      SBCI	R19,0xFF
    00CE E003      LDI	R16,3
    00CF D16A      RCALL	_insertPasswordItem
(0051) 
(0052) 	writePasswordItemNum(4);
    00D0 E004      LDI	R16,4
    00D1 D18D      RCALL	_writePasswordItemNum
    00D2 C011      RJMP	0x00E4
(0053) 
(0054)     while(1)
(0055)     {
(0056) 		door_minitor_count++;
    00D3 01C5      MOVW	R24,R10
    00D4 9601      ADIW	R24,1
    00D5 015C      MOVW	R10,R24
(0057) 		if(door_minitor_count>20)
    00D6 E184      LDI	R24,0x14
    00D7 E090      LDI	R25,0
    00D8 158A      CP	R24,R10
    00D9 059B      CPC	R25,R11
    00DA F430      BCC	0x00E1
(0058) 		{
(0059) 			//door open.
(0060) 			if(check_door())
    00DB D39C      RCALL	_check_door
    00DC 2300      TST	R16
    00DD F009      BEQ	0x00DF
(0061) 			{
(0062) 				tips_err();
    00DE D0E0      RCALL	_tips_err
(0063) 			}
(0064) 			door_minitor_count = 0;
    00DF 24AA      CLR	R10
    00E0 24BB      CLR	R11
(0065) 		}
(0066) 		delay_ms(500);
    00E1 EF04      LDI	R16,0xF4
    00E2 E011      LDI	R17,1
    00E3 D0B2      RCALL	_delay_ms
    00E4 CFEE      RJMP	0x00D3
(0067)     }
(0068)     return 0;
    00E5 2700      CLR	R16
    00E6 2711      CLR	R17
    00E7 96EF      ADIW	R28,0x3F
    00E8 962F      ADIW	R28,0xF
    00E9 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\wg26.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "password.h"
(0004) #include "timer.h"
(0005) 
(0006) //pc0 input wg26 d0, pc1 input wg26 d1.
(0007) //wg26 d0 is 0, d1 is 1.
(0008) void wg26_init_interrupt(void)
(0009) {
(0010)     //pc0,pc1 input mode.
(0011)     DDRC &= 0xfc;
_wg26_init_interrupt:
    00EA B384      IN	R24,0x14
    00EB 7F8C      ANDI	R24,0xFC
    00EC BB84      OUT	0x14,R24
(0012)     //上拉。
(0013)     PORTC |= 0x03;
    00ED B385      IN	R24,0x15
    00EE 6083      ORI	R24,3
    00EF BB85      OUT	0x15,R24
(0014)     //enable interrupt.
(0015)     //pd2 input mode.
(0016)     DDRD &= 0xfb;
    00F0 B381      IN	R24,0x11
    00F1 7F8B      ANDI	R24,0xFB
    00F2 BB81      OUT	0x11,R24
(0017) 	//
(0018) 	PORTD |= 0x04;
    00F3 9A92      SBI	0x12,2
(0019) 	
(0020)     SREG |= 0x80;
    00F4 9478      BSET	7
(0021)     //int0 enable.
(0022)     GICR |= 0x40;
    00F5 B78B      IN	R24,0x3B
    00F6 6480      ORI	R24,0x40
    00F7 BF8B      OUT	0x3B,R24
(0023)     //int0 fall edge.
(0024)     MCUCR |= 0x02;
    00F8 B785      IN	R24,0x35
    00F9 6082      ORI	R24,2
    00FA BF85      OUT	0x35,R24
(0025)     return;
    00FB 9508      RET
(0026) }
(0027) //diable reader.
(0028) static void disable_reader(void)
(0029) {
(0030)     GICR &= 0xbf;
_disable_reader:
    00FC B78B      IN	R24,0x3B
    00FD 7B8F      ANDI	R24,0xBF
    00FE BF8B      OUT	0x3B,R24
(0031)     return;
    00FF 9508      RET
(0032) }
(0033) //enable reader.
(0034) static void enable_reader(void)
(0035) {
(0036)     GICR |= 0x40;
_enable_reader:
    0100 B78B      IN	R24,0x3B
    0101 6480      ORI	R24,0x40
    0102 BF8B      OUT	0x3B,R24
(0037)     return;
    0103 9508      RET
_id_reader_check:
  id_code              --> Y+0
    0104 D4FF      RCALL	push_arg4
(0038) }
(0039) 
(0040) //id card id.
(0041) static unsigned long id_code = 0;
(0042) //read flags.
(0043) static unsigned int id_reader_flags = 0;
(0044) //read count.
(0045) static char read_count = 0;
(0046) //define reader flags.
(0047) #define IDREADERFLAG_WAITING 0x0000
(0048) #define IDREADERFLAG_READING 0x0001
(0049) #define IDREADERFLAG_READED 0x0002
(0050) //id code check.
(0051) static char id_reader_check(unsigned long id_code)
(0052) {
(0053)     return 0;
    0105 2700      CLR	R16
    0106 9624      ADIW	R28,4
    0107 9508      RET
_read_time_out:
  timer                --> R10
    0108 940E063D  CALL	push_gset3
    010A 2EA0      MOV	R10,R16
    010B 9722      SBIW	R28,2
(0054) }
(0055) 
(0056) //read timeout.
(0057) static void read_time_out(char timer)
(0058) {
(0059)     if(timer == IDREADERTIMEOUTTIMER)
    010C 20AA      TST	R10
    010D F009      BEQ	0x010F
    010E C03E      RJMP	0x014D
(0060)     {
(0061)         //disable reader.
(0062)         disable_reader();
    010F DFEC      RCALL	_disable_reader
(0063)         id_reader_flags = IDREADERFLAG_READED;
    0110 E082      LDI	R24,2
    0111 940E0860  CALL	0x860
(0064)         //read ok.
(0065)         if(read_count==26) //id card.
    0113 91800066  LDS	R24,read_count
    0115 318A      CPI	R24,0x1A
    0116 F511      BNE	0x0139
(0066)         {
(0067)             if(!id_reader_check(id_code))
    0117 91200062  LDS	R18,id_code+2
    0119 91300063  LDS	R19,id_code+3
    011B 91000060  LDS	R16,id_code
    011D 91100061  LDS	R17,id_code+1
    011F DFE4      RCALL	_id_reader_check
    0120 2300      TST	R16
    0121 F009      BEQ	0x0123
    0122 C021      RJMP	0x0144
(0068)             {
(0069)                 id_code &= 0x01fffffe;
    0123 EF4E      LDI	R20,0xFE
    0124 EF5F      LDI	R21,0xFF
    0125 EF6F      LDI	R22,0xFF
    0126 E071      LDI	R23,1
    0127 940E078A  CALL	0x78A
    0129 940E07A9  CALL	0x7A9
    012B 940E0768  CALL	0x768
(0070)                 id_code >>= 1;
    012D 9456      LSR	R5
    012E 9447      ROR	R4
    012F 9437      ROR	R3
    0130 9427      ROR	R2
    0131 940E0768  CALL	0x768
(0071)                 password_handle(IDREADEDIDCARD, id_code);
    0133 8248      STD	Y+0,R4
    0134 8259      STD	Y+1,R5
    0135 0191      MOVW	R18,R2
    0136 2700      CLR	R16
    0137 D157      RCALL	_password_handle
(0072)             }
(0073)         }
    0138 C00B      RJMP	0x0144
(0074)         else if(read_count==4)//keypad input.
    0139 91800066  LDS	R24,read_count
    013B 3084      CPI	R24,4
    013C F439      BNE	0x0144
    013D 940E078A  CALL	0x78A
(0075)         {
(0076)             password_handle(IDREADEDKEYPAD, id_code);
    013F 8248      STD	Y+0,R4
    0140 8259      STD	Y+1,R5
    0141 0191      MOVW	R18,R2
    0142 E001      LDI	R16,1
    0143 D14B      RCALL	_password_handle
(0077)         }
(0078)         //enable reader.
(0079)         enable_reader();
    0144 DFBB      RCALL	_enable_reader
(0080)         id_reader_flags = IDREADERFLAG_WAITING;
    0145 2422      CLR	R2
    0146 2433      CLR	R3
    0147 92300065  STS	id_reader_flags+1,R3
    0149 92200064  STS	id_reader_flags,R2
(0081)         read_count = 0;
    014B 92200066  STS	read_count,R2
(0082)     }
(0083)     return;
    014D 9622      ADIW	R28,2
    014E D4E6      RCALL	pop_gset3
    014F 9508      RET
_set_id_reading_status:
    0150 D4EE      RCALL	push_gset2
    0151 9722      SBIW	R28,2
(0084) }
(0085) //set status.
(0086) static void set_id_reading_status(void)
(0087) {
(0088)     if(id_reader_flags!=IDREADERFLAG_READING)
    0152 91800064  LDS	R24,id_reader_flags
    0154 91900065  LDS	R25,id_reader_flags+1
    0156 3081      CPI	R24,1
    0157 E0E0      LDI	R30,0
    0158 079E      CPC	R25,R30
    0159 F0A9      BEQ	0x016F
(0089)     {
(0090)         id_reader_flags = IDREADERFLAG_READING;
    015A E081      LDI	R24,1
    015B 940E0860  CALL	0x860
    015D 940E074E  CALL	0x74E
(0091)         id_code = 0;
    015F 93500061  STS	id_code+1,R21
    0161 93400060  STS	id_code,R20
    0163 93700063  STS	id_code+3,R23
    0165 93600062  STS	id_code+2,R22
(0092)         //1*100ms.
(0093)         set_timer(IDREADERTIMEOUTTIMER, 1, read_time_out);
    0167 E584      LDI	R24,0x54
    0168 E090      LDI	R25,0
    0169 8399      STD	Y+1,R25
    016A 8388      STD	Y+0,R24
    016B E021      LDI	R18,1
    016C E030      LDI	R19,0
    016D 2700      CLR	R16
    016E D264      RCALL	_set_timer
(0094)     }
(0095)     return;
    016F 9622      ADIW	R28,2
    0170 D4C2      RCALL	pop_gset2
    0171 9508      RET
_int0_isr:
    0172 D513      RCALL	push_lset
    0173 D4CB      RCALL	push_gset2
(0096) }
(0097) //pull id card id and keypad input.
(0098) #pragma interrupt_handler int0_isr:2
(0099) void int0_isr(void)
(0100) {
(0101)     set_id_reading_status();
    0174 DFDB      RCALL	_set_id_reading_status
(0102)     if(!(PINC&0x02))
    0175 9999      SBIC	0x13,1
    0176 C00D      RJMP	0x0184
    0177 940E0753  CALL	0x753
    0179 940E0793  CALL	0x793
(0103)     {
(0104)         id_code <<= 1;
(0105)         id_code |= 1;
    017B 2A24      OR	R2,R20
    017C 2A35      OR	R3,R21
    017D 2A46      OR	R4,R22
    017E 2A57      OR	R5,R23
    017F 940E0768  CALL	0x768
    0181 940E085A  CALL	0x85A
(0106)         ++read_count;
(0107)     }
    0183 C006      RJMP	0x018A
(0108)     else if(!(PINC&0x01))
    0184 9998      SBIC	0x13,0
    0185 C004      RJMP	0x018A
    0186 940E0753  CALL	0x753
    0188 940E085A  CALL	0x85A
(0109)     {
(0110)         id_code <<= 1;
(0111)         ++read_count;
(0112)     }
(0113)     return;
    018A D4A8      RCALL	pop_gset2
    018B D50D      RCALL	pop_lset
    018C 9518      RETI
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\util.c
(0001) #include "util.h"
(0002) 
(0003) #define XTAL    8
(0004) void delay_1ms(void)
(0005) {
(0006)     int i;
(0007)     //XTAL*143-2 = 1142
(0008)     for(i=1;i<1142;i++);
_delay_1ms:
  i                    --> R16
    018D E001      LDI	R16,1
    018E E010      LDI	R17,0
    018F 5F0F      SUBI	R16,0xFF
    0190 4F1F      SBCI	R17,0xFF
    0191 3706      CPI	R16,0x76
    0192 E0E4      LDI	R30,4
    0193 071E      CPC	R17,R30
    0194 F3D4      BLT	0x018F
    0195 9508      RET
_delay_ms:
  i                    --> R20
  ms                   --> R22
    0196 D4A8      RCALL	push_gset2
    0197 01B8      MOVW	R22,R16
(0009) }
(0010) //=========================================
(0011) void delay_ms(int ms)
(0012) {
(0013)     int i=0;
    0198 2744      CLR	R20
    0199 2755      CLR	R21
    019A C003      RJMP	0x019E
(0014)     while(i<ms)
(0015)     {
(0016)         delay_1ms();
    019B DFF1      RCALL	_delay_1ms
(0017)         i++;
    019C 5F4F      SUBI	R20,0xFF
    019D 4F5F      SBCI	R21,0xFF
    019E 1746      CP	R20,R22
    019F 0757      CPC	R21,R23
    01A0 F3D4      BLT	0x019B
    01A1 D491      RCALL	pop_gset2
    01A2 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\tips.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "tips.h"
(0005) #include "util.h"
(0006) 
(0007) #define BEEP_ON (PORTB&=0xdf)
(0008) #define BEEP_OFF (PORTB|=0x20)
(0009) #define LED_ON (PORTB&=0xbf)
(0010) #define LED_OFF (PORTB|=0x40)
(0011) 
(0012) //pb5 beep,pb6 led.
(0013) void tips_port_init(void)
(0014) {
(0015)     //PINB5 & PINB6 OUTPUT AND pull-up resistors.
(0016)     PORTB |= 0x60;
_tips_port_init:
    01A3 B388      IN	R24,0x18
    01A4 6680      ORI	R24,0x60
    01A5 BB88      OUT	0x18,R24
(0017)     DDRB |= 0x60;
    01A6 B387      IN	R24,0x17
    01A7 6680      ORI	R24,0x60
    01A8 BB87      OUT	0x17,R24
(0018)     return;
    01A9 9508      RET
(0019) }
(0020) //led on.
(0021) void tips_led_on(void)
(0022) {
(0023)     LED_ON;
_tips_led_on:
    01AA B388      IN	R24,0x18
    01AB 7B8F      ANDI	R24,0xBF
    01AC BB88      OUT	0x18,R24
(0024)     return;
    01AD 9508      RET
(0025) }
(0026) //led off.
(0027) void tips_led_off(void)
(0028) {
(0029)     LED_OFF;
_tips_led_off:
    01AE 9AC6      SBI	0x18,6
(0030)     return;
    01AF 9508      RET
(0031) }
(0032) //beep on.
(0033) void tips_beep_on(void)
(0034) {
(0035)     BEEP_ON;
_tips_beep_on:
    01B0 B388      IN	R24,0x18
    01B1 7D8F      ANDI	R24,0xDF
    01B2 BB88      OUT	0x18,R24
(0036)     return;
    01B3 9508      RET
(0037) }
(0038) //beep off.
(0039) void tips_beep_off(void)
(0040) {
(0041)     BEEP_OFF;
_tips_beep_off:
    01B4 9AC5      SBI	0x18,5
(0042)     return;
    01B5 9508      RET
(0043) }
(0044) //__------__ 6 pices.pice per 0.4 seconds.
(0045) void tips_ok(void)
(0046) {
(0047)     LED_ON;
_tips_ok:
    01B6 B388      IN	R24,0x18
    01B7 7B8F      ANDI	R24,0xBF
    01B8 BB88      OUT	0x18,R24
    01B9 940E081C  CALL	0x81C
(0048)     BEEP_ON;
(0049)     //2.4 seconds.
(0050)     delay_ms(400);
    01BB DFDA      RCALL	_delay_ms
(0051)     LED_OFF;
    01BC 9AC6      SBI	0x18,6
(0052)     BEEP_OFF;
    01BD 9AC5      SBI	0x18,5
(0053)     return;
    01BE 9508      RET
(0054) }
(0055) //_-_-___-_-_
(0056) void tips_err(void)
(0057) {
(0058)     BEEP_ON;
_tips_err:
    01BF 940E0798  CALL	0x798
(0059)     delay_ms(100);
    01C1 DFD4      RCALL	_delay_ms
(0060)     BEEP_OFF;
    01C2 9AC5      SBI	0x18,5
(0061)     delay_ms(100);
    01C3 E604      LDI	R16,0x64
    01C4 E010      LDI	R17,0
    01C5 DFD0      RCALL	_delay_ms
    01C6 940E0798  CALL	0x798
(0062)     BEEP_ON;
(0063)     delay_ms(100);
    01C8 DFCD      RCALL	_delay_ms
(0064)     BEEP_OFF;
    01C9 9AC5      SBI	0x18,5
(0065)  
(0066)     delay_ms(200);
    01CA EC08      LDI	R16,0xC8
    01CB E010      LDI	R17,0
    01CC DFC9      RCALL	_delay_ms
    01CD 940E0798  CALL	0x798
(0067)  
(0068)     BEEP_ON;
(0069)     delay_ms(100);
    01CF DFC6      RCALL	_delay_ms
(0070)     BEEP_OFF;
    01D0 9AC5      SBI	0x18,5
(0071)     delay_ms(100);
    01D1 E604      LDI	R16,0x64
    01D2 E010      LDI	R17,0
    01D3 DFC2      RCALL	_delay_ms
    01D4 940E0798  CALL	0x798
(0072)     BEEP_ON;
(0073)     delay_ms(100);
    01D6 DFBF      RCALL	_delay_ms
(0074)     BEEP_OFF;
    01D7 9AC5      SBI	0x18,5
(0075)     return;
    01D8 9508      RET
(0076) }
(0077) //_----_-_-_
(0078) void tips_id_ok(void)
(0079) {
(0080)     BEEP_ON;
_tips_id_ok:
    01D9 B388      IN	R24,0x18
    01DA 7D8F      ANDI	R24,0xDF
    01DB BB88      OUT	0x18,R24
(0081)     delay_ms(200);
    01DC EC08      LDI	R16,0xC8
    01DD E010      LDI	R17,0
    01DE DFB7      RCALL	_delay_ms
(0082)     BEEP_OFF;
    01DF 9AC5      SBI	0x18,5
(0083)     delay_ms(200);
    01E0 EC08      LDI	R16,0xC8
    01E1 E010      LDI	R17,0
    01E2 DFB3      RCALL	_delay_ms
    01E3 940E0798  CALL	0x798
(0084) 
(0085)     BEEP_ON;
(0086)     delay_ms(100);
    01E5 DFB0      RCALL	_delay_ms
(0087)     BEEP_OFF;
    01E6 9AC5      SBI	0x18,5
(0088)     delay_ms(100);
    01E7 E604      LDI	R16,0x64
    01E8 E010      LDI	R17,0
    01E9 DFAC      RCALL	_delay_ms
    01EA 940E0798  CALL	0x798
(0089)     BEEP_ON;
(0090)     delay_ms(100);
    01EC DFA9      RCALL	_delay_ms
(0091)     BEEP_OFF;
    01ED 9AC5      SBI	0x18,5
(0092)     return;
    01EE 9508      RET
    01EF 940E081C  CALL	0x81C
(0093) }
(0094) //__------__-----__
(0095) void tips_ring_on(void)
(0096) {
(0097)     BEEP_ON;
(0098)     //2.4 seconds.
(0099)     delay_ms(400);
_tips_ring_on:
    01F1 DFA4      RCALL	_delay_ms
(0100)     BEEP_OFF;
    01F2 9AC5      SBI	0x18,5
(0101)     delay_ms(400);
    01F3 E900      LDI	R16,0x90
    01F4 E011      LDI	R17,1
    01F5 DFA0      RCALL	_delay_ms
    01F6 940E081C  CALL	0x81C
(0102)     BEEP_ON;
(0103)     //2.4 seconds.
(0104)     delay_ms(400);
    01F8 DF9D      RCALL	_delay_ms
(0105)     BEEP_OFF;
    01F9 9AC5      SBI	0x18,5
(0106)     return;
    01FA 9508      RET
_readPasswordItemNum:
  num                  --> Y+3
    01FB 9724      SBIW	R28,4
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\password.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "log.h"
(0005) #include "locker.h"
(0006) #include "tips.h"
(0007) #include "timer.h"
(0008) #include "eeprom.h"
(0009) #include "password.h"
(0010) #include "ringandscreen.h"
(0011) 
(0012) //eeprom 
(0013) //addr: 0 number.
(0014) 
(0015) // 1: flags
(0016) // 2,3,4,5: id Card.
(0017) // 6,7,8,9: password H
(0018) // 10,11,12,13 :password L
(0019) 
(0020) // 14: flags
(0021) // 15,16,17,18: id Card.
(0022) // 19,20,21,22: password H
(0023) // 23,24,25,26 :password L
(0024) 
(0025) unsigned char readPasswordItemNum(void)
(0026) {
(0027)     unsigned char num = 0;
    01FC 2422      CLR	R2
    01FD 822B      STD	Y+3,R2
(0028) 
(0029)     rw24c256(&num, 1, 0, RW24C256READ);
    01FE E081      LDI	R24,1
    01FF 838A      STD	Y+2,R24
    0200 940E0828  CALL	0x828
    0202 D27F      RCALL	_rw24c256
(0030)     return num;
    0203 810B      LDD	R16,Y+3
    0204 9624      ADIW	R28,4
    0205 9508      RET
_readPasswordItem:
  t                    --> Y+16
  item                 --> Y+3
  index                --> R22
    0206 D438      RCALL	push_gset2
    0207 2F62      MOV	R22,R18
    0208 01A8      MOVW	R20,R16
    0209 9761      SBIW	R28,0x11
(0031) }
(0032) 
(0033) passwordItem_t readPasswordItem(unsigned char index)
(0034) {
(0035)     passwordItem_t item;
(0036)     unsigned char t = 0;
    020A 2422      CLR	R2
    020B 8A28      STD	Y+16,R2
    020C 940E07C9  CALL	0x7C9
    020E 940E0870  CALL	0x870
(0037) 
(0038)     rw24c256(&t, 1, index*13+1, RW24C256READ);
    0210 018E      MOVW	R16,R28
    0211 5F00      SUBI	R16,0xF0
    0212 4F1F      SBCI	R17,0xFF
    0213 D26E      RCALL	_rw24c256
(0039)     item.flags = t;
    0214 8828      LDD	R2,Y+16
    0215 822B      STD	Y+3,R2
    0216 940E07C9  CALL	0x7C9
(0040) 
(0041)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RW24C256READ);
    0218 9602      ADIW	R24,2
    0219 940E0844  CALL	0x844
    021B 5F0C      SUBI	R16,0xFC
    021C 4F1F      SBCI	R17,0xFF
    021D D264      RCALL	_rw24c256
    021E 940E07C9  CALL	0x7C9
(0042)     
(0043)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RW24C256READ);
    0220 9606      ADIW	R24,6
    0221 940E0844  CALL	0x844
    0223 5F08      SUBI	R16,0xF8
    0224 4F1F      SBCI	R17,0xFF
    0225 D25C      RCALL	_rw24c256
    0226 940E07C9  CALL	0x7C9
(0044) 	
(0045)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RW24C256READ);
    0228 960A      ADIW	R24,0xA
    0229 940E0844  CALL	0x844
    022B 5F04      SUBI	R16,0xF4
    022C 4F1F      SBCI	R17,0xFF
    022D D254      RCALL	_rw24c256
(0046)     
(0047)     return item;
    022E 01CE      MOVW	R24,R28
    022F 9603      ADIW	R24,3
    0230 E00D      LDI	R16,0xD
    0231 E010      LDI	R17,0
    0232 935A      ST	R21,-Y
    0233 934A      ST	R20,-Y
    0234 939A      ST	R25,-Y
    0235 938A      ST	R24,-Y
    0236 D4AA      RCALL	asgnblk
    0237 9661      ADIW	R28,0x11
    0238 D3FA      RCALL	pop_gset2
    0239 9508      RET
_insertPasswordItem:
  item                 --> R20
  index                --> R22
    023A D404      RCALL	push_gset2
    023B 01A9      MOVW	R20,R18
    023C 2F60      MOV	R22,R16
    023D 9723      SBIW	R28,3
    023E 940E07DF  CALL	0x7DF
    0240 940E0870  CALL	0x870
(0048) }
(0049) 
(0050) void insertPasswordItem(unsigned char index, passwordItem_t item)
(0051) {
(0052)     rw24c256(&(item.flags), 1, index*13+1, RW24C256WRITE);
    0242 018A      MOVW	R16,R20
    0243 D23E      RCALL	_rw24c256
    0244 940E07DF  CALL	0x7DF
(0053) 	
(0054)     rw24c256((unsigned char*)(&item.idCard), 4, index*13+2, RW24C256WRITE);
    0246 9602      ADIW	R24,2
    0247 940E0849  CALL	0x849
    0249 5F0F      SUBI	R16,0xFF
    024A 4F1F      SBCI	R17,0xFF
    024B D236      RCALL	_rw24c256
    024C 940E07DF  CALL	0x7DF
(0055) 	
(0056)     rw24c256((unsigned char*)(&item.passwordH), 4, index*13+6, RW24C256WRITE);
    024E 9606      ADIW	R24,6
    024F 940E0849  CALL	0x849
    0251 5F0B      SUBI	R16,0xFB
    0252 4F1F      SBCI	R17,0xFF
    0253 D22E      RCALL	_rw24c256
    0254 940E07DF  CALL	0x7DF
(0057) 	
(0058)     rw24c256((unsigned char*)(&item.passwordL), 4, index*13+10, RW24C256WRITE);
    0256 960A      ADIW	R24,0xA
    0257 940E0849  CALL	0x849
    0259 5F07      SUBI	R16,0xF7
    025A 4F1F      SBCI	R17,0xFF
    025B D226      RCALL	_rw24c256
(0059) 	
(0060)     return;
    025C 9623      ADIW	R28,3
    025D D3D5      RCALL	pop_gset2
    025E 9508      RET
_writePasswordItemNum:
  num                  --> Y+3
    025F 931A      ST	R17,-Y
    0260 930A      ST	R16,-Y
    0261 9723      SBIW	R28,3
(0061) }
(0062) 
(0063) void writePasswordItemNum(unsigned char num)
(0064) {
(0065)     rw24c256(&num, 1, 0, RW24C256WRITE);
    0262 2422      CLR	R2
    0263 822A      STD	Y+2,R2
    0264 940E0828  CALL	0x828
    0266 D21B      RCALL	_rw24c256
(0066)     return;
    0267 9625      ADIW	R28,5
    0268 9508      RET
_clear_pswd_status:
    0269 D3D5      RCALL	push_gset2
    026A 940E0793  CALL	0x793
(0067) }
(0068) 
(0069) #define PASSWORDREADIDCARDUNKOWN    0
(0070) #define PASSWORDREADIDCARDOK                1
(0071) #define PASSWORDREADIDANDPSWDOK         2
(0072) 
(0073) static unsigned char password_read_flags = 0;
(0074) static unsigned char current_index = 0;
(0075) static unsigned char input_err_count = 0;
(0076) 
(0077) //You input xxx then password is 1xxx.
(0078) static unsigned long passwordH = 1;
(0079) static unsigned long passwordL = 1;
(0080) 
(0081) static void clear_pswd_status(void)
(0082) {
(0083)     //clear last password input.
(0084)     passwordH = 1;
    026C 9350006B  STS	passwordH+1,R21
    026E 9340006A  STS	passwordH,R20
    0270 9370006D  STS	passwordH+3,R23
    0272 9360006C  STS	passwordH+2,R22
    0274 940E0793  CALL	0x793
    0276 940E07FA  CALL	0x7FA
(0085)     passwordL = 1;
(0086)     tips_led_off();
    0278 DF35      RCALL	_tips_led_off
(0087)     password_read_flags = PASSWORDREADIDCARDUNKOWN;
    0279 2422      CLR	R2
    027A 92200067  STS	password_read_flags,R2
(0088)     current_index = 0;
    027C 92200068  STS	current_index,R2
(0089)     stop_timer(PASSWORDTIMEOUTTIMER);
    027E E001      LDI	R16,1
    027F D173      RCALL	_stop_timer
(0090)     return;
    0280 D3B2      RCALL	pop_gset2
    0281 9508      RET
(0091) }
(0092) 
(0093) //cannot input timeout.
(0094) static void cannot_input_time_out(char timer)
(0095) {
(0096)     if(timer==PASSWORDTIMEOUTTIMER)
_cannot_input_time_out:
  timer                --> R16
    0282 3001      CPI	R16,1
    0283 F419      BNE	0x0287
(0097)         input_err_count = 0;
    0284 2422      CLR	R2
    0285 92200069  STS	input_err_count,R2
(0098)     return;
    0287 9508      RET
_input_time_out:
  timer                --> R20
    0288 D3B8      RCALL	push_gset1
    0289 2F40      MOV	R20,R16
(0099) }
(0100) 
(0101) //input timeout.
(0102) static void input_time_out(char timer)
(0103) {
(0104)     if(timer==PASSWORDTIMEOUTTIMER)
    028A 3041      CPI	R20,1
    028B F409      BNE	0x028D
(0105)         clear_pswd_status();
    028C DFDC      RCALL	_clear_pswd_status
(0106)     return;
    028D D3B6      RCALL	pop_gset1
    028E 9508      RET
_password_handle:
  current_item         --> Y+25
  pswd_item_num        --> R10
  i                    --> R12
  item                 --> Y+12
  code                 --> Y+48
  type                 --> R14
    028F 933A      ST	R19,-Y
    0290 932A      ST	R18,-Y
    0291 D3A7      RCALL	push_gset5
    0292 2EE0      MOV	R14,R16
    0293 97A6      SBIW	R28,0x26
(0107) }
(0108) 
(0109) void password_handle(char type, unsigned long code)
(0110) {
(0111)     unsigned char pswd_item_num = 0;
    0294 24AA      CLR	R10
(0112)     unsigned char i;
(0113)     passwordItem_t item;
(0114) 
(0115) 	//on screen
(0116) 	screen_on();
    0295 D1DB      RCALL	_screen_on
(0117)     //if input error count is too large.
(0118)     if(input_err_count>5)
    0296 E085      LDI	R24,5
    0297 90200069  LDS	R2,input_err_count
    0299 1582      CP	R24,R2
    029A F458      BCC	0x02A6
(0119)     {
(0120)         clear_pswd_status();
    029B DFCD      RCALL	_clear_pswd_status
(0121)         tips_err();
    029C DF22      RCALL	_tips_err
(0122)         //set time out. 100ms*10*60
(0123)         set_timer(PASSWORDTIMEOUTTIMER, 600, cannot_input_time_out);
    029D E588      LDI	R24,0x58
    029E E090      LDI	R25,0
    029F 8399      STD	Y+1,R25
    02A0 8388      STD	Y+0,R24
    02A1 E528      LDI	R18,0x58
    02A2 E032      LDI	R19,2
    02A3 E001      LDI	R16,1
    02A4 D12E      RCALL	_set_timer
(0124)         return;
    02A5 C11A      RJMP	0x03C0
(0125)     }
(0126)  
(0127)     //read a card.
(0128)     if(type==IDREADEDIDCARD)
    02A6 20EE      TST	R14
    02A7 F009      BEQ	0x02A9
    02A8 C040      RJMP	0x02E9
(0129)     {
(0130)         clear_pswd_status();
    02A9 DFBF      RCALL	_clear_pswd_status
(0131)         //read paswd item num.
(0132)         pswd_item_num = readPasswordItemNum();
    02AA DF50      RCALL	_readPasswordItemNum
    02AB 2EA0      MOV	R10,R16
(0133)         //loop find it.
(0134)         for(i=0;i<pswd_item_num;++i)
    02AC 24CC      CLR	R12
    02AD C02E      RJMP	0x02DC
(0135)         {
(0136)             //read a item.
(0137)             item = readPasswordItem(i);
    02AE 940E0866  CALL	0x866
    02B0 DF55      RCALL	_readPasswordItem
(0138)             //if item need id card, and is this id card.
(0139)             if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
    02B1 842C      LDD	R2,Y+12
    02B2 FE20      SBRS	R2,0
    02B3 C027      RJMP	0x02DB
    02B4 01FE      MOVW	R30,R28
    02B5 A820      LDD	R2,Z+48
    02B6 A831      LDD	R3,Z+49
    02B7 A842      LDD	R4,Z+50
    02B8 A853      LDD	R5,Z+51
    02B9 01FE      MOVW	R30,R28
    02BA 8465      LDD	R6,Z+13
    02BB 8476      LDD	R7,Z+14
    02BC 8487      LDD	R8,Z+15
    02BD 8890      LDD	R9,Z+16
    02BE 940E07E5  CALL	0x7E5
    02C0 F009      BEQ	0x02C2
    02C1 C019      RJMP	0x02DB
(0140)             {
(0141)                 //need paswd.
(0142)                 if(item.flags&PASSWORDFLAGS_PASSWORD)
    02C2 842C      LDD	R2,Y+12
    02C3 FE21      SBRS	R2,1
    02C4 C00A      RJMP	0x02CF
(0143)                 {
(0144)                     //id card ok, but need password.
(0145)                     //tips_id_ok();
(0146)                     //id card ok, but not input password, led on.
(0147)                     tips_led_on();
    02C5 DEE4      RCALL	_tips_led_on
(0148)                     current_index = i;
    02C6 92C00068  STS	current_index,R12
(0149)                     password_read_flags = PASSWORDREADIDCARDOK;
    02C8 E081      LDI	R24,1
    02C9 93800067  STS	password_read_flags,R24
    02CB 940E0830  CALL	0x830
(0150)                     //set time out. 100ms*10*30
(0151)                     set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    02CD D105      RCALL	_set_timer
(0152)                 }
    02CE C0F1      RJMP	0x03C0
(0153)                 else //only id card.
(0154)                 {
(0155)                     //record log
(0156)                     log(LOGTYPEIDOK, i, code, 0, 0);
    02CF 940E072B  CALL	0x72B
    02D1 2D2C      MOV	R18,R12
    02D2 E001      LDI	R16,1
    02D3 D190      RCALL	_log
(0157)                     //clear pswd statuc.
(0158)                     clear_pswd_status();
    02D4 DF94      RCALL	_clear_pswd_status
(0159)                     tips_ok();
    02D5 DEE0      RCALL	_tips_ok
(0160)                     locker_unlock();
    02D6 D18F      RCALL	_locker_unlock
(0161)                     //error count clear.
(0162)                     input_err_count = 0;
    02D7 2422      CLR	R2
    02D8 92200069  STS	input_err_count,R2
(0163)                 } //else
(0164)                 return;
    02DA C0E5      RJMP	0x03C0
    02DB 94C3      INC	R12
    02DC 14CA      CP	R12,R10
    02DD F408      BCC	0x02DF
    02DE CFCF      RJMP	0x02AE
(0165)             }  //if((item.flags&PASSWORDFLAGS_ID)&&(item.idCard==code))
(0166)         }	  //for(i=0;i<pswd_item_num;++i)
(0167)         //unkown id card.
(0168)         log(LOGTYPEIDERR, 0, code, 0, 0);
    02DF 940E072B  CALL	0x72B
    02E1 2722      CLR	R18
    02E2 E002      LDI	R16,2
    02E3 D180      RCALL	_log
(0169)         //clear password.
(0170)         clear_pswd_status();
    02E4 DF84      RCALL	_clear_pswd_status
(0171)         //error password and log.
(0172)         tips_err();
    02E5 DED9      RCALL	_tips_err
    02E6 940E0816  CALL	0x816
(0173)         //error count ++
(0174)         ++input_err_count;
(0175)         return;
    02E8 C0D7      RJMP	0x03C0
(0176)     }	  //if(type==IDREADEDIDCARD)
(0177)     else if(type==IDREADEDKEYPAD) // read a keypad input.
    02E9 2D8E      MOV	R24,R14
    02EA 3081      CPI	R24,1
    02EB F009      BEQ	0x02ED
    02EC C0D3      RJMP	0x03C0
(0178)     {
(0179)         code &= 0x0000000f;
    02ED E04F      LDI	R20,0xF
    02EE 940E0726  CALL	0x726
    02F0 940E07A4  CALL	0x7A4
    02F2 940E07A9  CALL	0x7A9
    02F4 01FE      MOVW	R30,R28
    02F5 AA20      STD	Z+48,R2
    02F6 AA31      STD	Z+49,R3
    02F7 AA42      STD	Z+50,R4
    02F8 AA53      STD	Z+51,R5
(0180)         if(code == 0x0000000a)  //*
    02F9 E04A      LDI	R20,0xA
    02FA 940E0726  CALL	0x726
    02FC 940E07A4  CALL	0x7A4
    02FE 940E087F  CALL	0x87F
    0300 F411      BNE	0x0303
(0181)         {
(0182)             //clear password.
(0183)             clear_pswd_status();
    0301 DF67      RCALL	_clear_pswd_status
(0184)         }
    0302 C0BD      RJMP	0x03C0
(0185)         else if(code == 0x0000000b) //#
    0303 E04B      LDI	R20,0xB
    0304 940E0726  CALL	0x726
    0306 940E07A4  CALL	0x7A4
    0308 940E087F  CALL	0x87F
    030A F009      BEQ	0x030C
    030B C07D      RJMP	0x0389
(0186)         {
(0187)             //need id card password.
(0188)             if(password_read_flags==PASSWORDREADIDCARDOK)
    030C 91800067  LDS	R24,password_read_flags
    030E 3081      CPI	R24,1
    030F F009      BEQ	0x0311
    0310 C035      RJMP	0x0346
(0189)             {
(0190)                 passwordItem_t current_item = readPasswordItem(current_index);
    0311 91200068  LDS	R18,current_index
    0313 018E      MOVW	R16,R28
    0314 5E07      SUBI	R16,0xE7
    0315 4F1F      SBCI	R17,0xFF
    0316 DEEF      RCALL	_readPasswordItem
    0317 940E0745  CALL	0x745
(0191)                 //password is ok.
(0192)                 if((current_item.passwordH==passwordH)&&(current_item.passwordL==passwordL))
    0319 01FE      MOVW	R30,R28
    031A 8C66      LDD	R6,Z+30
    031B 8C77      LDD	R7,Z+31
    031C A080      LDD	R8,Z+32
    031D A091      LDD	R9,Z+33
    031E 940E07E5  CALL	0x7E5
    0320 F009      BEQ	0x0322
    0321 C017      RJMP	0x0339
    0322 940E0771  CALL	0x771
    0324 01FE      MOVW	R30,R28
    0325 A062      LDD	R6,Z+34
    0326 A073      LDD	R7,Z+35
    0327 A084      LDD	R8,Z+36
    0328 A095      LDD	R9,Z+37
    0329 940E07E5  CALL	0x7E5
    032B F469      BNE	0x0339
    032C 940E0715  CALL	0x715
    032E 940E07B5  CALL	0x7B5
(0193)                 {
(0194)                     log(LOGTYPEIDANDPSWDOK, current_index, current_item.idCard, passwordH, passwordL);
    0330 E003      LDI	R16,3
    0331 D132      RCALL	_log
(0195)                     //clear password status.
(0196)                     clear_pswd_status();
    0332 DF36      RCALL	_clear_pswd_status
(0197)                     //unlock and write log.
(0198)                     tips_ok();
    0333 DE82      RCALL	_tips_ok
(0199)                     locker_unlock();
    0334 D131      RCALL	_locker_unlock
(0200)                     //error count clear.
(0201)                     input_err_count = 0;
    0335 2422      CLR	R2
    0336 92200069  STS	input_err_count,R2
(0202)                 }
    0338 C087      RJMP	0x03C0
(0203)                 else //password is error.
(0204)                 {
(0205)                     log(LOGTYPEIDANDPSWDERR, current_index, current_item.idCard, passwordH, passwordL);
    0339 940E0771  CALL	0x771
    033B 940E0715  CALL	0x715
    033D 940E07B5  CALL	0x7B5
    033F E004      LDI	R16,4
    0340 D123      RCALL	_log
(0206)                     //clear password.
(0207)                     clear_pswd_status();
    0341 DF27      RCALL	_clear_pswd_status
(0208)                     //error password and log.
(0209)                     tips_err();
    0342 DE7C      RCALL	_tips_err
    0343 940E0816  CALL	0x816
(0210)                     //error count ++.
(0211)                     ++input_err_count;
(0212)                 }
(0213)             }
    0345 C07A      RJMP	0x03C0
(0214)             else //only password.
(0215)             {
(0216)                 //read paswd item num.
(0217)                 pswd_item_num = readPasswordItemNum();
    0346 DEB4      RCALL	_readPasswordItemNum
    0347 2EA0      MOV	R10,R16
(0218)                 //loop find it.
(0219)                 for(i=0;i<pswd_item_num;++i)
    0348 24CC      CLR	R12
    0349 C02C      RJMP	0x0376
(0220)                 {
(0221)                     //read a item.
(0222)                     item = readPasswordItem(i);
    034A 940E0866  CALL	0x866
    034C DEB9      RCALL	_readPasswordItem
(0223)                     //if item need id card, and is this id card.
(0224)                     if((item.flags==PASSWORDFLAGS_PASSWORD)&&(item.passwordH==passwordH)
    034D 858C      LDD	R24,Y+12
    034E 3082      CPI	R24,2
    034F F009      BEQ	0x0351
    0350 C024      RJMP	0x0375
    0351 940E0745  CALL	0x745
    0353 01FE      MOVW	R30,R28
    0354 8861      LDD	R6,Z+17
    0355 8872      LDD	R7,Z+18
    0356 8883      LDD	R8,Z+19
    0357 8894      LDD	R9,Z+20
    0358 940E07E5  CALL	0x7E5
    035A F4D1      BNE	0x0375
    035B 940E0771  CALL	0x771
    035D 01FE      MOVW	R30,R28
    035E 8865      LDD	R6,Z+21
    035F 8876      LDD	R7,Z+22
    0360 8887      LDD	R8,Z+23
    0361 8C90      LDD	R9,Z+24
    0362 940E07E5  CALL	0x7E5
    0364 F481      BNE	0x0375
    0365 940E0715  CALL	0x715
    0367 940E074E  CALL	0x74E
    0369 940E0875  CALL	0x875
(0225)                         &&(item.passwordL==passwordL))
(0226)                     {
(0227)                         log(LOGTYPEPSWDOK, i, 0, passwordH, passwordL);
    036B 2D2C      MOV	R18,R12
    036C E005      LDI	R16,5
    036D D0F6      RCALL	_log
(0228)                         //clear password.
(0229)                         clear_pswd_status();
    036E DEFA      RCALL	_clear_pswd_status
(0230)                         //password is right. unlock and log.
(0231)                         tips_ok();
    036F DE46      RCALL	_tips_ok
(0232)                         locker_unlock();
    0370 D0F5      RCALL	_locker_unlock
(0233)                         //error count clear.
(0234)                         input_err_count = 0;
    0371 2422      CLR	R2
    0372 92200069  STS	input_err_count,R2
(0235)                         return;
    0374 C04B      RJMP	0x03C0
    0375 94C3      INC	R12
    0376 14CA      CP	R12,R10
    0377 F408      BCC	0x0379
    0378 CFD1      RJMP	0x034A
(0236)                     }
(0237)                 }
(0238)                 //password is error.
(0239)                 log(LOGTYPEPSWDERR, 0, 0, passwordH, passwordL);
    0379 940E0771  CALL	0x771
    037B 940E0715  CALL	0x715
    037D 940E074E  CALL	0x74E
    037F 940E0875  CALL	0x875
    0381 2722      CLR	R18
    0382 E006      LDI	R16,6
    0383 D0E0      RCALL	_log
(0240)                 //clear password.
(0241)                 clear_pswd_status();
    0384 DEE4      RCALL	_clear_pswd_status
(0242)                 //password is error, and log.
(0243)                 tips_err();
    0385 DE39      RCALL	_tips_err
    0386 940E0816  CALL	0x816
(0244)                 //error count++.
(0245)                 ++input_err_count;
(0246)                 return;
    0388 C037      RJMP	0x03C0
(0247)             }
(0248)         }
(0249)         else
(0250)         {
(0251)             tips_led_on();
    0389 DE20      RCALL	_tips_led_on
    038A 940E0830  CALL	0x830
(0252)             //set time out. 100ms*10*30
(0253)             set_timer(PASSWORDTIMEOUTTIMER, 300, input_time_out);
    038C D046      RCALL	_set_timer
    038D 940E0771  CALL	0x771
(0254)             passwordL = passwordL*10 + code;
    038F E04A      LDI	R20,0xA
    0390 E050      LDI	R21,0
    0391 E060      LDI	R22,0
    0392 E070      LDI	R23,0
    0393 940E0884  CALL	0x884
    0395 018A      MOVW	R16,R20
    0396 019B      MOVW	R18,R22
    0397 D26F      RCALL	empy32s
    0398 0118      MOVW	R2,R16
    0399 0129      MOVW	R4,R18
    039A 01FE      MOVW	R30,R28
    039B A860      LDD	R6,Z+48
    039C A871      LDD	R7,Z+49
    039D A882      LDD	R8,Z+50
    039E A893      LDD	R9,Z+51
    039F 0C26      ADD	R2,R6
    03A0 1C37      ADC	R3,R7
    03A1 1C48      ADC	R4,R8
    03A2 1C59      ADC	R5,R9
    03A3 9230006F  STS	passwordL+1,R3
    03A5 9220006E  STS	passwordL,R2
    03A7 92500071  STS	passwordL+3,R5
    03A9 92400070  STS	passwordL+2,R4
(0255)             //passwordH save password hight 9 num.
(0256)             if(passwordL>999999999)
    03AB EF4F      LDI	R20,0xFF
    03AC EC59      LDI	R21,0xC9
    03AD E96A      LDI	R22,0x9A
    03AE E37B      LDI	R23,0x3B
    03AF 1542      CP	R20,R2
    03B0 0553      CPC	R21,R3
    03B1 0564      CPC	R22,R4
    03B2 0575      CPC	R23,R5
    03B3 F460      BCC	0x03C0
(0257)             {
(0258)                 passwordH = passwordL;
    03B4 9230006B  STS	passwordH+1,R3
    03B6 9220006A  STS	passwordH,R2
    03B8 9250006D  STS	passwordH+3,R5
    03BA 9240006C  STS	passwordH+2,R4
    03BC 940E0793  CALL	0x793
    03BE 940E07FA  CALL	0x7FA
(0259)                 passwordL = 1;
(0260)             }
(0261)         }
(0262)     }
(0263)     return;
    03C0 96A6      ADIW	R28,0x26
    03C1 D275      RCALL	pop_gset5
    03C2 9622      ADIW	R28,2
    03C3 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\timer.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "timer.h"
(0005) 
(0006) void timer_init(void)
(0007) {
(0008)     //enable interrupt.
(0009)     SREG |= 0x80;
_timer_init:
    03C4 9478      BSET	7
(0010)     //timer0 normal mode.ck/1024.
(0011)     TCCR0 |= 0x05;
    03C5 B783      IN	R24,0x33
    03C6 6085      ORI	R24,5
    03C7 BF83      OUT	0x33,R24
(0012)     //init TCNT0.
(0013)     TCNT0 = 0;
    03C8 2422      CLR	R2
    03C9 BE22      OUT	0x32,R2
(0014)     //TIMSK
(0015)     //TIMSK |= 0x01;
(0016)     return; 
    03CA 9508      RET
(0017) }
(0018) //cpu timer0 start
(0019) static void t0_start(void)
(0020) {
(0021)     TIMSK |= 0x01;
_t0_start:
    03CB B789      IN	R24,0x39
    03CC 6081      ORI	R24,1
    03CD BF89      OUT	0x39,R24
(0022)     return;
    03CE 9508      RET
(0023) }
(0024) //cpu timer0 stop
(0025) static void t0_stop(void)
(0026) {
(0027)     TIMSK &= 0xfe;
_t0_stop:
    03CF B789      IN	R24,0x39
    03D0 7F8E      ANDI	R24,0xFE
    03D1 BF89      OUT	0x39,R24
(0028)     return;
    03D2 9508      RET
_set_timer:
  cb                   --> Y+4
  value                --> R22
  timer                --> R20
    03D3 D26B      RCALL	push_gset2
    03D4 01B9      MOVW	R22,R18
    03D5 2F40      MOV	R20,R16
(0029) }
(0030) //
(0031) static timer_t g_timer[MAXTIMER];
(0032) //set timer and start timer. set value 0, need wait a cpu timer pice.
(0033) void set_timer(char timer, int value, timerCB cb)
(0034) {
(0035)     //value=0, stoped timer.
(0036)     g_timer[timer].value = value+1;
    03D6 E084      LDI	R24,4
    03D7 9F84      MUL	R24,R20
    03D8 940E0784  CALL	0x784
    03DA 01CB      MOVW	R24,R22
    03DB 9601      ADIW	R24,1
    03DC 8391      STD	Z+1,R25
    03DD 8380      STD	Z+0,R24
(0037)     g_timer[timer].cb = cb;
    03DE E084      LDI	R24,4
    03DF 9F84      MUL	R24,R20
    03E0 940E07D9  CALL	0x7D9
    03E2 800C      LDD	R0,Y+4
    03E3 801D      LDD	R1,Y+5
    03E4 8211      STD	Z+1,R1
    03E5 8200      STD	Z+0,R0
(0038)     if(g_timer[timer].value)
    03E6 E084      LDI	R24,4
    03E7 9F84      MUL	R24,R20
    03E8 940E0784  CALL	0x784
    03EA 8020      LDD	R2,Z+0
    03EB 8031      LDD	R3,Z+1
    03EC 2022      TST	R2
    03ED F411      BNE	0x03F0
    03EE 2033      TST	R3
    03EF F009      BEQ	0x03F1
(0039)         t0_start();
    03F0 DFDA      RCALL	_t0_start
(0040)     return;
    03F1 D241      RCALL	pop_gset2
    03F2 9508      RET
(0041) }
(0042) //stop timer and clean timer.
(0043) void stop_timer(char timer)
(0044) {
(0045)     if(g_timer[timer].value)
_stop_timer:
  timer                --> R16
    03F3 E084      LDI	R24,4
    03F4 9F80      MUL	R24,R16
    03F5 940E0784  CALL	0x784
    03F7 8020      LDD	R2,Z+0
    03F8 8031      LDD	R3,Z+1
    03F9 2022      TST	R2
    03FA F411      BNE	0x03FD
    03FB 2033      TST	R3
    03FC F059      BEQ	0x0408
(0046)     {
(0047)         //stop this timer.
(0048)         g_timer[timer].value = 0;
    03FD E084      LDI	R24,4
    03FE 9F80      MUL	R24,R16
    03FF 940E0784  CALL	0x784
    0401 940E0854  CALL	0x854
(0049)         g_timer[timer].cb = 0;
    0403 9F80      MUL	R24,R16
    0404 940E07D9  CALL	0x7D9
    0406 8231      STD	Z+1,R3
    0407 8220      STD	Z+0,R2
(0050)     }
(0051)     return;
    0408 9508      RET
_timer0_isr:
  running_timer_count  --> R20
  i                    --> R22
    0409 D27C      RCALL	push_lset
    040A D234      RCALL	push_gset2
(0052) }
(0053) //timer spank.
(0054) #pragma interrupt_handler timer0_isr:10
(0055) void timer0_isr(void)
(0056) {
(0057)     static char time_pices = 0;
(0058)     ++time_pices;
    040B 91800072  LDS	R24,time_pices
    040D 5F8F      SUBI	R24,0xFF
    040E 93800072  STS	time_pices,R24
(0059)     //200ms.
(0060)     if(time_pices == 2)
    0410 3082      CPI	R24,2
    0411 F009      BEQ	0x0413
    0412 C04E      RJMP	0x0461
(0061)     {
(0062)         char running_timer_count = 0;
    0413 2744      CLR	R20
(0063)         char i;
(0064)         for(i=0;i<MAXTIMER;i++)
    0414 2766      CLR	R22
    0415 C042      RJMP	0x0458
(0065)         {
(0066)             if(g_timer[i].value>1)
    0416 E084      LDI	R24,4
    0417 9F86      MUL	R24,R22
    0418 940E0784  CALL	0x784
    041A 8020      LDD	R2,Z+0
    041B 8031      LDD	R3,Z+1
    041C E081      LDI	R24,1
    041D E090      LDI	R25,0
    041E 1582      CP	R24,R2
    041F 0593      CPC	R25,R3
    0420 F478      BCC	0x0430
(0067)             {
(0068)                 --g_timer[i].value;
    0421 E084      LDI	R24,4
    0422 9F86      MUL	R24,R22
    0423 0110      MOVW	R2,R0
    0424 E783      LDI	R24,0x73
    0425 E090      LDI	R25,0
    0426 0E28      ADD	R2,R24
    0427 1E39      ADC	R3,R25
    0428 01F1      MOVW	R30,R2
    0429 8180      LDD	R24,Z+0
    042A 8191      LDD	R25,Z+1
    042B 9701      SBIW	R24,1
    042C 8391      STD	Z+1,R25
    042D 8380      STD	Z+0,R24
(0069)                 ++running_timer_count;
    042E 9543      INC	R20
(0070)             }
    042F C027      RJMP	0x0457
(0071)             //timer call back.
(0072)             else if(g_timer[i].value==1)
    0430 E084      LDI	R24,4
    0431 9F86      MUL	R24,R22
    0432 940E0784  CALL	0x784
    0434 8180      LDD	R24,Z+0
    0435 8191      LDD	R25,Z+1
    0436 3081      CPI	R24,1
    0437 E0E0      LDI	R30,0
    0438 079E      CPC	R25,R30
    0439 F4E9      BNE	0x0457
(0073)             {
(0074)                 g_timer[i].value = 0;
    043A E084      LDI	R24,4
    043B 9F86      MUL	R24,R22
    043C 940E0784  CALL	0x784
    043E 940E0854  CALL	0x854
(0075)                 if(g_timer[i].cb)
    0440 9F86      MUL	R24,R22
    0441 01F0      MOVW	R30,R0
    0442 E785      LDI	R24,0x75
    0443 E090      LDI	R25,0
    0444 0FE8      ADD	R30,R24
    0445 1FF9      ADC	R31,R25
    0446 8020      LDD	R2,Z+0
    0447 8031      LDD	R3,Z+1
    0448 2022      TST	R2
    0449 F411      BNE	0x044C
    044A 2033      TST	R3
    044B F059      BEQ	0x0457
(0076)                 {
(0077)                     //disable cpu timer.
(0078)                     t0_stop();
    044C DF82      RCALL	_t0_stop
(0079)                     (g_timer[i].cb)(i);
    044D 2F06      MOV	R16,R22
    044E E084      LDI	R24,4
    044F 9F86      MUL	R24,R22
    0450 940E07D9  CALL	0x7D9
    0452 81A0      LDD	R26,Z+0
    0453 81B1      LDD	R27,Z+1
    0454 01FD      MOVW	R30,R26
    0455 D202      RCALL	xicall
(0080)                     //enable cpu timer.
(0081)                     t0_start();
    0456 DF74      RCALL	_t0_start
    0457 9563      INC	R22
    0458 3064      CPI	R22,4
    0459 F408      BCC	0x045B
    045A CFBB      RJMP	0x0416
(0082)                 }
(0083)             }
(0084)         }
(0085)         time_pices = 0;
    045B 2422      CLR	R2
    045C 92200072  STS	time_pices,R2
(0086)         //if no timer running, stop cpu timer.
(0087)         if(!running_timer_count) t0_stop();
    045E 2344      TST	R20
    045F F409      BNE	0x0461
    0460 DF6E      RCALL	_t0_stop
(0088)     }
(0089)     return;
    0461 D1D1      RCALL	pop_gset2
    0462 D236      RCALL	pop_lset
    0463 9518      RETI
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\log.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "log.h"
(0004) 
(0005) void log(char type, unsigned char index, unsigned long id_code, unsigned long pswdH, unsigned long pswdL)
(0006) {
_log:
  pswdL                --> Y+12
  pswdH                --> Y+8
  id_code              --> Y+4
  index                --> Y+2
  type                 --> Y+0
    0464 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\locker.c
(0001) #include<iom16v.h>
(0002) 
(0003) #include "locker.h"
(0004) 
(0005) void locker_init(void)
(0006) {
_locker_init:
    0465 9508      RET
(0007) 
(0008) }
(0009) void locker_unlock(void)
(0010) {
_locker_unlock:
    0466 9508      RET
(0011) 
(0012) }
(0013) 
(0014) void locker_lock(void)
(0015) {
_locker_lock:
    0467 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\ringandscreen.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "tips.h"
(0006) #include "timer.h"
(0007) #include "ringandscreen.h"
(0008) 
(0009) //door monitor input is pa0.
(0010) //screen power output pb7.
(0011) 
(0012) #define SCREEN_ON (PORTB|=0x80)
(0013) #define SCREEN_OFF (PORTB&=0x7f)
(0014) 
(0015) void doorandscreen_init(void)
(0016) {
(0017)     //PA0 INPUT.
(0018)     DDRA &= 0xfe;
_doorandscreen_init:
    0468 B38A      IN	R24,0x1A
    0469 7F8E      ANDI	R24,0xFE
    046A BB8A      OUT	0x1A,R24
(0019) 	PORTA |= 0x01;
    046B 9AD8      SBI	0x1B,0
(0020)     //pb7 OUTPUT.
(0021)     DDRB |= 0x80;
    046C 9ABF      SBI	0x17,7
(0022)     //init screen off
(0023)     PORTB &= 0x7f;
    046D B388      IN	R24,0x18
    046E 778F      ANDI	R24,0x7F
    046F BB88      OUT	0x18,R24
(0024)     //init interrput.
(0025)     return;
    0470 9508      RET
(0026) }
(0027) 
(0028) /**
(0029) #define SCREEN_RESET_START (PORTC&=0xef)
(0030) #define SCREEN_RESET_STOP (PORTC|=0x10)
(0031) #define RING_ON (PORTC&=0xdf)
(0032) #define RING_OFF (PORTC&=0x20)
(0033) 
(0034) void ringandscreen_init(void)
(0035) {
(0036)     //PC0,PC1,PC2 INPUT.
(0037)     DDRC &= 0xf8;
(0038)     //PC3,PC4,PC5 OUTPUT.
(0039)     DDRC |= 0x38;
(0040)     //
(0041)     PORTC = 0xff;
(0042)     //init interrput.
(0043)     return;
(0044) }
(0045) 
(0046) static void disable_input(void)
(0047) {
(0048) 
(0049) }
(0050) 
(0051) static void enable_input(void)
(0052) {
(0053) 
(0054) }
(0055) 
(0056) void screen_on(void)
(0057) {
(0058)     if((PORTC&=0x04))
(0059)     {
(0060)         SCREEN_ON;
(0061)         delay_ms(500);
(0062)         SCREEN_RESET_START;
(0063)         delay_ms(100);
(0064)         SCREEN_RESET_STOP;
(0065)     }
(0066)     return;
(0067) }
(0068) 
(0069) void screen_off(void)
(0070) {
(0071)     SCREEN_OFF;
(0072)     return;
(0073) }
(0074) 
(0075) void ring_on(void)
(0076) {
(0077)     RING_ON;
(0078)     delay_ms(20);
(0079)     RING_OFF;
(0080)     return;
(0081) }
(0082) 
(0083) void ring_screen_timeout(char timer)
(0084) {
(0085)     if(timer==RINGANDSCREENINPUTTIMER)
(0086)     {
(0087)         screen_off();
(0088)     }
(0089) }
(0090) 
(0091) void door_minitor_timeout(char timer)
(0092) {
(0093)     if(timer==RINGANDSCREENINPUTTIMER)
(0094)     {
(0095)         tips_err();
(0096)         //start timer. 10s.
(0097)         set_timer(RINGANDSCREENINPUTTIMER, 140, door_minitor_timeout); 
(0098)     }
(0099) }
(0100) 
(0101) void input_isr(void)
(0102) {
(0103)     disable_input();
(0104)     //
(0105)     delay_ms(100);
(0106)     if(!(PINC&0x01)) //ring input.
(0107)     {
(0108)         screen_on();
(0109)         ring_on();
(0110)         tips_ring_on();
(0111)         //start timer. 50s.
(0112)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0113)     }
(0114)     else if(!(PIND&0x02)) //screen key input.
(0115)     {
(0116)         screen_on();
(0117)         delay_ms(800);
(0118)         //start timer. 50s.
(0119)         set_timer(RINGANDSCREENINPUTTIMER, 600, ring_screen_timeout);
(0120)     }
(0121)     enable_input();
(0122)     return;
(0123) }
(0124) **/
(0125) 
(0126) void screen_on(void)
(0127) {
(0128)     SCREEN_ON;
_screen_on:
    0471 9AC7      SBI	0x18,7
    0472 940E07CF  CALL	0x7CF
(0129)     NOP(); NOP(); NOP(); NOP();    
(0130) 	SCREEN_OFF;
    0474 B388      IN	R24,0x18
    0475 778F      ANDI	R24,0x7F
    0476 BB88      OUT	0x18,R24
(0131)     return;
    0477 9508      RET
(0132) }
(0133) 
(0134) //when door open, return 1.
(0135) char check_door(void)
(0136) {
(0137)     return (PINA&0x01);
_check_door:
    0478 B309      IN	R16,0x19
    0479 7001      ANDI	R16,1
    047A 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\eeprom.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "util.h"
(0005) #include "eeprom.h"
(0006) 
(0007) /* 一个通用的24C01－24C256共9种EEPROM的字节读写操作程序，   
(0008) 此程序有五个入口条件，分别为读写数据缓冲区指针,   
(0009) 进行读写的字节数，EEPROM首址，EEPROM控制字节，   
(0010) 以及EEPROM类型。此程序结构性良好，具有极好的容错性，程序机器码也不多:   
(0011) DataBuff为读写数据输入／输出缓冲区的首址   
(0012) Length 为要读写数据的字节数量   
(0013) Addr 为EEPROM的片内地址 AT24256为0～32767   
(0014) Control 为EEPROM的控制字节，具体形式为(1)(0)(1)(0)(A2)(A1)(A0)(R/W),其中R/W=1,   
(0015) 表示读操作,R/W=0为写操作,A2,A1,A0为EEPROM的页选或片选地址;   
(0016) enumer为枚举变量,需为AT2401至AT24256中的一种,分别对应AT24C01至AT24C256;   
(0017) 函数返回值为一个位变量，若返回1表示此次操作失效，0表示操作成功;   
(0018) ERROR为允许最大次数，若出现ERRORCOUNT次操作失效后，则函数中止操作，并返回1   
(0019) SDA和SCL由用户自定义，这里暂定义为P3^0和P3^1; */   
(0020) /*对于1K位，2K位，4K位，8K位，16K位芯片采用一个8位长的字节地址码，对于32K位以上   
(0021) 的采用2个8位长的字节地址码直接寻址，而4K位，8K位，16K位配合页面地址来寻址*/   
(0022)    
(0023) /* －－－－－  AT24C01～AT24C256 的读写程序 －－－－－－ */
(0024) 
(0025) #define AT24C256DEVADDR 0xa0
(0026) 
(0027) #define MAXRETRY    10
(0028) 
(0029) #define SET_SCL (PORTC|=0x80)
(0030) #define CLR_SCL (PORTC&=0x7f)
(0031) #define SET_SDA (PORTC|=0x40)
(0032) #define CLR_SDA (PORTC&=0xbf)
(0033) #define TEST_SDA ((PINC&0x40)?1:0)
(0034) #define SDA_OUT (DDRC|=0x40)
(0035) #define SDA_IN (DDRC&=0xbf,PORTC|=0x40)
(0036) 
(0037) static void start(void);
(0038) static void stop(void);
(0039) static unsigned char recAck(void);
(0040) static void ack(void);
(0041) static void noAck(void);
(0042) static void sendByte(unsigned char byte);
(0043) static unsigned char receiveByte(void);
(0044) 
(0045) //pc7 scl
(0046) //pc6 sda
(0047) void at24c256_init(void)
(0048) {
(0049)     //pc6 and pc7 output mode.
(0050)     DDRC |= 0xc0;
_at24c256_init:
    047B B384      IN	R24,0x14
    047C 6C80      ORI	R24,0xC0
    047D BB84      OUT	0x14,R24
(0051)     PORTC |= 0xc0;
    047E B385      IN	R24,0x15
    047F 6C80      ORI	R24,0xC0
    0480 BB85      OUT	0x15,R24
(0052)     return;
    0481 9508      RET
_rw24c256:
  i                    --> R10
  err                  --> R20
  rwFlag               --> R22
  addr                 --> R12
  len                  --> R14
  data                 --> Y+10
    0482 D181      RCALL	push_arg4
    0483 D1B5      RCALL	push_gset5
    0484 2EE2      MOV	R14,R18
    0485 84CE      LDD	R12,Y+14
    0486 84DF      LDD	R13,Y+15
    0487 8968      LDD	R22,Y+16
(0053) }
(0054) 
(0055) char rw24c256(unsigned char *data,unsigned char len,unsigned int addr, unsigned char rwFlag)    
(0056) {
(0057)     unsigned char i = MAXRETRY;
    0488 E08A      LDI	R24,0xA
    0489 2EA8      MOV	R10,R24
(0058)     char err = 1;  /*   出错标志   */   
    048A E041      LDI	R20,1
    048B C047      RJMP	0x04D3
(0059)     while(i--)    
(0060)     {    
(0061)         start();  /*   启动总线   */
    048C D0E4      RCALL	_start
(0062)         sendByte(AT24C256DEVADDR |0x00); /*   向IIC总线写数据，器件地址 */   
    048D EA00      LDI	R16,0xA0
    048E D126      RCALL	_sendByte
(0063)         if(recAck()) continue; /*   如写不正确结束本次循环   */   
    048F D0F6      RCALL	_recAck
    0490 2300      TST	R16
    0491 F009      BEQ	0x0493
    0492 C040      RJMP	0x04D3
(0064)         sendByte((unsigned char)(addr >> 8));//把整型数据转换为字符型数据：弃高取低，只取低8位.如果容量大于32K位，使用16位地址寻址，写入高八位地址    
    0493 0186      MOVW	R16,R12
    0494 2F01      MOV	R16,R17
    0495 2711      CLR	R17
    0496 D11E      RCALL	_sendByte
(0065)         if(recAck())  continue;    
    0497 D0EE      RCALL	_recAck
    0498 2300      TST	R16
    0499 F009      BEQ	0x049B
    049A C038      RJMP	0x04D3
(0066)         sendByte((unsigned char)addr); /*   向IIC总线写数据   */   
    049B 2D0C      MOV	R16,R12
    049C D118      RCALL	_sendByte
(0067)         if(recAck())  continue; /*   如写正确结束本次循环   */
    049D D0E8      RCALL	_recAck
    049E 2300      TST	R16
    049F F009      BEQ	0x04A1
    04A0 C032      RJMP	0x04D3
(0068)         if(rwFlag == RW24C256WRITE)   //判断是读器件还是写器件    
    04A1 2366      TST	R22
    04A2 F4A1      BNE	0x04B7
(0069)         {
(0070)             err=0;         /* 清错误特征位 */   
    04A3 2744      CLR	R20
    04A4 C00C      RJMP	0x04B1
(0071)             while(len--)    
(0072)             {
(0073)                 sendByte(*(data++)); /*   向IIC总线写数据   */   
    04A5 85EA      LDD	R30,Y+10
    04A6 85FB      LDD	R31,Y+11
    04A7 9101      LD	R16,Z+
    04A8 87FB      STD	Y+11,R31
    04A9 87EA      STD	Y+10,R30
    04AA D10A      RCALL	_sendByte
(0074)                 if(!recAck()) continue; /*   如写正确结束本次循环   */   
    04AB D0DA      RCALL	_recAck
    04AC 2300      TST	R16
    04AD F409      BNE	0x04AF
    04AE C002      RJMP	0x04B1
(0075)                 err=1;    
    04AF E041      LDI	R20,1
(0076)                 break;    
    04B0 C003      RJMP	0x04B4
    04B1 940E083D  CALL	0x83D
    04B3 F789      BNE	0x04A5
(0077)             }    
(0078)             if(err==1) continue;    
    04B4 3041      CPI	R20,1
    04B5 F529      BNE	0x04DB
    04B6 C01C      RJMP	0x04D3
(0079)             break;    
(0080)         }    
(0081)         else   
(0082)         { 
(0083)             start();  /*   启动总线   */   
    04B7 D0B9      RCALL	_start
(0084)             sendByte(AT24C256DEVADDR |0x01); /*   向IIC总线写数据   */   
    04B8 EA01      LDI	R16,0xA1
    04B9 D0FB      RCALL	_sendByte
(0085)             if(recAck()) continue;//器件没应答结束本次本层循环    
    04BA D0CB      RCALL	_recAck
    04BB 2300      TST	R16
    04BC F009      BEQ	0x04BE
    04BD C015      RJMP	0x04D3
(0086)             //循环数量要减一。
(0087)             len--;
    04BE 94EA      DEC	R14
    04BF C008      RJMP	0x04C8
(0088)             while(len--)  /*   字节长为0结束   */   
(0089)             {
(0090)                 *(data++)= receiveByte();    
    04C0 D110      RCALL	_receiveByte
    04C1 2E20      MOV	R2,R16
    04C2 85EA      LDD	R30,Y+10
    04C3 85FB      LDD	R31,Y+11
    04C4 9221      ST	R2,Z+
    04C5 87FB      STD	Y+11,R31
    04C6 87EA      STD	Y+10,R30
(0091)                 ack();   /*   对IIC总线产生应答   */   
    04C7 D0DF      RCALL	_ack
    04C8 940E083D  CALL	0x83D
    04CA F7A9      BNE	0x04C0
(0092)             }    
(0093)             *data=receiveByte(); /* 读最后一个字节 */   
    04CB D105      RCALL	_receiveByte
    04CC 2E20      MOV	R2,R16
    04CD 85EA      LDD	R30,Y+10
    04CE 85FB      LDD	R31,Y+11
    04CF 8220      STD	Z+0,R2
(0094)             noAck();  /*   不对IIC总线产生应答   */   
    04D0 D0DF      RCALL	_noAck
(0095)             err=0;    
    04D1 2744      CLR	R20
(0096)             break;    
    04D2 C008      RJMP	0x04DB
    04D3 2C2A      MOV	R2,R10
    04D4 2433      CLR	R3
    04D5 2D82      MOV	R24,R2
    04D6 5081      SUBI	R24,1
    04D7 2EA8      MOV	R10,R24
    04D8 2022      TST	R2
    04D9 F009      BEQ	0x04DB
    04DA CFB1      RJMP	0x048C
(0097)         }    
(0098)     }    
(0099)     stop();  /*   停止IIC总线   */   
    04DB D09F      RCALL	_stop
(0100)     if(rwFlag == RW24C256WRITE)    
    04DC 2366      TST	R22
    04DD F419      BNE	0x04E1
(0101)     {     
(0102)         delay_ms(50);    
    04DE E302      LDI	R16,0x32
    04DF E010      LDI	R17,0
    04E0 DCB5      RCALL	_delay_ms
(0103)     }    
(0104)     return err;    
    04E1 2F04      MOV	R16,R20
    04E2 D154      RCALL	pop_gset5
    04E3 9624      ADIW	R28,4
    04E4 9508      RET
_rw24c256Int:
  tmp                  --> Y+7
  out                  --> Y+3
  rwFlag               --> Y+21
  addr                 --> Y+19
  data                 --> Y+15
    04E5 D11E      RCALL	push_arg4
    04E6 D158      RCALL	push_gset2
    04E7 972B      SBIW	R28,0xB
(0105) }    
(0106) 
(0107) unsigned long rw24c256Int(unsigned long data, unsigned int addr, unsigned char rwFlag)
(0108) {
(0109)     unsigned char tmp[4] = {0, 0, 0, 0};
    04E8 E58A      LDI	R24,0x5A
    04E9 E090      LDI	R25,0
    04EA 01FE      MOVW	R30,R28
    04EB 9637      ADIW	R30,7
    04EC E004      LDI	R16,4
    04ED E010      LDI	R17,0
    04EE 93FA      ST	R31,-Y
    04EF 93EA      ST	R30,-Y
    04F0 939A      ST	R25,-Y
    04F1 938A      ST	R24,-Y
    04F2 D1D5      RCALL	asgncblk
(0110) 	unsigned long out = 0;
    04F3 E040      LDI	R20,0
    04F4 940E0726  CALL	0x726
    04F6 940E087A  CALL	0x87A
(0111) 
(0112)     if(rwFlag==RW24C256WRITE)
    04F8 880D      LDD	R0,Y+21
    04F9 2000      TST	R0
    04FA F009      BEQ	0x04FC
    04FB C03E      RJMP	0x053A
(0113)     {
(0114)         tmp[0] = (unsigned char)(data&0x000000ff);
    04FC EF4F      LDI	R20,0xFF
    04FD 940E0726  CALL	0x726
    04FF 940E07D4  CALL	0x7D4
    0501 940E07A9  CALL	0x7A9
    0503 822F      STD	Y+7,R2
(0115)         tmp[1] = (unsigned char)((data>>8)&0x000000ff);
    0504 E088      LDI	R24,0x8
    0505 E090      LDI	R25,0
    0506 940E079E  CALL	0x79E
    0508 938A      ST	R24,-Y
    0509 0181      MOVW	R16,R2
    050A 0192      MOVW	R18,R4
    050B D1B0      RCALL	lsr32
    050C 0118      MOVW	R2,R16
    050D 0129      MOVW	R4,R18
    050E 940E07F5  CALL	0x7F5
    0510 940E07A9  CALL	0x7A9
    0512 8628      STD	Y+8,R2
(0116)         tmp[2] = (unsigned char)((data>>16)&0x000000ff);
    0513 EF4F      LDI	R20,0xFF
    0514 940E0726  CALL	0x726
    0516 940E07D4  CALL	0x7D4
    0518 0112      MOVW	R2,R4
    0519 2444      CLR	R4
    051A 2455      CLR	R5
    051B 940E07A9  CALL	0x7A9
    051D 8629      STD	Y+9,R2
(0117)         tmp[3] = (unsigned char)((data>>24)&0x000000ff);
    051E E188      LDI	R24,0x18
    051F E090      LDI	R25,0
    0520 940E079E  CALL	0x79E
    0522 938A      ST	R24,-Y
    0523 0181      MOVW	R16,R2
    0524 0192      MOVW	R18,R4
    0525 D196      RCALL	lsr32
    0526 0118      MOVW	R2,R16
    0527 0129      MOVW	R4,R18
    0528 940E07F5  CALL	0x7F5
    052A 940E07A9  CALL	0x7A9
    052C 862A      STD	Y+10,R2
(0118)         rw24c256((unsigned char*)&tmp, 4, addr, RW24C256WRITE);
    052D 2422      CLR	R2
    052E 822A      STD	Y+2,R2
    052F 940E080D  CALL	0x80D
    0531 DF50      RCALL	_rw24c256
    0532 940E079E  CALL	0x79E
(0119) 		out = data;
    0534 01FE      MOVW	R30,R28
    0535 8223      STD	Z+3,R2
    0536 8234      STD	Z+4,R3
    0537 8245      STD	Z+5,R4
    0538 8256      STD	Z+6,R5
(0120)     }
    0539 C02E      RJMP	0x0568
(0121)     else
(0122)     {
(0123)         rw24c256((unsigned char*)&tmp, 4, addr, RW24C256READ);
    053A E081      LDI	R24,1
    053B 838A      STD	Y+2,R24
    053C 940E080D  CALL	0x80D
    053E DF43      RCALL	_rw24c256
(0124) 
(0125)         out= 0;
    053F E040      LDI	R20,0
    0540 940E0726  CALL	0x726
    0542 940E087A  CALL	0x87A
(0126)         out |= tmp[0];
    0544 802F      LDD	R2,Y+7
    0545 940E06F9  CALL	<created procedures>
(0127)         out <<= 8;
    0547 D168      RCALL	lsl32
    0548 940E0822  CALL	0x822
(0128)         out |= tmp[1];
    054A 8428      LDD	R2,Y+8
    054B 940E06F9  CALL	<created procedures>
(0129)         out <<= 8;
    054D D162      RCALL	lsl32
    054E 940E0822  CALL	0x822
(0130)         out |= tmp[2];
    0550 8429      LDD	R2,Y+9
    0551 940E06F9  CALL	<created procedures>
(0131)         out <<= 8;
    0553 D15C      RCALL	lsl32
    0554 940E0822  CALL	0x822
(0132)         out |= tmp[3];
    0556 842A      LDD	R2,Y+10
    0557 2433      CLR	R3
    0558 2444      CLR	R4
    0559 2455      CLR	R5
    055A 01FE      MOVW	R30,R28
    055B 8063      LDD	R6,Z+3
    055C 8074      LDD	R7,Z+4
    055D 8085      LDD	R8,Z+5
    055E 8096      LDD	R9,Z+6
    055F 2862      OR	R6,R2
    0560 2873      OR	R7,R3
    0561 2884      OR	R8,R4
    0562 2895      OR	R9,R5
    0563 01FE      MOVW	R30,R28
    0564 8263      STD	Z+3,R6
    0565 8274      STD	Z+4,R7
    0566 8285      STD	Z+5,R8
    0567 8296      STD	Z+6,R9
(0133)     }
(0134)     return out;
    0568 01FE      MOVW	R30,R28
    0569 8103      LDD	R16,Z+3
    056A 8114      LDD	R17,Z+4
    056B 8125      LDD	R18,Z+5
    056C 8136      LDD	R19,Z+6
    056D 962B      ADIW	R28,0xB
    056E D0C4      RCALL	pop_gset2
    056F 9624      ADIW	R28,4
    0570 9508      RET
(0135) }
(0136) 
(0137) /* * * * * 以下是对IIC总线的操作子程序 * * * * */   
(0138) /* * * * * * 启动总线 * * * * */   
(0139) static void start(void)    
(0140) {    
(0141)     //SCL=0; /* SCL处于高电平时,SDA从高电平转向低电平表示 */   
(0142)     //CLR_SCL;
(0143)     //SDA=1; /* 一个"开始"状态,该状态必须在其他命令之前执行 */   
(0144)     SET_SDA;
_start:
    0571 9AAE      SBI	0x15,6
(0145)     NOP();
    0572 0000      NOP
    0573 940E07EA  CALL	0x7EA
(0146)     //SCL=1;
(0147)     SET_SCL;
(0148)     NOP(); NOP(); NOP();    
(0149)     //SDA=0;
(0150)     CLR_SDA;
    0575 B385      IN	R24,0x15
    0576 7B8F      ANDI	R24,0xBF
    0577 BB85      OUT	0x15,R24
    0578 940E07C1  CALL	0x7C1
(0151)     NOP(); NOP(); NOP(); NOP();    
(0152)     //SCL=0;
(0153)     CLR_SCL;
(0154)     //SDA=1;
(0155)     //SET_SDA;
(0156) 
(0157)     return;
    057A 9508      RET
(0158) }    
(0159)    
(0160) /* * * * * 停止IIC总线 * * * * */   
(0161) static void stop(void)    
(0162) {     
(0163)     //SCL=0; /*SCL处于高电平时,SDA从低电平转向高电平 */
(0164)     //CLR_SCL;   
(0165)     //SDA=0; /*表示一个"停止"状态,该状态终止所有通讯 */
(0166)     CLR_SDA;
_stop:
    057B B385      IN	R24,0x15
    057C 7B8F      ANDI	R24,0xBF
    057D BB85      OUT	0x15,R24
(0167)     NOP();
    057E 0000      NOP
    057F 940E07EA  CALL	0x7EA
(0168)     //SCL=1;
(0169)     SET_SCL;
(0170)     NOP(); NOP(); NOP(); /* 空操作 */
(0171)     //SDA=1;
(0172)     SET_SDA;
    0581 9AAE      SBI	0x15,6
(0173)     NOP(); NOP(); NOP();
    0582 0000      NOP
    0583 0000      NOP
    0584 0000      NOP
(0174)     //SCL=0;
(0175)     //CLR_SCL;
(0176)     
(0177)     return;
    0585 9508      RET
(0178) }    
(0179)    
(0180) /* * * * * 检查应答位 * * * * */   
(0181) static unsigned char recAck(void)    
(0182) {
(0183)     unsigned char result;
(0184)      unsigned char i=0;
_recAck:
  result               --> R16
  i                    --> R16
    0586 2700      CLR	R16
    0587 940E084E  CALL	0x84E
(0185)     
(0186)     //SCL=0;
(0187)     //CLR_SCL;   
(0188)     //SDA=1;
(0189)     SET_SDA;
(0190)     SDA_IN;
(0191)     //SCL=1;
(0192)     SET_SCL;
    0589 9AAF      SBI	0x15,7
    058A 940E07CF  CALL	0x7CF
(0193)     //change sda input mode.
(0194)     NOP(); NOP(); NOP(); NOP();
    058C C001      RJMP	0x058E
(0195)     //CY=SDA;     /* 因为返回值总是放在CY中的 */
(0196)     while(TEST_SDA&&(i>250)) i++;
    058D 9503      INC	R16
    058E 9B9E      SBIS	0x13,6
    058F C003      RJMP	0x0593
    0590 E021      LDI	R18,1
    0591 E030      LDI	R19,0
    0592 C002      RJMP	0x0595
    0593 2722      CLR	R18
    0594 2733      CLR	R19
    0595 3020      CPI	R18,0
    0596 0723      CPC	R18,R19
    0597 F019      BEQ	0x059B
    0598 EF8A      LDI	R24,0xFA
    0599 1780      CP	R24,R16
    059A F390      BCS	0x058D
(0197)     result = TEST_SDA;
    059B 9B9E      SBIS	0x13,6
    059C C003      RJMP	0x05A0
    059D E001      LDI	R16,1
    059E E010      LDI	R17,0
    059F C002      RJMP	0x05A2
    05A0 2700      CLR	R16
    05A1 2711      CLR	R17
(0198)     //SCL=0;
(0199)     CLR_SCL;
    05A2 B385      IN	R24,0x15
    05A3 778F      ANDI	R24,0x7F
    05A4 BB85      OUT	0x15,R24
(0200)     //SDA_OUT;
(0201)     SDA_OUT;
    05A5 9AA6      SBI	0x14,6
(0202)     return result;
    05A6 9508      RET
(0203) }    
(0204)    
(0205) /* * * * *对IIC总线产生应答 * * * * */   
(0206) static void ack(void)    
(0207) {     
(0208)     //SDA=0; /* EEPROM通过在收到每个地址或数据之后, */
(0209)     CLR_SDA;
_ack:
    05A7 B385      IN	R24,0x15
    05A8 7B8F      ANDI	R24,0xBF
    05A9 BB85      OUT	0x15,R24
(0210)     //SCL=1; /* 置SDA低电平的方式确认表示收到读SDA口状态 */
(0211)     SET_SCL;
    05AA 9AAF      SBI	0x15,7
    05AB 940E07C1  CALL	0x7C1
(0212)     NOP(); NOP(); NOP(); NOP();
(0213)     //SCL=0;
(0214)     CLR_SCL;   
(0215)     NOP();
    05AD 0000      NOP
(0216)     //SDA=1;
(0217)     SET_SDA;
    05AE 9AAE      SBI	0x15,6
(0218) 
(0219)     return;
    05AF 9508      RET
(0220) }    
(0221)    
(0222) /* * * * * * * * * 不对IIC总线产生应答 * * * * */   
(0223) static void noAck(void)    
(0224) {    
(0225)     //SDA=1;
(0226)     SET_SDA;
_noAck:
    05B0 9AAE      SBI	0x15,6
(0227)     //SCL=1;
(0228)     SET_SCL;
    05B1 9AAF      SBI	0x15,7
    05B2 940E07C1  CALL	0x7C1
(0229)     NOP(); NOP(); NOP(); NOP();    
(0230)     //SCL=0;
(0231)     CLR_SCL;
(0232)     
(0233)     return;
    05B4 9508      RET
_sendByte:
  mask                 --> R20
  byte                 --> R16
    05B5 D08B      RCALL	push_gset1
(0234) }    
(0235)    
(0236) /* * * * * * * * * 向IIC总线写数据 * * * * */   
(0237) static void sendByte(unsigned char byte)    
(0238) {
(0239)     unsigned char mask = 0x80;
    05B6 E840      LDI	R20,0x80
(0240)     for(;mask>0;)    
    05B7 C011      RJMP	0x05C9
(0241)     {
(0242)         //SCL=0;
(0243)         CLR_SCL;
    05B8 940E0838  CALL	0x838
(0244)         NOP();NOP();
    05BA 0000      NOP
(0245)         if(mask&byte)
    05BB 2E24      MOV	R2,R20
    05BC 2220      AND	R2,R16
    05BD F011      BEQ	0x05C0
(0246)         {
(0247)             //SDA=1;
(0248)             SET_SDA;
    05BE 9AAE      SBI	0x15,6
(0249)         }
    05BF C003      RJMP	0x05C3
(0250)         else
(0251)         {
(0252)             //SDA=0;
(0253)             CLR_SDA;
    05C0 B385      IN	R24,0x15
    05C1 7B8F      ANDI	R24,0xBF
    05C2 BB85      OUT	0x15,R24
(0254)         }
(0255)         mask >>= 1;
    05C3 9546      LSR	R20
(0256)         NOP();NOP();
    05C4 0000      NOP
    05C5 0000      NOP
(0257)         //SCL=1;
(0258)         SET_SCL;
    05C6 9AAF      SBI	0x15,7
(0259)         NOP();NOP();
    05C7 0000      NOP
    05C8 0000      NOP
    05C9 2422      CLR	R2
    05CA 1624      CP	R2,R20
    05CB F360      BCS	0x05B8
(0260)     }
(0261)     //SCL=0;
(0262)     CLR_SCL;
    05CC B385      IN	R24,0x15
    05CD 778F      ANDI	R24,0x7F
    05CE BB85      OUT	0x15,R24
(0263) 
(0264)     return;
    05CF D074      RCALL	pop_gset1
    05D0 9508      RET
_receiveByte:
  i                    --> R16
  receivebyte          --> R18
    05D1 D06F      RCALL	push_gset1
(0265) }
(0266)    
(0267) /* * * * * * * * * 从IIC总线上读数据子程序 * * * * */   
(0268) static unsigned char receiveByte(void)    
(0269) {     
(0270)     unsigned char receivebyte = 0, i=8;     
    05D2 2722      CLR	R18
    05D3 E008      LDI	R16,0x8
(0271)     //SCL=0;
(0272)     CLR_SCL;
    05D4 B385      IN	R24,0x15
    05D5 778F      ANDI	R24,0x7F
    05D6 BB85      OUT	0x15,R24
    05D7 940E084E  CALL	0x84E
(0273)     //SDA = 1;
(0274)     SET_SDA;
(0275)     SDA_IN;
(0276)     NOP();NOP();
    05D9 0000      NOP
    05DA 0000      NOP
    05DB C013      RJMP	0x05EF
(0277)     while(i--)    
(0278)     {     
(0279)         //SCL=1;
(0280)         SET_SCL;
    05DC 9AAF      SBI	0x15,7
(0281)         NOP();NOP();
    05DD 0000      NOP
    05DE 0000      NOP
(0282)         receivebyte = (receivebyte <<1 ) | TEST_SDA;
    05DF 9B9E      SBIS	0x13,6
    05E0 C003      RJMP	0x05E4
    05E1 E041      LDI	R20,1
    05E2 E050      LDI	R21,0
    05E3 C002      RJMP	0x05E6
    05E4 2744      CLR	R20
    05E5 2755      CLR	R21
    05E6 2E22      MOV	R2,R18
    05E7 2433      CLR	R3
    05E8 0C22      LSL	R2
    05E9 1C33      ROL	R3
    05EA 2A24      OR	R2,R20
    05EB 2A35      OR	R3,R21
    05EC 2D22      MOV	R18,R2
    05ED 940E0838  CALL	0x838
    05EF 2E20      MOV	R2,R16
    05F0 2433      CLR	R3
    05F1 5001      SUBI	R16,1
    05F2 2022      TST	R2
    05F3 F741      BNE	0x05DC
(0283)         //SCL=0;
(0284)         CLR_SCL;
(0285)         NOP();
(0286)     }
(0287)     SDA_OUT;
    05F4 9AA6      SBI	0x14,6
(0288)     return receivebyte;    
    05F5 2F02      MOV	R16,R18
    05F6 D04D      RCALL	pop_gset1
    05F7 9508      RET
FILE: D:\yang-home-shanghai\smarthome\门禁系统资料\code\uart.c
(0001) #include<iom16v.h>
(0002) #include <macros.h>
(0003) 
(0004) #include "uart.h"
(0005) 
(0006) //uart0 init. for printf.
(0007) void uart0_init(void)
(0008) {
(0009)     UCSRB = 0x00;                //禁止UART发送和接收
_uart0_init:
    05F8 2422      CLR	R2
    05F9 B82A      OUT	0x0A,R2
(0010)     UCSRA = 0x02;               //倍速
    05FA E082      LDI	R24,2
    05FB B98B      OUT	0x0B,R24
(0011)     UCSRC = 0x06;                //8位数据
    05FC E086      LDI	R24,6
    05FD BD80      OUT	0x20,R24
(0012)     UBRRL = 0x67;                 //9600bps
    05FE E687      LDI	R24,0x67
    05FF B989      OUT	0x09,R24
(0013)     UBRRH = 0x00;
    0600 BC20      OUT	0x20,R2
(0014)     UCSRB = 0x18;
FILE: <library>
    0601 E188      LDI	R24,0x18
    0602 B98A      OUT	0x0A,R24
    0603 9508      RET
push_arg4:
    0604 940E086B  CALL	0x86B
push_arg2:
    0606 9508      RET
empy32s:
empy32u:
    0607 D059      RCALL	long_prolog
    0608 927F      PUSH	R7
    0609 D070      RCALL	tstzero1
    060A F131      BEQ	0x0631
    060B 2477      CLR	R7
    060C D073      RCALL	tstzero2
    060D F419      BNE	0x0611
    060E 018C      MOVW	R16,R24
    060F 019D      MOVW	R18,R26
    0610 C020      RJMP	0x0631
    0611 9F08      MUL	R16,R24
    0612 2CB0      MOV	R11,R0
    0613 2CA1      MOV	R10,R1
    0614 9F28      MUL	R18,R24
    0615 2C90      MOV	R9,R0
    0616 2C81      MOV	R8,R1
    0617 9F18      MUL	R17,R24
    0618 0CA0      ADD	R10,R0
    0619 1C91      ADC	R9,R1
    061A 1C87      ADC	R8,R7
    061B 9F09      MUL	R16,R25
    061C 0CA0      ADD	R10,R0
    061D 1C91      ADC	R9,R1
    061E 1C87      ADC	R8,R7
    061F 9F19      MUL	R17,R25
    0620 0C90      ADD	R9,R0
    0621 1C81      ADC	R8,R1
    0622 9F0A      MUL	R16,R26
    0623 0C90      ADD	R9,R0
    0624 1C81      ADC	R8,R1
    0625 9F38      MUL	R19,R24
    0626 0C80      ADD	R8,R0
    0627 9F29      MUL	R18,R25
    0628 0C80      ADD	R8,R0
    0629 9F1A      MUL	R17,R26
    062A 0C80      ADD	R8,R0
    062B 9F0B      MUL	R16,R27
    062C 0C80      ADD	R8,R0
    062D 2D0B      MOV	R16,R11
    062E 2D1A      MOV	R17,R10
    062F 2D29      MOV	R18,R9
    0630 2D38      MOV	R19,R8
    0631 907F      POP	R7
    0632 C03C      RJMP	long_epilog
pop_gset2:
    0633 E0E2      LDI	R30,2
    0634 C010      RJMP	pop
pop_gset3:
    0635 E0E4      LDI	R30,4
    0636 C00E      RJMP	pop
pop_gset5:
    0637 27EE      CLR	R30
    0638 C00C      RJMP	pop
push_gset5:
    0639 92FA      ST	R15,-Y
    063A 92EA      ST	R14,-Y
push_gset4:
    063B 92DA      ST	R13,-Y
    063C 92CA      ST	R12,-Y
push_gset3:
    063D 92BA      ST	R11,-Y
    063E 92AA      ST	R10,-Y
push_gset2:
    063F 937A      ST	R23,-Y
    0640 936A      ST	R22,-Y
push_gset1:
    0641 935A      ST	R21,-Y
    0642 934A      ST	R20,-Y
    0643 9508      RET
pop_gset1:
    0644 E0E1      LDI	R30,1
pop:
    0645 9149      LD	R20,Y+
    0646 9159      LD	R21,Y+
    0647 FDE0      SBRC	R30,0
    0648 9508      RET
    0649 9169      LD	R22,Y+
    064A 9179      LD	R23,Y+
    064B FDE1      SBRC	R30,1
    064C 9508      RET
    064D 90A9      LD	R10,Y+
    064E 90B9      LD	R11,Y+
    064F FDE2      SBRC	R30,2
    0650 9508      RET
    0651 90C9      LD	R12,Y+
    0652 90D9      LD	R13,Y+
    0653 FDE3      SBRC	R30,3
    0654 9508      RET
    0655 90E9      LD	R14,Y+
    0656 90F9      LD	R15,Y+
    0657 9508      RET
xicall:
    0658 920A      ST	R0,-Y
    0659 95C8      LPM
    065A 920A      ST	R0,-Y
    065B 9631      ADIW	R30,1
    065C 95C8      LPM
    065D 2DF0      MOV	R31,R0
    065E 91E9      LD	R30,Y+
    065F 9009      LD	R0,Y+
    0660 9409      IJMP
long_prolog:
    0661 928A      ST	R8,-Y
    0662 929A      ST	R9,-Y
    0663 92AA      ST	R10,-Y
    0664 92BA      ST	R11,-Y
    0665 93EA      ST	R30,-Y
    0666 938A      ST	R24,-Y
    0667 939A      ST	R25,-Y
    0668 93AA      ST	R26,-Y
    0669 93BA      ST	R27,-Y
    066A 8589      LDD	R24,Y+9
    066B 859A      LDD	R25,Y+10
    066C 85AB      LDD	R26,Y+11
    066D 85BC      LDD	R27,Y+12
    066E 9508      RET
long_epilog:
    066F 91B9      LD	R27,Y+
    0670 91A9      LD	R26,Y+
    0671 9199      LD	R25,Y+
    0672 9189      LD	R24,Y+
    0673 91E9      LD	R30,Y+
    0674 90B9      LD	R11,Y+
    0675 90A9      LD	R10,Y+
    0676 9099      LD	R9,Y+
    0677 9089      LD	R8,Y+
    0678 9624      ADIW	R28,4
    0679 9508      RET
tstzero1:
    067A 27EE      CLR	R30
    067B 2BE0      OR	R30,R16
    067C 2BE1      OR	R30,R17
    067D 2BE2      OR	R30,R18
    067E 2BE3      OR	R30,R19
    067F 9508      RET
tstzero2:
    0680 27EE      CLR	R30
    0681 2BE8      OR	R30,R24
    0682 2BE9      OR	R30,R25
    0683 2BEA      OR	R30,R26
    0684 2BEB      OR	R30,R27
    0685 9508      RET
push_lset:
    0686 93FA      ST	R31,-Y
    0687 93EA      ST	R30,-Y
    0688 93BA      ST	R27,-Y
    0689 93AA      ST	R26,-Y
    068A 939A      ST	R25,-Y
    068B 938A      ST	R24,-Y
    068C 940E086B  CALL	0x86B
    068E 929A      ST	R9,-Y
    068F 928A      ST	R8,-Y
    0690 927A      ST	R7,-Y
    0691 926A      ST	R6,-Y
    0692 940E0884  CALL	0x884
    0694 921A      ST	R1,-Y
    0695 920A      ST	R0,-Y
    0696 B60F      IN	R0,0x3F
    0697 920A      ST	R0,-Y
    0698 9508      RET
pop_lset:
    0699 9009      LD	R0,Y+
    069A BE0F      OUT	0x3F,R0
    069B 9009      LD	R0,Y+
    069C 9019      LD	R1,Y+
    069D 9029      LD	R2,Y+
    069E 9039      LD	R3,Y+
    069F 9049      LD	R4,Y+
    06A0 9059      LD	R5,Y+
    06A1 9069      LD	R6,Y+
    06A2 9079      LD	R7,Y+
    06A3 9089      LD	R8,Y+
    06A4 9099      LD	R9,Y+
    06A5 9109      LD	R16,Y+
    06A6 9119      LD	R17,Y+
    06A7 9129      LD	R18,Y+
    06A8 9139      LD	R19,Y+
    06A9 9189      LD	R24,Y+
    06AA 9199      LD	R25,Y+
    06AB 91A9      LD	R26,Y+
    06AC 91B9      LD	R27,Y+
    06AD 91E9      LD	R30,Y+
    06AE 91F9      LD	R31,Y+
    06AF 9508      RET
lsl32:
    06B0 920F      PUSH	R0
    06B1 9009      LD	R0,Y+
    06B2 2000      TST	R0
    06B3 F031      BEQ	0x06BA
    06B4 0F00      LSL	R16
    06B5 1F11      ROL	R17
    06B6 1F22      ROL	R18
    06B7 1F33      ROL	R19
    06B8 940A      DEC	R0
    06B9 CFF8      RJMP	0x06B2
    06BA 900F      POP	R0
    06BB 9508      RET
lsr32:
    06BC 920F      PUSH	R0
    06BD 9009      LD	R0,Y+
    06BE 2000      TST	R0
    06BF F031      BEQ	0x06C6
    06C0 9536      LSR	R19
    06C1 9527      ROR	R18
    06C2 9517      ROR	R17
    06C3 9507      ROR	R16
    06C4 940A      DEC	R0
    06C5 CFF8      RJMP	0x06BE
    06C6 900F      POP	R0
    06C7 9508      RET
asgncblk:
    06C8 93AA      ST	R26,-Y
    06C9 93BA      ST	R27,-Y
    06CA 93EA      ST	R30,-Y
    06CB 93FA      ST	R31,-Y
    06CC 920A      ST	R0,-Y
    06CD 81AF      LDD	R26,Y+7
    06CE 85B8      LDD	R27,Y+8
    06CF 81ED      LDD	R30,Y+5
    06D0 81FE      LDD	R31,Y+6
    06D1 3000      CPI	R16,0
    06D2 0701      CPC	R16,R17
    06D3 F031      BEQ	0x06DA
    06D4 95C8      LPM
    06D5 920D      ST	R0,X+
    06D6 9631      ADIW	R30,1
    06D7 5001      SUBI	R16,1
    06D8 4010      SBCI	R17,0
    06D9 CFF7      RJMP	0x06D1
    06DA 9009      LD	R0,Y+
    06DB 91F9      LD	R31,Y+
    06DC 91E9      LD	R30,Y+
    06DD 91B9      LD	R27,Y+
    06DE 91A9      LD	R26,Y+
    06DF 9624      ADIW	R28,4
    06E0 9508      RET
asgnblk:
    06E1 93AA      ST	R26,-Y
    06E2 93BA      ST	R27,-Y
    06E3 93EA      ST	R30,-Y
    06E4 93FA      ST	R31,-Y
    06E5 920A      ST	R0,-Y
    06E6 81AF      LDD	R26,Y+7
    06E7 85B8      LDD	R27,Y+8
    06E8 81ED      LDD	R30,Y+5
    06E9 81FE      LDD	R31,Y+6
    06EA 3000      CPI	R16,0
    06EB 0701      CPC	R16,R17
    06EC F029      BEQ	0x06F2
    06ED 9001      LD	R0,Z+
    06EE 920D      ST	R0,X+
    06EF 5001      SUBI	R16,1
    06F0 4010      SBCI	R17,0
    06F1 CFF8      RJMP	0x06EA
    06F2 9009      LD	R0,Y+
    06F3 91F9      LD	R31,Y+
    06F4 91E9      LD	R30,Y+
    06F5 91B9      LD	R27,Y+
    06F6 91A9      LD	R26,Y+
    06F7 9624      ADIW	R28,4
    06F8 9508      RET
<created procedures>:
    06F9 2433      CLR	R3
    06FA 2444      CLR	R4
    06FB 2455      CLR	R5
    06FC 01FE      MOVW	R30,R28
    06FD 8063      LDD	R6,Z+3
    06FE 8074      LDD	R7,Z+4
    06FF 8085      LDD	R8,Z+5
    0700 8096      LDD	R9,Z+6
    0701 2862      OR	R6,R2
    0702 2873      OR	R7,R3
    0703 2884      OR	R8,R4
    0704 2895      OR	R9,R5
    0705 01FE      MOVW	R30,R28
    0706 8263      STD	Z+3,R6
    0707 8274      STD	Z+4,R7
    0708 8285      STD	Z+5,R8
    0709 8296      STD	Z+6,R9
    070A E088      LDI	R24,0x8
    070B E090      LDI	R25,0
    070C 01FE      MOVW	R30,R28
    070D 8023      LDD	R2,Z+3
    070E 8034      LDD	R3,Z+4
    070F 8045      LDD	R4,Z+5
    0710 8056      LDD	R5,Z+6
    0711 938A      ST	R24,-Y
    0712 0181      MOVW	R16,R2
    0713 0192      MOVW	R18,R4
    0714 9508      RET
    0715 8628      STD	Y+8,R2
    0716 8639      STD	Y+9,R3
    0717 864A      STD	Y+10,R4
    0718 865B      STD	Y+11,R5
    0719 9040006C  LDS	R4,passwordH+2
    071B 9050006D  LDS	R5,passwordH+3
    071D 9020006A  LDS	R2,passwordH
    071F 9030006B  LDS	R3,passwordH+1
    0721 822C      STD	Y+4,R2
    0722 823D      STD	Y+5,R3
    0723 824E      STD	Y+6,R4
    0724 825F      STD	Y+7,R5
    0725 9508      RET
    0726 E050      LDI	R21,0
    0727 E060      LDI	R22,0
    0728 E070      LDI	R23,0
    0729 01FE      MOVW	R30,R28
    072A 9508      RET
    072B E040      LDI	R20,0
    072C E050      LDI	R21,0
    072D E060      LDI	R22,0
    072E E070      LDI	R23,0
    072F 8748      STD	Y+8,R20
    0730 8759      STD	Y+9,R21
    0731 876A      STD	Y+10,R22
    0732 877B      STD	Y+11,R23
    0733 E040      LDI	R20,0
    0734 E050      LDI	R21,0
    0735 E060      LDI	R22,0
    0736 E070      LDI	R23,0
    0737 834C      STD	Y+4,R20
    0738 835D      STD	Y+5,R21
    0739 836E      STD	Y+6,R22
    073A 837F      STD	Y+7,R23
    073B 01FE      MOVW	R30,R28
    073C A820      LDD	R2,Z+48
    073D A831      LDD	R3,Z+49
    073E A842      LDD	R4,Z+50
    073F A853      LDD	R5,Z+51
    0740 8228      STD	Y+0,R2
    0741 8239      STD	Y+1,R3
    0742 824A      STD	Y+2,R4
    0743 825B      STD	Y+3,R5
    0744 9508      RET
    0745 9040006C  LDS	R4,passwordH+2
    0747 9050006D  LDS	R5,passwordH+3
    0749 9020006A  LDS	R2,passwordH
    074B 9030006B  LDS	R3,passwordH+1
    074D 9508      RET
    074E E040      LDI	R20,0
    074F E050      LDI	R21,0
    0750 E060      LDI	R22,0
    0751 E070      LDI	R23,0
    0752 9508      RET
    0753 90400062  LDS	R4,id_code+2
    0755 90500063  LDS	R5,id_code+3
    0757 90200060  LDS	R2,id_code
    0759 90300061  LDS	R3,id_code+1
    075B 0C22      LSL	R2
    075C 1C33      ROL	R3
    075D 1C44      ROL	R4
    075E 1C55      ROL	R5
    075F 92300061  STS	id_code+1,R3
    0761 92200060  STS	id_code,R2
    0763 92500063  STS	id_code+3,R5
    0765 92400062  STS	id_code+2,R4
    0767 9508      RET
    0768 92300061  STS	id_code+1,R3
    076A 92200060  STS	id_code,R2
    076C 92500063  STS	id_code+3,R5
    076E 92400062  STS	id_code+2,R4
    0770 9508      RET
    0771 90400070  LDS	R4,passwordL+2
    0773 90500071  LDS	R5,passwordL+3
    0775 9020006E  LDS	R2,passwordL
    0777 9030006F  LDS	R3,passwordL+1
    0779 9508      RET
    077A E00D      LDI	R16,0xD
    077B E010      LDI	R17,0
    077C 93FA      ST	R31,-Y
    077D 93EA      ST	R30,-Y
    077E 939A      ST	R25,-Y
    077F 938A      ST	R24,-Y
    0780 940E06E1  CALL	asgnblk
    0782 019E      MOVW	R18,R28
    0783 9508      RET
    0784 01F0      MOVW	R30,R0
    0785 E783      LDI	R24,0x73
    0786 E090      LDI	R25,0
    0787 0FE8      ADD	R30,R24
    0788 1FF9      ADC	R31,R25
    0789 9508      RET
    078A 90400062  LDS	R4,id_code+2
    078C 90500063  LDS	R5,id_code+3
    078E 90200060  LDS	R2,id_code
    0790 90300061  LDS	R3,id_code+1
    0792 9508      RET
    0793 E041      LDI	R20,1
    0794 E050      LDI	R21,0
    0795 E060      LDI	R22,0
    0796 E070      LDI	R23,0
    0797 9508      RET
    0798 B388      IN	R24,0x18
    0799 7D8F      ANDI	R24,0xDF
    079A BB88      OUT	0x18,R24
    079B E604      LDI	R16,0x64
    079C E010      LDI	R17,0
    079D 9508      RET
    079E 01FE      MOVW	R30,R28
    079F 8427      LDD	R2,Z+15
    07A0 8830      LDD	R3,Z+16
    07A1 8841      LDD	R4,Z+17
    07A2 8852      LDD	R5,Z+18
    07A3 9508      RET
    07A4 A820      LDD	R2,Z+48
    07A5 A831      LDD	R3,Z+49
    07A6 A842      LDD	R4,Z+50
    07A7 A853      LDD	R5,Z+51
    07A8 9508      RET
    07A9 2224      AND	R2,R20
    07AA 2235      AND	R3,R21
    07AB 2246      AND	R4,R22
    07AC 2257      AND	R5,R23
    07AD 9508      RET
    07AE 8741      STD	Z+9,R20
    07AF 8752      STD	Z+10,R21
    07B0 8763      STD	Z+11,R22
    07B1 8774      STD	Z+12,R23
    07B2 01CE      MOVW	R24,R28
    07B3 01FE      MOVW	R30,R28
    07B4 9508      RET
    07B5 01FE      MOVW	R30,R28
    07B6 8C22      LDD	R2,Z+26
    07B7 8C33      LDD	R3,Z+27
    07B8 8C44      LDD	R4,Z+28
    07B9 8C55      LDD	R5,Z+29
    07BA 8228      STD	Y+0,R2
    07BB 8239      STD	Y+1,R3
    07BC 824A      STD	Y+2,R4
    07BD 825B      STD	Y+3,R5
    07BE 91200068  LDS	R18,current_index
    07C0 9508      RET
    07C1 0000      NOP
    07C2 0000      NOP
    07C3 0000      NOP
    07C4 0000      NOP
    07C5 B385      IN	R24,0x15
    07C6 778F      ANDI	R24,0x7F
    07C7 BB85      OUT	0x15,R24
    07C8 9508      RET
    07C9 E081      LDI	R24,1
    07CA 838A      STD	Y+2,R24
    07CB E08D      LDI	R24,0xD
    07CC 9F86      MUL	R24,R22
    07CD 01C0      MOVW	R24,R0
    07CE 9508      RET
    07CF 0000      NOP
    07D0 0000      NOP
    07D1 0000      NOP
    07D2 0000      NOP
    07D3 9508      RET
    07D4 8427      LDD	R2,Z+15
    07D5 8830      LDD	R3,Z+16
    07D6 8841      LDD	R4,Z+17
    07D7 8852      LDD	R5,Z+18
    07D8 9508      RET
    07D9 01F0      MOVW	R30,R0
    07DA E785      LDI	R24,0x75
    07DB E090      LDI	R25,0
    07DC 0FE8      ADD	R30,R24
    07DD 1FF9      ADC	R31,R25
    07DE 9508      RET
    07DF 2422      CLR	R2
    07E0 822A      STD	Y+2,R2
    07E1 E08D      LDI	R24,0xD
    07E2 9F86      MUL	R24,R22
    07E3 01C0      MOVW	R24,R0
    07E4 9508      RET
    07E5 1462      CP	R6,R2
    07E6 0473      CPC	R7,R3
    07E7 0484      CPC	R8,R4
    07E8 0495      CPC	R9,R5
    07E9 9508      RET
    07EA 9AAF      SBI	0x15,7
    07EB 0000      NOP
    07EC 0000      NOP
    07ED 0000      NOP
    07EE 9508      RET
    07EF 01FE      MOVW	R30,R28
    07F0 8345      STD	Z+5,R20
    07F1 8356      STD	Z+6,R21
    07F2 8367      STD	Z+7,R22
    07F3 8770      STD	Z+8,R23
    07F4 9508      RET
    07F5 EF4F      LDI	R20,0xFF
    07F6 E050      LDI	R21,0
    07F7 E060      LDI	R22,0
    07F8 E070      LDI	R23,0
    07F9 9508      RET
    07FA 9350006F  STS	passwordL+1,R21
    07FC 9340006E  STS	passwordL,R20
    07FE 93700071  STS	passwordL+3,R23
    0800 93600070  STS	passwordL+2,R22
    0802 9508      RET
    0803 8341      STD	Z+1,R20
    0804 8352      STD	Z+2,R21
    0805 8363      STD	Z+3,R22
    0806 8374      STD	Z+4,R23
    0807 9508      RET
    0808 8345      STD	Z+5,R20
    0809 8356      STD	Z+6,R21
    080A 8367      STD	Z+7,R22
    080B 8770      STD	Z+8,R23
    080C 9508      RET
    080D 880B      LDD	R0,Y+19
    080E 881C      LDD	R1,Y+20
    080F 8219      STD	Y+1,R1
    0810 8208      STD	Y+0,R0
    0811 E024      LDI	R18,4
    0812 018E      MOVW	R16,R28
    0813 5F09      SUBI	R16,0xF9
    0814 4F1F      SBCI	R17,0xFF
    0815 9508      RET
    0816 91800069  LDS	R24,input_err_count
    0818 5F8F      SUBI	R24,0xFF
    0819 93800069  STS	input_err_count,R24
    081B 9508      RET
    081C B388      IN	R24,0x18
    081D 7D8F      ANDI	R24,0xDF
    081E BB88      OUT	0x18,R24
    081F E900      LDI	R16,0x90
    0820 E011      LDI	R17,1
    0821 9508      RET
    0822 01FE      MOVW	R30,R28
    0823 8303      STD	Z+3,R16
    0824 8314      STD	Z+4,R17
    0825 8325      STD	Z+5,R18
    0826 8336      STD	Z+6,R19
    0827 9508      RET
    0828 2433      CLR	R3
    0829 8239      STD	Y+1,R3
    082A 8228      STD	Y+0,R2
    082B E021      LDI	R18,1
    082C 018E      MOVW	R16,R28
    082D 5F0D      SUBI	R16,0xFD
    082E 4F1F      SBCI	R17,0xFF
    082F 9508      RET
    0830 E586      LDI	R24,0x56
    0831 E090      LDI	R25,0
    0832 8399      STD	Y+1,R25
    0833 8388      STD	Y+0,R24
    0834 E22C      LDI	R18,0x2C
    0835 E031      LDI	R19,1
    0836 E001      LDI	R16,1
    0837 9508      RET
    0838 B385      IN	R24,0x15
    0839 778F      ANDI	R24,0x7F
    083A BB85      OUT	0x15,R24
    083B 0000      NOP
    083C 9508      RET
    083D 2C2E      MOV	R2,R14
    083E 2433      CLR	R3
    083F 2D82      MOV	R24,R2
    0840 5081      SUBI	R24,1
    0841 2EE8      MOV	R14,R24
    0842 2022      TST	R2
    0843 9508      RET
    0844 8399      STD	Y+1,R25
    0845 8388      STD	Y+0,R24
    0846 E024      LDI	R18,4
    0847 018E      MOVW	R16,R28
    0848 9508      RET
    0849 8399      STD	Y+1,R25
    084A 8388      STD	Y+0,R24
    084B E024      LDI	R18,4
    084C 018A      MOVW	R16,R20
    084D 9508      RET
    084E 9AAE      SBI	0x15,6
    084F B384      IN	R24,0x14
    0850 7B8F      ANDI	R24,0xBF
    0851 BB84      OUT	0x14,R24
    0852 9AAE      SBI	0x15,6
    0853 9508      RET
    0854 2422      CLR	R2
    0855 2433      CLR	R3
    0856 8231      STD	Z+1,R3
    0857 8220      STD	Z+0,R2
    0858 E084      LDI	R24,4
    0859 9508      RET
    085A 91800066  LDS	R24,read_count
    085C 5F8F      SUBI	R24,0xFF
    085D 93800066  STS	read_count,R24
    085F 9508      RET
    0860 E090      LDI	R25,0
    0861 93900065  STS	id_reader_flags+1,R25
    0863 93800064  STS	id_reader_flags,R24
    0865 9508      RET
    0866 2D2C      MOV	R18,R12
    0867 018E      MOVW	R16,R28
    0868 5F04      SUBI	R16,0xF4
    0869 4F1F      SBCI	R17,0xFF
    086A 9508      RET
    086B 933A      ST	R19,-Y
    086C 932A      ST	R18,-Y
    086D 931A      ST	R17,-Y
    086E 930A      ST	R16,-Y
    086F 9508      RET
    0870 9601      ADIW	R24,1
    0871 8399      STD	Y+1,R25
    0872 8388      STD	Y+0,R24
    0873 E021      LDI	R18,1
    0874 9508      RET
    0875 8348      STD	Y+0,R20
    0876 8359      STD	Y+1,R21
    0877 836A      STD	Y+2,R22
    0878 837B      STD	Y+3,R23
    0879 9508      RET
    087A 8343      STD	Z+3,R20
    087B 8354      STD	Z+4,R21
    087C 8365      STD	Z+5,R22
    087D 8376      STD	Z+6,R23
    087E 9508      RET
    087F 1624      CP	R2,R20
    0880 0635      CPC	R3,R21
    0881 0646      CPC	R4,R22
    0882 0657      CPC	R5,R23
    0883 9508      RET
    0884 925A      ST	R5,-Y
    0885 924A      ST	R4,-Y
    0886 923A      ST	R3,-Y
    0887 922A      ST	R2,-Y
    0888 9508      RET
